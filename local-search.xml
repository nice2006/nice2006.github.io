<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>幻象——有趣的句子</title>
    <link href="/2025/03/24/%E5%B9%BB%E8%B1%A1%E2%80%94%E2%80%94%E6%9C%89%E8%B6%A3%E7%9A%84%E5%8F%A5%E5%AD%90/"/>
    <url>/2025/03/24/%E5%B9%BB%E8%B1%A1%E2%80%94%E2%80%94%E6%9C%89%E8%B6%A3%E7%9A%84%E5%8F%A5%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p>赞不绝口的朋友：“哎呀，你这孩子太漂亮了！”<br>妈妈：“噢，这不算什么——你该看看他的照片！”</p><p>从前，读到无聊报纸时，读者会说“今天的世界也太无趣！”<br>今天，他便要抱怨：“这报纸也太无趣！”</p><p>使世界变得有趣已不再是神的责任，而是新闻编辑的责任了。</p><p>我们索要的超过现实世界所能提供的限度，便要求有人编造出什么来补足世界的缺憾。这不过是我们追求幻象的一个例子罢了。</p><p>生动鲜明的图像让苍白的现实失色。</p><p>读者与观众很快就被报道的生动与照片的“真实”所折服，而不再关心被记录的事件是否自然发生。</p><p>但麦考利肯定想象不到记者在 20 世纪美国的崇高地位。他们早早把自己变成了人民的保护者。据说他们拥有超然的态度，没有党派的偏见，紧贴信息的源头，据有缜密清晰的表达能力，又时时刻刻直接接触全体人民，这使他们也成了人民的顾问。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>社科</tag>
      
      <tag>真相</tag>
      
      <tag>传播学</tag>
      
      <tag>《幻象》</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后真相时代</title>
    <link href="/2025/03/24/%E5%90%8E%E7%9C%9F%E7%9B%B8%E6%97%B6%E4%BB%A3/"/>
    <url>/2025/03/24/%E5%90%8E%E7%9C%9F%E7%9B%B8%E6%97%B6%E4%BB%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="第一部分——片面真相：沟通者选择的真相"><a href="#第一部分——片面真相：沟通者选择的真相" class="headerlink" title="第一部分——片面真相：沟通者选择的真相"></a>第一部分——片面真相：沟通者选择的真相</h2><h3 id="复杂性"><a href="#复杂性" class="headerlink" title="复杂性"></a>复杂性</h3><blockquote><p>真相是散落成无数碎片的镜子，每个人都认为自己看到的一小片是完整的真相。<br>——理查德·伯顿</p></blockquote><h4 id="片面真相存在的原因"><a href="#片面真相存在的原因" class="headerlink" title="片面真相存在的原因"></a>片面真相存在的原因</h4><p>生活是极其复杂的，没有人能看到整个画面。无法在形成关于现实的实用理解之前考虑所有可用信，只能进行简化和选择<br>同时我们更倾向于和想法一致的朋友或同事讨论问题，并下意识地滤除与我们想法存在冲突的思想或数据</p><h3 id="复杂性策略"><a href="#复杂性策略" class="headerlink" title="复杂性策略"></a>复杂性策略</h3><h4 id="1-忽略"><a href="#1-忽略" class="headerlink" title="1.忽略"></a>1.忽略</h4><p>忽略分为两大手段</p><ol><li>直接忽略特定真相</li><li>将特定真相”淹没”</li></ol><p>不过需要注意的是：忽略不一定具有误导性，忽略可以提高对事物的认知效率</p><h5 id="忽略真相"><a href="#忽略真相" class="headerlink" title="忽略真相"></a>忽略真相</h5><p>恶意忽略真相常常体现在只描述对自己有利的方向，而不谈及对自己观点不利的方向<br>同时”忽略真相”还可以在众多细节之中抓住要点，提高认知效率。不过需要注意的是，认知效率的提高往往容易导致偏见的产生。<br><strong>示例</strong><br>“我们相信，亚马逊利用自己的主导地位伤害了美国读者的利益，压榨了整个图书行业的利润，影响了许多作家的职业生涯（并使他们产生了恐惧），阻碍了思想在我们这个社会中的自由流动。”然而，他们并没有提及亚马逊为许多作家和小型出版商提供了丰富的机遇，也没有考虑到亚马逊在其他领域的伟大成就。</p><h5 id="“淹没”真相"><a href="#“淹没”真相" class="headerlink" title="“淹没”真相"></a>“淹没”真相</h5><p>淹没真相往往将对自己不利的真相与对自己有利的真相相提并论，并强调对自己有利的方向更为重要<br><strong>示例</strong><br>“是的，我们的税收政策的确对残疾人不利，但是残疾人目前的就业人数比过去任何时候都要多，科技的发展也在为残疾人提供越来越大的帮助”这三句都是事实，然而第二个和第三个事实无法改变第一个事实</p><h4 id="2-混淆"><a href="#2-混淆" class="headerlink" title="2.混淆"></a>2.混淆</h4><p>混淆的关键在于将事件的注意力从原本的真相中转移，那么这要求用于混淆的真相越能挑起群众的神经越好<br>不过需要注意的是：在混淆之前一定要对引入的无关真相进行仔细选择，有些无关真相有可能会造成意想不到的伤害</p><h4 id="3-关联"><a href="#3-关联" class="headerlink" title="3.关联"></a>3.关联</h4><p>关联的目的在于使人们觉得两个或更多无关真相之间存在联系，通过巧妙的选择一系列看似有联系的真相，将目标与无关真相绑定起来<br>关联容易让人们产生对现实的虚假想象，而这种想象来源于作者对一系列真相的精心编排。作者是不需要说谎就能达到效果的。<br>同时需要注意的是：在互联网时代，周围人员和组织的信息越来越容易可以被公开获取，我们越来越容易通过与他人片面真相的关联而受到不公正的贬低，宣传对手可以通过宣传周围人员的片面真相而对我们造成伤害。<br><strong>示例</strong><br>“克里斯·休恩在担任能源和气候变化部长期间支持木质颗粒绿色补贴。2013 年，62 岁的休恩先生由于滥用司法程序而被监禁”，克里斯·休恩由于对一次违章驾驶撒谎（有趣的是，原文中被称为“滥用司法程序”）而被定罪，这与绿色补贴没有任何关系。《泰晤士报》将这两个不相关的真相结合在一起，使人们觉得休恩在推动这项政策时采取了恶意行为。</p><h3 id="复杂性总结"><a href="#复杂性总结" class="headerlink" title="复杂性总结"></a>复杂性总结</h3><p>复杂性无处不在，事物具有的多面性超出了我们大多数人的想象。当我们听到以“……是……”开头时，只需要考虑这些话语谈论的事物具有的复杂性、多样性以及矛盾性。也许这些话语的确反映了某种真相，但我们一定可以在同样的事物中得出其他许多竞争性真相。<br>我们需要对政客、评论家和社会活动家保持警惕，因为他们一定会呈现出最适合自己的局部。<br>同时，我们也可以从复杂的主题中选择简单的真相，从而更有效的表达自己，这样的简化和选择对于沟通者和听众都是一件好事</p><h4 id="如何应用于现实"><a href="#如何应用于现实" class="headerlink" title="如何应用于现实"></a>如何应用于现实</h4><ul><li>考虑任何重要问题的许多不同方面，均衡地寻找各种不同观点</li><li>选择哪些可以支持你的观点，又不会歪曲你所传达的现实的真相</li><li>通过忽略真相使问题变得更加清晰，但是注意不要误导听众</li></ul><h4 id="当心……"><a href="#当心……" class="headerlink" title="当心……"></a>当心……</h4><ul><li>将重要真相淹没在不相关海洋中的误导者</li><li>仅仅通过关联，攻击人和项目的误导者</li></ul><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><blockquote><p>谁控制了过去，谁就控制了未来。谁控制了现在，谁就控制了过去。<br>——乔治·奥威尔</p></blockquote><h3 id="历史策略"><a href="#历史策略" class="headerlink" title="历史策略"></a>历史策略</h3><h4 id="1-忘记过去"><a href="#1-忘记过去" class="headerlink" title="1.忘记过去"></a>1.忘记过去</h4><p>强制性的遗忘很难实现，此时在脑海中已经存在历史的记忆。但是沟通者可以引导我们远离不符合他们需要的历史真相。其中最简单的方法就是漏掉使你感到不便的部分（此处指忽略特定历史的整体）。忽略过去的罪恶可以回避批评，忽略或淡化对手的成功也可以用来削弱对手。同时偏差选择是最常见的形式，我们天生就具备这项技能，选择性历史叙述极具误导性（此处指选择性的讲述特定历史的某一片面真相）<br><strong>示例</strong><br>“重要技术被开发出来，尤其是在交通运输、餐具和个人卫生领域。民主制度蓬勃发展，许多人加入了工会，获得了选举权，社会变得更加公平。许多穷人的膳食得到了改善，他们变得更加健康和强壮。婴儿死亡率下降，人均寿命上升。酗酒人数有所下降。工作岗位，尤其是女性岗位有所增加，着增进了性别平等”这段话讨论的是第一次世界大战。</p><h4 id="2-有选择的记忆过去"><a href="#2-有选择的记忆过去" class="headerlink" title="2.有选择的记忆过去"></a>2.有选择的记忆过去</h4><p>历史是由无数真相组成的，我们没有能力了解任一历史事件的所有真相，对特定真相的选择决定了对过去的理解，而对过去的理解又会影响现在的行动，它塑造了我们的身份，影响了我们的思考方式。<br>通过选择，我们改变历史。当加入当前意图时，可以将过去塑造成几乎任何形式<br>误导者也可以仅仅谈论他们发现的一个真相，从而很大程度的歪曲历史。<br><strong>示例</strong><br>面对西贡的陷落，羞耻感成为绝大多数美国人的反应。他们选择遗忘掉这段历史，尽管作为军事行动，这是一次引人瞩目的成就：直升机小组夜以继日勤奋工作，从西贡撤出了 1373 名美国人、5595 名越南人和其他国家的公民。<br>面对敦刻尔克大撤退，英国人自豪的回顾起由渔船、私人游艇组成的开往法国海岸的小型船队以及它们所救出的数千名勇敢的士兵。他们选择自豪的回顾历史，尽管在法国战场上英国军队遭受了毁灭性的失败。<br>面对“百年国耻”，中国人则选择群情激愤的回顾这段历史，中国政府将这段历史的每一个细节深深的印在国民意识中。侵华日军南京大屠杀遇难同胞纪念馆是这座历史都城访问人数最多的地点。<br>对历史的选择造就了三个国家不同的身份认同</p><h3 id="历史总结"><a href="#历史总结" class="headerlink" title="历史总结"></a>历史总结</h3><p>历史决定了个人、组织或者国家的身份从何而来，通过忘记或者选择性的记忆，历史可以被无限改写</p><h4 id="如何应用于现实-1"><a href="#如何应用于现实-1" class="headerlink" title="如何应用于现实"></a>如何应用于现实</h4><ul><li>根据相关历史事件和成就塑造组织的当前身份</li><li>重述过去的成功行动和事件，以鼓励其他人现在的行动</li></ul><h4 id="当心……-1"><a href="#当心……-1" class="headerlink" title="当心……"></a>当心……</h4><ul><li>通过忽略相关重要历史使自己免于尴尬或者削弱对手的误导者</li><li>用高度选择性的历史叙述推动暴力、歧视和种族冲突的误导者</li></ul><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>对于黄疸病人来说，蜂蜜似乎是苦的。对于被疯狗咬过的人来说，水是恐怖的。<br>——马可·奥勒</p></blockquote><p>背景会极大的改变我们对现实的印象，可以改变意义。在不同背景下，同一个故事或物体会给人完全不同的印象，确定需要强调和需要淡化的背景是影响现实的一个重要环节，我们对很多物品的反应主要取决于背景，而不是物品本身。面对不同的背景，我们的行为往往也不同。我们往往在思考的时候忽视或者故意忽视某些背景。通过强调或忽视某些背景，演讲者在听众开始思考相关问题之前就已经能够有效地改变听众的思考方式。</p><h3 id="背景策略"><a href="#背景策略" class="headerlink" title="背景策略"></a>背景策略</h3><h4 id="1-设置框架"><a href="#1-设置框架" class="headerlink" title="1.设置框架"></a>1.设置框架</h4><p>设置有利于个人意图的背景可以提前决定人们对于一个问题的反应，合适的背景可以创造出令人信服的框架，影响人们对于框架内信息的处理方式。在沟通过程中，如果双方用完全不同的框架考虑一个复杂问题，那么他们不太可能找到共同的基础。有时，我们甚至很难听到与我们当前框架不符的信息。背景改变时，我们会下意识地对自己使用不同框架，我们的自我形象也会发生改变<br>框架可以帮助我们解读事件，也可以被人用于操纵和劝说我们。使用不同的背景可以改变谈判或辩论的方向<br><strong>示例</strong><br>“巴以冲突中，许多以色列犹太人认为这块神圣土地是上帝许诺给他们的，或者认为他们在敌对环境中取得了来之不易的安全。巴勒斯坦人考虑的则是他们被迫离开家园和土地时受到的不公正对待。”双方拥有各自的背景，这种框架错位使他们几乎不可能达成妥协。</p><h4 id="2-忽略相关背景"><a href="#2-忽略相关背景" class="headerlink" title="2.忽略相关背景"></a>2.忽略相关背景</h4><p>为了误导听众，许多演讲者会故意操纵或忽略背景。他们喜欢对反对者的文字断章取义，曲解反对者的立场，以更好的反驳对方。通过忽略相关背景，演讲者暗示听众不存在的真相是真实存在的，或者支持某个论点。<br><strong>示例</strong><br>“但是妈妈说，我可以在洗澡以后看电视”，小男孩真诚的对困惑的保姆说，不过他漏掉了一个重要背景，即这项特权只适用于星期六。</p><h3 id="背景总结"><a href="#背景总结" class="headerlink" title="背景总结"></a>背景总结</h3><p>我们当下的阅读习惯决定了我们喜欢碎片化信息，长篇报道已经让位于新闻滚动条和推特信息。因此，我们不可避免地失去了背景，我们在不了解实情的情况下对事件、评论、声明和传闻做出回应。我们需要确保自己了解最贴切的背景</p><h4 id="如何应用于现实-2"><a href="#如何应用于现实-2" class="headerlink" title="如何应用于现实"></a>如何应用于现实</h4><ul><li>总是应该检查背景</li><li>将最有用的背景作为框架，以支撑你的论点</li><li>通过改变背景改变对事物、人和问题的态度</li></ul><h4 id="当心……-2"><a href="#当心……-2" class="headerlink" title="当心……"></a>当心……</h4><ul><li>在不了解完整背景的情况下分享劲爆新闻的误传者</li><li>故意略去重要背景，尤其是引用他人话语的误导者</li></ul><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><blockquote><p>只要拷问数字，它们就会承认任何罪名。<br>——格雷格·伊斯特布鲁克</p></blockquote><p>我们在看到一个统计量时很难知道它的真正含义，误导者可以按时他们所希望的含义，从而影响现实<br>在对数字进行思考之前，我们要先真正弄明白这个数字代表了什么，即指代事物具体而详实的定义</p><h3 id="数字策略"><a href="#数字策略" class="headerlink" title="数字策略"></a>数字策略</h3><h4 id="1-选择有利单位"><a href="#1-选择有利单位" class="headerlink" title="1.选择有利单位"></a>1.选择有利单位</h4><p>对数字指代对象的不同选择，往往能导致不同的叙述效果。在了解背景之前，我们无法做出判断。<br><strong>示例</strong><br>1、“特朗普总统 2017 年对国会说‘9400 万美国人没有工作’时，这似乎意味着所有这些人都是被动失业者”，实际上，这个来自劳工统计局对数字包括所有 16 岁以上的学生、退休人员以及那些选择不工作的人。真实的美国失业数字——想工作但无法获得工作职位的人——在 2017 年初约为 760 万，不到特朗普所说数字的 1&#x2F;10。<br>2、“某款沐浴露产品的市场宣传材料称：‘原始薄荷茶树叶沐浴露浓缩了 7927 片真实的薄荷叶’”，数字 7927 以很大的字号印在瓶子上。7927 片薄荷叶对于此类产品而言并不多，但这款产品显然暗示了这是一个很大的数字。</p><h4 id="2-使数字看上去变大或变小"><a href="#2-使数字看上去变大或变小" class="headerlink" title="2.使数字看上去变大或变小"></a>2.使数字看上去变大或变小</h4><p>当某人试图说服你相信一个数字特别重要时，他所做的第一件事将数字转换成包含相关背景的更具启发性的真相。百分率往往可以比数字本身提供更多信息。百分率可以让绝对数字很大的事物所占比例很小，也可以让绝对数字很小的事物所占比例很大，这两个方向都可以被误导者所利用。在相对数字面前，我们往往又很少考虑绝对数字。同时，对数字指代对象的转换也可以改变数字的大小。想让数字变大或变小，可以把时间线拉长或拉近。也可以将某件事物转换成无关测量单位，使其看上去更加便宜或昂贵，一件事物的成本是它的实际金额，对这个成本的任何改写都是竞争性真相，很可能是为了服务于某个特殊目的。<br>同时，我们最重要的一些真相来自重要数字随时间的变化情况，误导者可能会用某个与其相关的数字讲述不同的故事。我们需要考虑到数字指代对象本身的变化。对相关问题选择不同的起始时间也会改变相关现象的真相。</p><ol><li>将数字转换成百分率</li><li>使用相对数字或绝对数字</li><li>改变数字指代的对象</li><li>改变（时间）范围</li><li>将事物转换成无关测量单位</li><li>改变起始时间</li><li>忽略对象本身的变化</li></ol><p><strong>示例</strong><br>1、“皇家《每日快报》的一则标题是‘多么划算！王室每年只会给你带来 56 磅成本’”，政客们喜欢用每日成本代替每年成本，甚至使用每个纳税人的或公民的成本。<br>2、“英国财政部发布了一则预测报告，称如果脱离欧盟，英国 2030 年的国内生产总值将比留在欧盟低 6%”，这则新闻稿使人们觉得英国将比目前更加糟糕。实际上财政部的预测显示，不管是否脱离欧盟，英国 2030 年的国内生产总值都要比现在高很多。更加完整诚实的标题应该是这样的：“英国将比它本应面临的情况糟糕一些，但它仍会好于现在”。</p><h4 id="3-隐藏或夸大趋势"><a href="#3-隐藏或夸大趋势" class="headerlink" title="3.隐藏或夸大趋势"></a>3.隐藏或夸大趋势</h4><p>隐藏或夸大趋势的常用手段之一就是使用图表。误导者可以改变图像的标度，在有利的轴线上描绘数据时，下降趋势可以显得很平坦，不明显的增长也可以显得很突出。同时累计图像也是常用图表之一，对于误导者来说，累计图像的好处在于，它不会下降。<br>同时对于两组数据来说，表面上的关联并不意味着它们存在某种因果关系，可能都是由第三个因素导致的，误传者很容易陷入这个陷阱。<br>另外值得一提的是，不同的平均数可以达到不同的效果，面对不了解平均数差异的听众，误导者可以在均值和中位数之间进行切换。大多数评论家不会具体指出他们使用的是哪种平均数，聪明的误导者会选择符合个人意图的平均数。<br><strong>示例</strong><br>1、“苹果总裁蒂姆·库克 2013 年展示了“苹果手机销售”图表，从而隐藏了两个季度的销售下降，他在一个月后对平板电脑销量也进行了同样的操作，因为平板电脑销量也下降了两个季度。”。<br>2、“有人注意到，海滨度假区销售的冰淇淋越多，溺水的人就越多。”这并不意味着冰淇淋会导致致命的痉挛，当天气暖和时，人们喜欢吃冰淇淋。当天气较好时，人们还喜欢游泳。<br>3、2014-2015 年，英国税前工资的中位数是 22400 英镑，同一年的工资均值是 31800 英镑，所以“28000 英镑的教师工资低于平均收入”与“28000 英镑的教师工资高于平均收入”都是成立的。</p><h4 id="4-挑选统计量"><a href="#4-挑选统计量" class="headerlink" title="4.挑选统计量"></a>4.挑选统计量</h4><p>对于平均数而言，统计量也是一个非常重要的因素。例如国家或省的均值总会低估普通人的经历。<br>非常有趣的是“<a href="https://zh.m.wikipedia.org/wiki/%25E8%25BE%259B%25E6%2599%25AE%25E6%25A3%25AE%25E6%2582%2596%25E8%25AE%25BA">辛普森悖论</a>”。<br>所以在面对不同的统计量时，我们一定要注意数字使用的背景。<br><strong>示例</strong><br>1、“2015 年，爱尔兰国内生产总值增长了 26%。对于这个欧元区小国来说，这是一个惊人的成就。”然而，国内生产总值的激增与爱尔兰人几乎没有关系，原因在于少数国外公司由于税收原因在全球赌桌上移动了一些筹码，一些宝贵的资产被转移到爱尔兰。但是这些新增资产和新增国民收入对于爱尔兰人没有太大意义，爱尔兰仍然是世界上人均债务第二多的国家。<br>2、虽然国内生产总值被视作目前最好的国家经济健康指标，但是它的增长并不意味着快乐和幸福的增长。当科技改变我们的活动和我们重视的事情时，国内生产总值和人类福祉的差异正在变得越来越重要。大多数发达国家的国内生产总值已经连续多年保持停滞，不过在这段时间发达国家居民的机器、沟通和医学质量得到了显著的提高，不过由于互联网服务不需要花一分钱，所以这些价值大部分被国内生产总值的统计数字忽略了。考虑到这个问题，中国国家统计局副局长在 2016 年呼吁将免费服务纳入国内生产总值报告中。‘数字经济催生了新的商业模式，创造了许多非货币交易，’许宪春说，‘它们的收入主要来自网络广告，而不是实际享受服务的用户。所以，消费者免费获得的最终服务的价值常常被低估或忽略’。英国国家统计局被要求研究如何将共享经济纳入国内生产总值的估计之中。</p><h5 id="辛普森悖论"><a href="#辛普森悖论" class="headerlink" title="辛普森悖论"></a>辛普森悖论</h5><p>辛普森悖论的问题在于，同样的数字可以传达两个不同的真相，它的关键在于识别群体与子群体的差异。例如“当一个头发超过平均值的男人走进酒吧，酒吧里的头发长度平均值却下降了”，这是因为第一个平均值指的是酒吧内男性群体的平均值，第二个平均值指的是酒吧内所有人的总平均值，这句话里面暗含了指代群体的改变。</p><h3 id="数字总结"><a href="#数字总结" class="headerlink" title="数字总结"></a>数字总结</h3><p>面对数字，我们往往会停止批判性思考。数字很重要，我们一定不能失去对数字的信任。但是我们需要更好地解读数字。对数字的解读本质上还是对数字背后指代对象的可变性、延展性的解读。</p><h4 id="如何应用于现实-3"><a href="#如何应用于现实-3" class="headerlink" title="如何应用于现实"></a>如何应用于现实</h4><ul><li>深入挖掘，以理解辩论中的每个数字究竟代表了什么</li><li>确保你使用的是最贴切的单位，你所对比的事物处于同一级别</li><li>将数字放在背景中，将它们与其他相关数字进行比较，以显示它们的真实大小</li></ul><h4 id="当心……-3"><a href="#当心……-3" class="headerlink" title="当心……"></a>当心……</h4><ul><li>试图使数字看上去更大或更小，或者使趋势变得更加明显的误导者</li><li>认为两组相关数据存在因果关系的误传者</li><li>挑选统计量或者不明确指出自己使用的是何种平均数的误导者</li></ul><h3 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h3><blockquote><p>让事实见鬼去吧！我们需要故事<br>——肯·凯西</p></blockquote><p>故事是对变化过程的选择性连贯描述，强调局面和事件之间的因果关系。故事有三个最主要的构成：变化过程、因果关系、触发事件。对于变化过程，强调的是故事必须要有变化，即故事内容一定是丰富的。对于因果关系，这是一切故事的核心，是故事的逻辑所在，也是听众愿意相信故事的原因，原因是可以被人为创造的，因果关系由叙事过程决定，讲述者一定会说清楚事情发生的原因。对于触发事件，每个故事都需要一系列事件的最初诱因，同一个事件的不同故事，触发事件一般不同，取决于讲述者的观点态度。<br>因果关系具有非常强大的力量。人们渴望获得解释。当重要的事情发生时，我们希望理解它为什么发生。由于故事似乎可以说明一件事情是如何导致另一件事情的，因此它可以帮助我们理解这个混乱的世界。故事作为沟通的真正价值在于它们使复杂事物变得连贯而清晰。<br>不过故事的问题也在于此，故事具有高度选择性。它们没法给出完整的画面，是片面的真相。即故事只能给读者固定的由讲述者选择的片面真相。当讲述者描述一系列事件时，会选择起始点、叙述时段和描绘人物的方式，重要的是，叙述者会简化原因和结果。故事相当具有条理，但真实的生活很少如此黑白分明，事件往往拥有多个原因。<br>面对描述同一事件不同版本的故事，我们的思维模式和世界观往往使我们相信其中一个版本，不过这些版本呈现的事实都是真相。至于这些事实连接成的因果关系及其组合而成的最终信息，就要看讲述者如何讲故事了。</p><h3 id="故事策略"><a href="#故事策略" class="headerlink" title="故事策略"></a>故事策略</h3><h4 id="1-通过连接事实暗示因果关系"><a href="#1-通过连接事实暗示因果关系" class="headerlink" title="1.通过连接事实暗示因果关系"></a>1.通过连接事实暗示因果关系</h4><p>对故事三要素的不同选择，可以传达不同的观点和思想。通过对事件的一系列特定事实的选择，串联起来构成一个完整的故事，可以暗示读者其中的因果关系。<br>因此在讲故事的过程中，我们需要知道根据现有事实构造不同故事的方式，以及我们可以让听众相信的不同结论。<br><strong>示例</strong><br>在对金融危机故事的讲述中，默文·金讲述的故事始于柏林墙倒塌，而其他人则将金融服务行业放松管制、债务抵押债券的发明或者美国住房泡沫作为触发事件。这些都暗示和强调了支持个人观点的不同的因果关系。</p><h4 id="2-用故事定义身份"><a href="#2-用故事定义身份" class="headerlink" title="2.用故事定义身份"></a>2.用故事定义身份</h4><p>故事不一定要讲述过去的事情，同样可以展望未来，讲述关于前进方向的许多具有同样可能性的故事。<br>故事的作用在于提出了一个因果链条，淡化了其他的因果链条。<br>这个策略在企业和群体中用的很多。公司起源故事是团结员工和吸引顾客的常见手段，当然这些都是选择性历史，只讲述使当前企业具有良好形象的过往事迹。具有同样效果的还有逸事，这是关于某些人或事件的局部真相，其目的是改变人们的普遍行为和思维模式，在企业环境中，这种坦诚而真实的描述可以起到有效的鼓励作用。<br><strong>示例</strong><br>北面和巴塔哥尼亚的创始人为满足自己的探险需求而设计工具包和服装的故事极大地提高了他们的品牌形象，巴克莱银行为他们的贵格会创始人而自豪，其诚实、正直和坦率的原则是银行员工目前仍然在使用的口号，耐克为其共同创始人兼跑步教练比尔·鲍尔曼打造了一个复杂的神话。</p><h4 id="3-用案例故事鼓励或改变行为"><a href="#3-用案例故事鼓励或改变行为" class="headerlink" title="3.用案例故事鼓励或改变行为"></a>3.用案例故事鼓励或改变行为</h4><p>当政客和记者用故事支持争议性观点时，他们会起到引导情绪的作用，这些故事的作用在于长时间激起读者的情绪，使读者支持作者的观点，哪怕故事本身和观点毫无联系。故事的目的不一定在于说明什么事实，激起情绪也是目的之一。因此，开场故事是极为常见的新闻技巧（严格来说，应该是“现代新闻”技巧）。人们喜欢故事，而且认为故事具有说服力——后者更加重要。<br><strong>示例</strong><br>“ 1 月 23 日星期一下午刚过 3 点，从伦敦西北部卡皮塔尔中学走出来的孩子们突然停止了往常的喧嚣。‘所有孩子像平时一样跑来跑去，’一个邻居说，‘突然，大家安静下来。我站起来，拉开窗帘，看到孩子们尖叫着四散奔逃。’<br>15 岁的学生夸马里•巴恩斯被刺数刀。他倒在距离学校大门几米远的地方。一个女人用胳膊抱着他。医疗救助人员冲到现场，将夸马里送到医院。”这是 2017 年《卫报》一篇谈论英国青少年持刀犯罪的重要文章的开头，在这篇文章中，他的故事服务于一个明确的目标：一个孩子在自家学校门外被刺的开头远比持刀犯罪枯燥事实刀均衡呈现更加引人注目。然而，文章开头的故事与作者的主要论点没有任何关系。</p><h4 id="4-将故事作为证据"><a href="#4-将故事作为证据" class="headerlink" title="4.将故事作为证据"></a>4.将故事作为证据</h4><p>常常被人们忽略的一点是：故事没法证明任何事情，它仅仅是独立的数据点，将一个具体案例外推为普遍规则是一种逻辑谬误。<br>倡导者可以用故事展示一件事情可能具有的情况，而不是证明什么结论，真实的故事可以展示可能性。在讲述过程中应当努力将故事当作数据点和论证，而不是某个论点的基础。在证明某件事情时，要坚持使用冰冷的数字和事实。</p><h3 id="故事总结"><a href="#故事总结" class="headerlink" title="故事总结"></a>故事总结</h3><p>故事具有极大的力量，很容易被人相信。由于它可以帮助我们理解复杂世界，由于它们的结构符合古老的心理模式，因此我们往往认为它们是唯一的真相。实际上它们只是真相之一。当我们倾听和讲述故事时，我们应该记住它们所描绘的真相具有多大的灵活性。</p><h4 id="如何应用于现实-4"><a href="#如何应用于现实-4" class="headerlink" title="如何应用于现实"></a>如何应用于现实</h4><ul><li>用故事澄清事情发生的原因和可能性</li><li>仔细选择关于某个组织的故事，以帮助该组织塑造身份</li><li>分享关于最佳实践的逸事，以鼓励其他人做出相同的表现</li></ul><h4 id="当心……-4"><a href="#当心……-4" class="headerlink" title="当心……"></a>当心……</h4><ul><li>在真实事件组成的故事中捏造因果关系的误导者</li><li>用具体故事证明普遍观点的误传者</li></ul><h2 id="第二部分——主观真相：可以改变的真相"><a href="#第二部分——主观真相：可以改变的真相" class="headerlink" title="第二部分——主观真相：可以改变的真相"></a>第二部分——主观真相：可以改变的真相</h2><h3 id="道德"><a href="#道德" class="headerlink" title="道德"></a>道德</h3><blockquote><p>杀人是被禁止的。所以，所有的杀人犯都会受到惩罚，除非他们杀掉一堆人，最后吹响胜利的号角。<br>——伏尔泰</p></blockquote><p>在不同文化的不同道德观念之中，一个人眼中的善可能是另一个人眼中的恶。但是我们往往认为某些道德观点是不言而喻的。我们过于坚信我们的道德，但善恶并不是一成不变的。道德真理可以被操纵，有经验的沟通者（往往是被尊为社会道德指引者的人）可以为事物、事件甚至个人赋予不同的道德意义，从而重塑我们的现实。</p><h3 id="道德策略"><a href="#道德策略" class="headerlink" title="道德策略"></a>道德策略</h3><h4 id="1-妖魔化"><a href="#1-妖魔化" class="headerlink" title="1.妖魔化"></a>1.妖魔化</h4><p>在我们生活的世界上，总有一些人持有和我们完全不同的道德观念。在我们还没有形成固定观念的问题上，我们可以更加清晰的看到道德真理可能具有的灵活性。<br>我们往往会接受所在群体的主流道德真理，出现道德争议时，我们会服从群体中大多数人的反应。道德真理将群体维系在一起。如果一个群体的不同成员开始采纳不同道德真理，那么道德的合作功能就会蒸发，群体就会受到破坏。由此，遵守群体道德真理的“同济压力”在每个文化中都很强烈。<br>当群体的立场受到挑战时，我们会自发的为这种立场辩护，哪怕已经开始产生怀疑。我们甚至会将与其他群体相冲突的道德真理定义我们群体，这加剧了不同社会的割裂。<br>以上这些群体错位可能是相对隔离群体逐渐变化的结果，但更可能是领导者或意见领袖故意设计的。这为将其他群体的道德真理妖魔化提供了可能。强大的沟通者可以鼓励整个群体接受新的道德真理。<br><strong>示例</strong><br>植物兴奋剂和致幻剂千年以来就一直被地球几乎所有文化使用，这种植物提取物一直广泛在社会中使用，直到 20 世纪最初的几十年，各国政府共同参与了妖魔化毒品和毒品使用者的运动，西方政府反毒品宣传中强调了危险物质、“边缘群体”威胁和犯罪之间的联系。它们广泛的将毒品与反政府组织联系起来起来，借用毒品打击这些群体。</p><h4 id="2-影响群体道德"><a href="#2-影响群体道德" class="headerlink" title="2.影响群体道德"></a>2.影响群体道德</h4><p>群体道德容易与社会整体道德相违背，有可能是外界对群体的要求，也有可能是群体内部约定俗成。形成群体道德可以通过长期且重复的行为和言论，也可以通过群体内部的忠诚。<br><strong>示例</strong><br>有一条完全可以被称为宇宙道德法则的道德真理，那就是我们不应该互相残杀。不过，大多数社会都会在依靠一群愿意杀人的同胞维持秩序。我们将这些人称为士兵，并且向他们灌输这样一个真理：在某些情况下，杀人是正当的。这样并不容易。</p><h4 id="3-让道德变得不重要"><a href="#3-让道德变得不重要" class="headerlink" title="3.让道德变得不重要"></a>3.让道德变得不重要</h4><p>有一种言论，被社会上大多数人谴责的行为在道德上是中性的——它们在道德上谈不上好，但也谈不上坏。很多人只想知道他们的行为是否合法，如果合法，他们就不会讨论其他事情了（所谓的“法无禁止皆可为”）。<br><strong>示例</strong><br>投资银行家通常会努力遵守法律，遵守金融监管结构制定的大量复杂规则，但他们中的许多人认为自己并没有其他任何道德义务。</p><h3 id="道德总结"><a href="#道德总结" class="headerlink" title="道德总结"></a>道德总结</h3><p>道德是主观的和可变的，改变自身道德真理的群体会采取与其他人完全不同的做法。当有害的群体道德真理出现时，我们需要努力改变它们。<br>培育道德同样是非常重要的。面对有害的道德真理，倡导者应该主动培育良好的道德“与之对抗”。</p><h4 id="培育道德"><a href="#培育道德" class="headerlink" title="培育道德"></a>培育道德</h4><p>培育道德有几种方式：</p><ol><li>同理心。同理心是改变组织内部道德文化的重要工具。如果一个人被迫长时间思考说谎对社会的恶劣影响，那么他未来就不太可能说谎。</li><li>重塑价值观。如果领导者重新定义群体的价值观念，那么群体更有可能培育出良好的道德真理。</li><li>举出证据。对于具有分析头脑、不太容易接受同理心干预的人来说，这场常常是最有效的策略。例如可以展示当前行为对人们自身利益的损害，从而说服他们改变行为。</li><li>长时间坚持。如果没有同情意愿或者不愿意接受新定义和智力辩论的人来说，可以让他长时间坚持习惯良好的道德真理，这样可以让他养成真正的道德真理。伪装的品德完全有可能变成真正的品德。</li></ol><h4 id="如何应用于现实-5"><a href="#如何应用于现实-5" class="headerlink" title="如何应用于现实"></a>如何应用于现实</h4><ul><li>认识到道德是主观的，具有破坏性的群体道德可以得到改变。</li><li>通过同理心、激励、逻辑论证以及合意性的新定义灌输新的道德真理。</li></ul><h4 id="当心……-5"><a href="#当心……-5" class="headerlink" title="当心……"></a>当心……</h4><ul><li>对于道德中性事物的人群进行妖魔化的误导者。</li><li>支持某种对社会有害的道德真理的群体。</li></ul><h3 id="吸引力"><a href="#吸引力" class="headerlink" title="吸引力"></a>吸引力</h3><blockquote><p>己之蜜糖，彼之砒霜。<br>——卢克莱修</p></blockquote><p>我们常常被激发快感、兴趣或兴奋的事物吸引，排斥激发仇恨、恐惧或厌恶的事物。不同的情绪以不同的方式激励我们。<br>吸引力是非常易变的，即使表面上看起来普遍被人接受或者普遍不被接受的事物也可以被描绘成完全不同的色彩。它不仅取决于事物本身，也取决于上下文。如果农业、卫生和知识可以被视作坏事，战争、粪便和失败可以被视作好事，那么愿望的主观性似乎不会有什么界限。任何事物的吸引力都存在竞争性真相。合适的竞争性真相会极大地影响我们的行为，我们可以对我们想要的理想事物进行选择，并且推动其他人朝着相同的方向前进。</p><h3 id="吸引力策略"><a href="#吸引力策略" class="headerlink" title="吸引力策略"></a>吸引力策略</h3><h4 id="1-劝说人们喜欢对他们有益的事物"><a href="#1-劝说人们喜欢对他们有益的事物" class="headerlink" title="1.劝说人们喜欢对他们有益的事物"></a>1.劝说人们喜欢对他们有益的事物</h4><p>当我们享受预期时，我们更容易享受某种事物。这被称为“营销安慰剂效应”。从生物学来说，情绪本身不是目的，而是一种机制，劝说我们追求对进化有用的目标，排斥对进化有害的目标。然而这种机制可以得到重新校正。<br>这个策略的关键在于“说服”与“目标”。<br>对于成年人而言，孩子更容易被说服接受某些事物。不过需要注意的是，通过奖励（！）或恐吓只会强化某些事物对他们无益的信息，使之成为自我实现的预言。然而，成年人也是很容易被说服的，</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>社科</tag>
      
      <tag>《后真相时代》</tag>
      
      <tag>真相</tag>
      
      <tag>传播学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>串、数组和广义表</title>
    <link href="/2025/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
    <url>/2025/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>字符串一般被称为串，串是一种内容受限的线性表。多维数组和广义表也是线性表的一种延伸。</p><h2 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h2><p><strong>串</strong>是有零个或多个字符组成的有限序列。</p><p><strong>串的长度</strong>：串中字符的数目 n。</p><p><strong>空串</strong>：零个字符的穿。</p><p><strong>子串</strong>：串中任意个连续的字符组成的字序列。</p><p><strong>主串</strong>：包含子串的串。</p><p>字符在串中的位置被称为字符在序列中的序号。</p><p>子串在主串中的位置是以子串的第一个字符在主串中的位置表示。</p><p>两个串相等当且仅当这两个串的值相等。</p><p><strong>空格串</strong>：一个或多个空格组成的串” “。</p><h2 id="串的类型定义、存储结构及其运算"><a href="#串的类型定义、存储结构及其运算" class="headerlink" title="串的类型定义、存储结构及其运算"></a>串的类型定义、存储结构及其运算</h2><h3 id="串的抽象类型定义"><a href="#串的抽象类型定义" class="headerlink" title="串的抽象类型定义"></a>串的抽象类型定义</h3><p>串的逻辑结构和线性表极其相似，但是串的基本操作和线性表有很大的差别。在串的基本操作中，一般以”串的整体”作为操作对象。</p><p>串的抽象数据类型定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ADT String&#123;<br>数据对象：D=&#123;ai|ai∈CharacterSet, i=l,<span class="hljs-number">2</span>,…,n,n&gt;=<span class="hljs-number">0</span>J<br>数据关系：Rl=&#123;&lt;ai<span class="hljs-number">-1</span>,ai&gt;|ai<span class="hljs-number">-1</span>,ai∈D,i=<span class="hljs-number">2</span>,…,n&#125;<br>基本操作：<br>    <span class="hljs-built_in">StrAssign</span>(&amp;T, chars)<br>        初始条件：chars是字符串常址。<br>        操作结果：生成一个其值等于chars的串T。<br>    <span class="hljs-built_in">StrCopy</span>(&amp;T,S)<br>        初始条件：串S存在。<br>        操作结果：由串S复制得串T。<br>    <span class="hljs-built_in">StrEmpty</span>(S)<br>        初始条件：串S存在。<br>        操作结果：若S为空串，则返回<span class="hljs-literal">true</span>, 否则返回<span class="hljs-literal">false</span>。<br>    StrCompar <span class="hljs-built_in">e</span>(S,T)<br>        初始条件：串S和T存在。<br>        操作结果：若S&gt;T, 则返回值&gt;<span class="hljs-number">0</span>; 若S=T, 则返回值=<span class="hljs-number">0</span>; 若S&lt;T, 则返回值&lt;<span class="hljs-number">0</span>。<br>    <span class="hljs-built_in">StrLength</span>(S)<br>        初始条件：串S存在。<br>        操作结果：返回S的元素个数，称为串的长度。<br>    <span class="hljs-built_in">ClearString</span>(&amp;S)<br>        初始条件：串S存在。<br>        操作结果：将S清为空串。<br>    <span class="hljs-built_in">Concat</span>(&amp;T,Sl,S2)<br>        初始条件：串Sl和S2存在。<br>        操作结果：用T返回由Sl和S2联接而成的新串。<br>    <span class="hljs-built_in">SubString</span>(&amp;Sub,S,pos,len)<br>        初始条件：串S存在，<span class="hljs-number">1</span>&lt;=pos&lt;=<span class="hljs-built_in">StrLength</span>(S)且<span class="hljs-number">0</span>&lt;=<span class="hljs-number">1</span>en&lt;=<span class="hljs-built_in">StrLength</span>(S)-pos+l。<br>        操作结果：用Sub返回串S的第pos个字符起长度为len的子串。<br>    <span class="hljs-built_in">Index</span>(S,T,pos)<br>        初始条件：串S和T存在，T是非空串，<span class="hljs-number">1</span>:s;pos:s;<span class="hljs-built_in">strLength</span>(S)。<br>        操作结果：若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置；否则函数值为<span class="hljs-number">0</span>。<br>    <span class="hljs-built_in">Replace</span>(&amp;S,T,V)<br>        初始条件：串S,T和V存在,T是非空串。<br>        操作结果：用V替换主串S中出现的所有与T相等的不重叠的子串。<br>    <span class="hljs-built_in">Strlnsert</span>(&amp;S,pos,T)<br>        初始条件：串S和T存在，<span class="hljs-number">1</span>&lt;=pos&lt;=<span class="hljs-built_in">StrLength</span>(S)+l。<br>        操作结果：在串S的第pos 个字符之前插人串T。<br>    <span class="hljs-built_in">StrDelete</span>(&amp;S,pos,len)<br>    初始条件：串S存在，<span class="hljs-number">1</span>&lt;=pos&lt;=<span class="hljs-built_in">StrLength</span>(S)-len+l。<br>    操作结果：从串S中删除第pos 个字符起长度为len 的子串。<br>    <span class="hljs-built_in">DestroyString</span> (&amp;S)<br>    初始条件：串S存在。<br>    操作结果：串S被销毁。<br>&#125;ADT String<br></code></pre></td></tr></table></figure><h3 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h3><p>串可以用链式存储，但是有存储效率和算法考虑，一般采用顺序存储结构</p><h4 id="串的顺序存储"><a href="#串的顺序存储" class="headerlink" title="串的顺序存储"></a>串的顺序存储</h4><p>串的顺序存储结构用一组地址连续的存储单元存储串值的字符序列，每个定义的串都被分配一个固定长度的存储区域。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 255      <span class="hljs-comment">//串的最大长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">char</span> ch[MAXLEN<span class="hljs-number">+1</span>];  <span class="hljs-comment">//存储串的一维数组</span><br>    <span class="hljs-type">int</span> length;         <span class="hljs-comment">//串的当前长度</span><br>&#125;SString;<br></code></pre></td></tr></table></figure><p>然而实际上这种为串变量设定固定大小的空间不是很合理，最好根据实际需要在程序执行过程中按需分配和释放字符数组的空间。</p><p>在 C 语言中，可以使用被称为”堆”堆自由存储区，为每个新产生的串动态分配一块实际串长所需要的存储空间，如果分配成功则返回一个指向起始地址的指针。这样被称为串的堆式顺序存储结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">char</span> *ch;    <span class="hljs-comment">//如果是非空串，则按串长分配存储区，否则 ch 为 NULL</span><br>    <span class="hljs-type">int</span> length;  <span class="hljs-comment">//串的当前长度</span><br>&#125;HString;<br></code></pre></td></tr></table></figure><h4 id="串的链式存储"><a href="#串的链式存储" class="headerlink" title="串的链式存储"></a>串的链式存储</h4><p>在串的链式存储中，存在一个与别的链式存储不一样的问题，本质是串结构的特殊性——串中每一个数据元素是一个字符，用链表存储串时，需要选择一个结点存储几个字符（可以存放一个，也可以存放多个）。</p><p>为了便于串的操作，当用链表存储串值时，除了头指针还可以加一个尾指针指示链表中的最后一个结点，并给出当前串的长度。这样定义的串存储结构为块链结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHUNKSIZE 80     <span class="hljs-comment">//由用户定义块大小</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Chunk</span>&#123;<br>    <span class="hljs-type">char</span> ch[CHUNKSIZE];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Chunk</span> *next;<br>&#125;Chunk;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    Chunk *head, *tail;  <span class="hljs-comment">//串的头和尾指针</span><br>    <span class="hljs-type">int</span> length;          <span class="hljs-comment">//串的当前长度</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在链式存储中，结点大小直接影响串处理的效率。面对很长的串，存储密度就很重要了。</p><p>存储密度小，运算处理方便，但是存储占用量大。因此串的字符集的大小也是一个重要因素。一般来说，字符集小，字符的机内编码就短，这影响串值存储方式的选取。</p><h3 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h3><p>子串的定位运算通常称为串的模式匹配或串匹配。</p><p>串的模式匹配的效果：</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image.png"></p><p>著名的模式匹配算法有 BF 算法和 KMP 算法</p><h4 id="BF-算法"><a href="#BF-算法" class="headerlink" title="BF 算法"></a>BF 算法</h4><p>BF 算法是最简单直观的模式匹配算法。</p><p>模式匹配也要求可以指定主串中查找的起始位置，这样字符串顺序存储结构的优势就体现出来了。</p><p><strong>算法步骤</strong></p><ol><li>分别利用计数指针 i 和 j 指示主串 S 和模式 T 中当前正待比较的字符位置，i 的初值为 pos，j 的初值为 1。</li><li>如果两个串都没有达到串尾，即 i 和 j 均分别小于等于 S 和 T 的长度时，则循环执行一下操作：</li></ol><ul><li>S.ch[i] 和 T.ch[i] 比较，若相等，则 i 和 j 分别指示串中下个位置，继续比较后续字符。</li><li>若不等，指针后退重新开始匹配，从主串的下一个字符（i&#x3D;i-j+2）起再重新和模式的第一个字符（j&#x3D;1） 比较。</li></ul><ol start="3"><li>如果 j&gt;T.length，说明匹配成功，返回和模式 T 中第一个字符相等的字符串在主串中的序号（i-T.length）；否则匹配失败，返回 0。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Index_BF</span><span class="hljs-params">(SString S, SString T, <span class="hljs-type">int</span> pos)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//返回模式 T 在主串 S 中第 pos 个字符开始第一次出现的位置。若不存在则返回值为0</span><br> <span class="hljs-comment">//其中，T 非空，1&lt;=pos&lt;=S.length</span><br>    i = pos;                           <span class="hljs-comment">//初始化</span><br>    j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)  <span class="hljs-comment">//两个串均为比较到串尾</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(S.ch[i] == T.ch[i])         <span class="hljs-comment">//继续比较后续字符</span><br>        &#123;<br>            ++i;<br>            ++j;<br>        &#125;<br>        <span class="hljs-keyword">else</span>                           <span class="hljs-comment">//指针后退重新开始匹配</span><br>        &#123;<br>            i = i-j<span class="hljs-number">+2</span>;<br>            j=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j&gt;T.length)                 <span class="hljs-comment">//匹配成功</span><br>            <span class="hljs-keyword">return</span> i-T.length;<br>        <span class="hljs-keyword">else</span>                           <span class="hljs-comment">//匹配失败</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h5><p><strong>最好情况下平均时间复杂度</strong>：</p><p>最好的情况下，每次不成功的匹配都发生在模式串的第一个字符和主串相对应字符的比较。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_2.png"></p><p>最好情况下平均时间复杂度是 O(n+m)。</p><p><strong>最坏情况下平均时间复杂度</strong>：</p><p>最坏情况下，每次不成功的匹配都发生在模式串的最后一个字符与主串相对应字符的比较。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_3.png"></p><p>最坏情况下平均时间复杂度是 O(n*m)。</p><p>由此看出，BF 算法在匹配失败后总是跳转到 i-j+2 的位置，这导致算法的时间复杂度比较高。</p><h4 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h4><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的类型定义"><a href="#数组的类型定义" class="headerlink" title="数组的类型定义"></a>数组的类型定义</h3><p>数组：类型相同的数据元素构成的有序集合。</p><p>n 维数组：数组中每个元素处于 n 个关系中。</p><p>数组的特点在于结构中的元素本身可以看作是具有某种结构的数据，但要求它们属于同一数据类型。</p><p>一个 n 维数组类型可以定义为其数据元素为 n-1 维数组类型的一维数组类型。</p><p>由于数组一旦被定义，维度和维界就不再改变，因此除了初始化和销毁外，只有存取元素和修改元素值的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ADT Array&#123;<br>    数据对象:ji=<span class="hljs-number">0</span>,...,bi<span class="hljs-number">-1</span>,i=l,<span class="hljs-number">2</span>,...,n,<br>        D =&#123;aj1j<span class="hljs-number">2.</span>..jn|<span class="hljs-built_in">n</span>(&gt;O)称为数组的维数,bi是数组第i维的长度,ji是数组元素的第i维下标，aj1j<span class="hljs-number">2.</span>..jn∈ElemSet&#125;<br>    数据关系:R=&#123;Rl,R2,...,Rn&#125;<br>    基本操作:<br>        <span class="hljs-built_in">InitArray</span> (&amp;A, n, bound i, ···, boundn)<br>            操作结果:若维数n和各维长度合法， 则构造相应的数组A, 并返回OK。<br>        <span class="hljs-built_in">DestroyArray</span>(&amp;A)<br>            操作结果:销毁数组A。<br>        <span class="hljs-built_in">Value</span>(A,&amp;e,indexl ,...,indexn)<br>            初始条件:A是n维数组，e为元素变量，随后是n个下标值。<br>            操作结果:若各下标不超界，则e赋值为所指定的A的元素值，并返回OK。<br>        <span class="hljs-built_in">Assign</span>(&amp;A,e,indexl, …，indexn)<br>            初始条件:A是n维数组，e为元素变扯，随后是n 个下标值。<br>            操作结果:若下标不超界，则将e的值赋给所指定的A的元素，并返回OK。<br>&#125; ADT Array<br></code></pre></td></tr></table></figure><h3 id="数组的顺序存储"><a href="#数组的顺序存储" class="headerlink" title="数组的顺序存储"></a>数组的顺序存储</h3><p>由于数组特殊的特性，采用顺序存储比较合适。</p><p>需要注意的是，存储单元是一维结构，但数组可以是多维结构，此时便存在次序约定的问题——一种是以列序为主序的存储方式，另一种是以行序为主序的存储方式。常用的语言都是以行序为主序的存储方式。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_4.png"></p><p>因此对于数组而言，只要给出下标就可以访问到元素的位置。（随机存储结构，很好理解，放个图略过得了）</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_5.png"></p><h3 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h3><blockquote><p>说实话，没看懂</p></blockquote><h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_6.png"></p><h4 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h4><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_7.png"><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_8.png"></p><h4 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h4><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_9.png"></p><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><h3 id="广义表的定义"><a href="#广义表的定义" class="headerlink" title="广义表的定义"></a>广义表的定义</h3><p>广义表是线性表的推广，称作列表。一般记作 <code>LS = (a1,a2,...,an)</code>。需要注意的是，这里的 ai 不再局限于单个元素，在广义表中既可以是元素也可以是广义表，分别称为广义表的原子和子表。由此看出广义表的定义是一个递归定义。</p><p>关于广义表有几个重要结论：</p><ol><li>广义表的元素可以是子表，广义表是一个多层次结构。</li><li>广义表可为其他广义表所共享。</li><li>广义表可以是一个递归的表，即广义表可以是其本身的一个子表。</li></ol><p>广义表的结构比较复杂，其中主要的两个运算如下：</p><ul><li>取表头 GetHead(LS)：取出的表头为非空广义表的第一个元素。</li><li>取表尾 GetTail(LS)：取出的表尾为除去表头外，其余元素构成的表。</li></ul><h3 id="广义表的存储结构"><a href="#广义表的存储结构" class="headerlink" title="广义表的存储结构"></a>广义表的存储结构</h3><p>广义表常用链式存储结构。同时又有两种处理思路：</p><ul><li>头尾链表</li><li>扩展线性链表</li></ul><h4 id="头尾链表的存储结构"><a href="#头尾链表的存储结构" class="headerlink" title="头尾链表的存储结构"></a>头尾链表的存储结构</h4><p>由于一对确定的表头表尾可唯一确定广义表，因此一个表结点由三个域组成：标志域、指示表头的指针域和指示表尾的指针域；原子结点则由两个域组成：标志域和值域。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_10.png"></p><p>形式定义说明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>&#123;ATOM,LIST&#125; ElemTag;           <span class="hljs-comment">//ATOM == 0：原子;LIST == 1：子表</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">GLNode</span><br>&#123;<br>    ElemTag tag;                           <span class="hljs-comment">//公共部分，用于区分原子结点和表结点</span><br>    <span class="hljs-keyword">union</span>                                  <span class="hljs-comment">//原子结点和表结点的联合部分</span><br>    &#123;<br>        AtomType atom;                     <span class="hljs-comment">//atom 是原子结点的值域，AtomByte 由用户定义</span><br>        <span class="hljs-keyword">struct</span>&#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">GLNode</span>*hp, *tp;&#125;ptr  <span class="hljs-comment">//ptr 是表结点的指针域，ptr.hp 和 ptr.tp 分别指向表头和表尾</span><br>    &#125;;<br>&#125;*GList;                                   <span class="hljs-comment">//广义表类型</span><br></code></pre></td></tr></table></figure><p>这种存储结构有以下三个特点：</p><ul><li>除空表的表头指针为空外，任意非空广义表，表头指针均指向一个表结点。</li><li>容易分清列表中原子和子表所在层次。</li><li>最高层的表结点个数即为广义表的长度。</li></ul><h4 id="扩展线性链表的存储结构"><a href="#扩展线性链表的存储结构" class="headerlink" title="扩展线性链表的存储结构"></a>扩展线性链表的存储结构</h4><p>这种结构中，两种元素都由三个域构成。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_11.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_12.png"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈和队列</title>
    <link href="/2025/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2025/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>栈和队列本质上也是线性表，是操作受限的线性表。</p><h2 id="栈和队列的定义和特点"><a href="#栈和队列的定义和特点" class="headerlink" title="栈和队列的定义和特点"></a>栈和队列的定义和特点</h2><h3 id="栈的定义和特权"><a href="#栈的定义和特权" class="headerlink" title="栈的定义和特权"></a>栈的定义和特权</h3><p>栈是限定在表尾进行插入或删除操作的线性表。表尾端叫做<strong>栈顶</strong>，表头端叫做<strong>栈底</strong>，不含元素的空表称为<strong>空栈</strong>。</p><p>栈的修改按照后进先出的原则进行，被称为<strong>后进先出</strong>（LIFO）的线性表。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231616615.png"></p><p>相比数组和链表，栈更多的是限制，”没有”很明显的优势。不过，虽然从功能上来说，数组和链表确实可以替代栈，但它俩暴露了太多的操作接口，操作上灵活自由但使用时可能不太可控，容易出 bug。</p><p>因此，如果一个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这时应该首选”栈”这种数据结构。</p><h3 id="队列的定义和特点"><a href="#队列的定义和特点" class="headerlink" title="队列的定义和特点"></a>队列的定义和特点</h3><p>队列是一种<strong>先进先出</strong>（FIFO）的线性表，只允许在表的一端进行插入，另一端删除元素。</p><p>队列中允许插入的一端称为<strong>队尾</strong>，允许删除的一端称为<strong>队头</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231616493.png"></p><h2 id="栈的表示和操作的实现"><a href="#栈的表示和操作的实现" class="headerlink" title="栈的表示和操作的实现"></a>栈的表示和操作的实现</h2><h3 id="栈的类型定义"><a href="#栈的类型定义" class="headerlink" title="栈的类型定义"></a>栈的类型定义</h3><p>栈的抽象数据类型定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ADT Stack&#123;<br>    数据对象： D=&#123;ai|ai∈ElemSet, i=l, <span class="hljs-number">2</span>,..., n,n&gt;=<span class="hljs-number">0</span>&#125;<br>    数据关系： R= &#123;&lt;ai<span class="hljs-number">-1</span>,ai&gt;|ai<span class="hljs-number">-1</span>,,ai∈D, i=<span class="hljs-number">2</span>,...,n&#125;<br>        约定an端为栈顶， a1端为栈底。<br>    基本操作：<br>        <span class="hljs-built_in">InitStack</span>(&amp;S)<br>            操作结果：构造一个空栈s。<br>        <span class="hljs-built_in">DestroyStack</span>(&amp;S)<br>            初始条件：栈s巳存在。<br>            操作结果：栈S被销毁。<br>        <span class="hljs-built_in">ClearStack</span>(&amp;S)<br>            初始条件：栈S已存在。<br>            操作结果：将S清为空栈。<br>        StackEmpt <span class="hljs-built_in">y</span>(S)<br>            初始条件：栈S巳存在。<br>            操作结果：若栈s 为空栈， 则返回<span class="hljs-literal">true</span>, 否则返回<span class="hljs-literal">false</span>。<br>        <span class="hljs-built_in">StackLength</span> (S)<br>            初始条件：栈S已存在。<br>            操作结果：返回s的元素个数， 即栈的长度。<br>        <span class="hljs-built_in">GetTop</span>(S)<br>            初始条件：栈S已存在且非空。<br>            操作结果：返回s的栈顶元素， 不修改栈顶指针。<br>        <span class="hljs-built_in">Push</span>(&amp;S,e)<br>            初始条件：栈S已存在。<br>            操作结果：插入元素e为新的栈顶元素。<br>        <span class="hljs-built_in">Pop</span>(&amp;S,&amp;e)<br>            初始条件：栈s已存在且非空。<br>            操作结果：删除S的栈顶元素，并用e返回其值。<br>        <span class="hljs-built_in">StackTraverse</span>(S)<br>            初始条件：栈S已存在且非空。<br>            操作结果：从栈底到栈顶依次对S的每个数据元素进行访问。<br>&#125;ADT Stack<br></code></pre></td></tr></table></figure><h3 id="顺序栈的表示和实现"><a href="#顺序栈的表示和实现" class="headerlink" title="顺序栈的表示和实现"></a>顺序栈的表示和实现</h3><p>顺序栈指的是利用顺序存储结构实现的栈，使用 top 指针指示栈顶元素在顺序栈中的位置。通常做法是以 top&#x3D;&#x3D;0 表示空栈。但由于 C 语言中数组下标从 0 开始，所有另设指针 base 指示栈底元素在顺序栈中的位置，此时当 top 和 base 值相等时，表示空栈。</p><p>基于数组的栈，是一个固定大小的栈，需要事先制定栈的大小。不过要实现一个支持动态扩容的栈，只需要底层依赖一个支持动态扩容的数组就可以了。不过实际上，支持动态扩容的顺序栈在实际开发中用的比较少。</p><p>顺序栈的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    SElemType *base;  <span class="hljs-comment">//栈底指针</span><br>    SElemType *top;   <span class="hljs-comment">//栈顶指针</span><br>    <span class="hljs-type">int</span> stacksize;    <span class="hljs-comment">//栈可用的最大容量</span><br>&#125;SqStack;<br></code></pre></td></tr></table></figure><p>base 是栈底指针，始终指向栈底的位置，如果值为 NULL ，说明栈结构不存在。top 是栈顶指针，初值指向栈底，插入新元素时，指针 top 值加一，删除栈顶元素时指针 top 值减一。<strong>栈非空时，top 始终指向栈顶元素的上一个位置</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231616479.png"></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><strong>算法步骤</strong></p><ol><li>动态分配一个最大容量是 MAXSIZE 的数组空间，使 base 指向这段空间的基地址，即栈底。</li><li>栈顶指针 top 初始为 base，表示栈为空。</li><li>stacksize 置为栈的最大容量 MAXSIZE。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//构造一个空栈S</span><br>    S.base = <span class="hljs-keyword">new</span> SElemType [MAXSIZE];  <span class="hljs-comment">//为顺序栈分配一个最大容量为 MAXSIZE 的数组空间</span><br>    <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(OVERFLOW);        <span class="hljs-comment">//存储分配失败</span><br>    S.top = S.base;                    <span class="hljs-comment">//top 初始化为 base，空栈</span><br>    S.stacksize = MAXSIZE;             <span class="hljs-comment">//stacksize 置为栈的最大容量 MAXSIZE</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h4><p><strong>算法步骤</strong></p><ol><li>判断栈是否满，若满则返回 ERROR。</li><li>将新元素压入栈顶，栈顶指针加一。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S, SElemType e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//插入元素e为新的栈顶元素</span><br>    <span class="hljs-keyword">if</span>(S.top-S.base==S.stacksize) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//栈满</span><br>    *S.top++ = e;                                <span class="hljs-comment">//元素e压入栈顶，栈顶指针加一</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><p><strong>算法步骤</strong></p><ol><li>判断栈是否空，若空则返回 ERROR。</li><li>栈顶指针减一，栈顶元素出栈。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S, SElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//删除 S 的栈顶元素，用 e 返回其值</span><br>    <span class="hljs-keyword">if</span>(S.top==S.base) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//栈空</span><br>    e = *--S.top;                    <span class="hljs-comment">//栈顶指针减一，将栈顶元素赋给 e</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h4><p>当栈非空时，此操作返回当前栈顶元素的值，栈顶指针保持不变。</p><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SElemType <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//返回 S 的栈顶元素，不修改栈顶指针</span><br>    <span class="hljs-keyword">if</span>(S.top!=S.base)       <span class="hljs-comment">//栈非空</span><br>        <span class="hljs-keyword">return</span> *(S.top<span class="hljs-number">-1</span>);  <span class="hljs-comment">//返回栈顶元素的值，栈顶指针不变</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链栈的表示和实现"><a href="#链栈的表示和实现" class="headerlink" title="链栈的表示和实现"></a>链栈的表示和实现</h3><p>顺序栈和顺序表一样受到最大空间容量的限制，所以在无法预先估计最大容量的时候，应该使用链栈。</p><p>链栈的结构和单链表的结构相同，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackNode</span><br>&#123;<br>    ElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackNode</span> *next;<br>&#125;StackNode, *LinkStack;<br></code></pre></td></tr></table></figure><p>由于栈主要操作就是插入和删除，所以不用在加入头结点。（说到底，头结点只是为了操作方便的工具罢了，不是必须的）</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(LinkStack &amp;s)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//构造一个空栈 S，栈顶指针置空</span><br>    S = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="入栈-1"><a href="#入栈-1" class="headerlink" title="入栈"></a>入栈</h4><p>入栈不需要判断栈是否满，这一点和顺序栈有所不同，只需要为入栈元素分配一个结点空间。</p><p><strong>算法步骤</strong></p><ol><li>为入栈元素 e 分配空间，用指针 p 指向。</li><li>将新结点数据域置为 e。</li><li>将新结点插入栈顶。</li><li>修改栈顶指针为 p。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231616079.png"></p><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(LinkStack &amp;S,  SElemType e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//在栈顶插入元素 e</span><br>    p = <span class="hljs-keyword">new</span> StackNode;  <span class="hljs-comment">//生成新的结点</span><br>    p-&gt;data = e;        <span class="hljs-comment">//将新结点的数据域置为 e</span><br>    p-&gt;next = S;        <span class="hljs-comment">//将新结点插入栈顶</span><br>    S = p;              <span class="hljs-comment">//修改栈顶指针为 p</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h4><p>链栈出栈前不仅要判断栈是否为空，还要释放出栈元素的栈顶空间，这是和顺序栈不同的地方。</p><p><strong>算法步骤</strong></p><ol><li>判断栈是否为空，若空则返回 ERROR。</li><li>将栈顶元素赋给 e。</li><li>临时保存栈顶元素空间，以备释放。</li><li>修改栈顶指针，指向新的栈顶元素。</li><li>释放原栈顶元素的空间。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231616914.png"></p><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(LinkStack &amp;S, SELemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//删除 S 的栈顶元素，用 e 返回其值</span><br>    <span class="hljs-keyword">if</span>(S==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//栈空</span><br>    e = S-&gt;data;               <span class="hljs-comment">//将栈顶元素赋给 e</span><br>    p = S;                     <span class="hljs-comment">//用 p 临时保存栈顶元素空间，以备释放</span><br>    S = S-&gt;next;               <span class="hljs-comment">//修改栈顶指针</span><br>    <span class="hljs-keyword">delete</span> p;                  <span class="hljs-comment">//释放原栈顶元素的空间</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="取栈顶元素-1"><a href="#取栈顶元素-1" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h4><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SElemType <span class="hljs-title">GetTop</span><span class="hljs-params">(LinkStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S!=<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> S-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h2><p>栈作为一个比较基础的数据结构，应用场景还是很多的。比较经典的应用场景就是函数调用栈。</p><p>操作系统给每个线程分配一块独立的内存空间，这块内存就被组织成”栈”这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p><h2 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h2><p>对于表达式求值，编译器通过两个栈实现运算。其中一个保存操作数的栈，另一个保存运算符的栈。从左向后遍历表达式，如果遇到数字就直接压入操作数栈；如果遇到运算符，就与运算符栈的栈顶元素进行比较。</p><p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的有限集低或相同，从运算符栈中取栈顶运算符，从操作数栈顶取两个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p><h2 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h2><h3 id="递归算法的应用情景"><a href="#递归算法的应用情景" class="headerlink" title="递归算法的应用情景"></a>递归算法的应用情景</h3><p><strong>递归</strong>：在一个函数、过程或者数据结构定义的内部又直接（或间接）出现定义本身的应用。</p><p>以下三种情况常使用递归方法：</p><h4 id="定义属于递归"><a href="#定义属于递归" class="headerlink" title="定义属于递归"></a>定义属于递归</h4><p><strong>递归求解</strong>：把一个复杂问题分解成几个相对简单且解法相同或类似的子问题来求解。</p><p>这种分解-求解的策略也叫做”分治法”。</p><p>采用”分治法”要满足以下三个条件：</p><ol><li>能将一个问题转化为新问题，并且它们解法相同，不同的仅仅是处理对象。</li><li>有一个明确的<strong>递归出口</strong>，又叫做<strong>递归的边界</strong>。</li></ol><h4 id="数据结构是递归的"><a href="#数据结构是递归的" class="headerlink" title="数据结构是递归的"></a>数据结构是递归的</h4><p>有些数据结构本身具有递归的特性，例如链表、广义表、二叉树等等。</p><h4 id="问题可以用递归求解"><a href="#问题可以用递归求解" class="headerlink" title="问题可以用递归求解"></a>问题可以用递归求解</h4><p>这里指问题采用递归求解更方便，考验脑子的时候到了。</p><h3 id="递归算法的效率分析"><a href="#递归算法的效率分析" class="headerlink" title="递归算法的效率分析"></a>递归算法的效率分析</h3><h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>算法分析中，如果一个算法包含递归调用时，时间复杂度可以转化为一个递归方程求解。迭代法是求解递归方程的一个常用方法，迭代的展开递归方程的右端，变成一个非递归的和式，然后通过对和式的估计来达到对方程左端的估计。</p><h4 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h4><p>分析递归算法的空间复杂度需要分析工作栈的大小。</p><p><code>S(n) = O(f(n))</code>，其中 f(n) 为”递归工作栈”中工作记录的个数与问题规模 n 的函数关系。</p><h3 id="利用栈将递归转化为非递归的方法"><a href="#利用栈将递归转化为非递归的方法" class="headerlink" title="利用栈将递归转化为非递归的方法"></a>利用栈将递归转化为非递归的方法</h3><p>步骤：</p><ol><li>设置一个递归工作栈存放递归工作记录（包括实参、返回地址及局部变量等）。</li><li>进入非递归调用入口，将调用程序传来的实参和返回地址入栈。</li><li>进入递归调用入口：不满足递归结束条件时，逐层递归，将实参、返回地址及局部变量入栈。这一步可以用循环语句完成。</li><li>递归结束条件满足，将到达递归出口的给定常数作为当前的函数值。</li><li>返回处理：栈非空的情况下，反复退出栈顶记录，逐层计算当前函数值，直到栈空为止。</li></ol><p>由于递归调用的特性，可以将任何递归算法改成非递归算法，但是改写后的算法和原来比结构不够清晰，可读性较差。</p><h2 id="队列的表示和操作的实现"><a href="#队列的表示和操作的实现" class="headerlink" title="队列的表示和操作的实现"></a>队列的表示和操作的实现</h2><h3 id="队列的类型定义"><a href="#队列的类型定义" class="headerlink" title="队列的类型定义"></a>队列的类型定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ADT Queue&#123;<br>    数据对象：D=&#123;aila∈ElemSet,i=l,<span class="hljs-number">2</span>,…,n,n&gt;=O&#125;<br>    数据关系：R=&#123;&lt;ai<span class="hljs-number">-1</span>,ai&gt;|ai,ai∈D,i=<span class="hljs-number">2</span>,…,n&#125;<br>        约定其中a1端为队列头，an端为队列尾。<br>    基本操作：<br>        <span class="hljs-built_in">InitQueue</span>(&amp;Q)<br>            操作结果：构造一个空队列Q。<br>        <span class="hljs-built_in">DestroyQueue</span>(&amp;Q)<br>            初始条件：队列Q已存在。<br>            操作结果：队列Q被销毁， 不再存在。<br>        <span class="hljs-built_in">ClearQueue</span>(&amp;Q)<br>            初始条件：队列Q巳存在。<br>            操作结果：将Q清为空队列。<br>        <span class="hljs-built_in">QueueEmpty</span>(Q)<br>            初始条件：队列Q已存在。<br>            操作结果：若Q为空队列，则返回<span class="hljs-literal">true</span>, 否则返回<span class="hljs-literal">false</span>。<br>        <span class="hljs-built_in">QueueLength</span>(Q)<br>            初始条件：队列Q已存在。<br>            操作结果：返回Q的元素个数，即队列的长度。<br>        <span class="hljs-built_in">GetHead</span>(Q&#125;<br>            初始条件：Q为非空队列。<br>            操作结果：返回Q的队头元素。<br>        <span class="hljs-built_in">EnQueue</span>(&amp;Q,e)<br>            初始条件：队列Q已存在。<br>            操作结果：插入元素e为Q的新的队尾元素。<br>        <span class="hljs-built_in">DeQueue</span>(&amp;Q,&amp; e)<br>            初始条件：Q为非空队列。<br>            操作结果：删除Q的队头元素，并用e 返回其值。<br>        <span class="hljs-built_in">QueueTraverse</span>(Q)<br>            初始条件：Q巳存在且非空。<br>            操作结果：从队头到队尾，依次对Q的每个数据元素访问。<br>&#125;ADT Queue<br></code></pre></td></tr></table></figure><h3 id="循环队列——队列的顺序表示和实现"><a href="#循环队列——队列的顺序表示和实现" class="headerlink" title="循环队列——队列的顺序表示和实现"></a>循环队列——队列的顺序表示和实现</h3><p>在队列的顺序存储结构中，需要附设两个整型变量 front 和 rear 分别指示队列头元素和队列尾元素的位置。</p><p>队列的顺序存储结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    QElemType *base;  <span class="hljs-comment">//存储空间的基地址</span><br>    <span class="hljs-type">int</span> front;        <span class="hljs-comment">//头指针</span><br>    <span class="hljs-type">int</span> rear;         <span class="hljs-comment">//尾指针</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><p>初始化创建空队列时，设置 front &#x3D; rear &#x3D; 0，插入新元素尾指针 rear 加一，删除队列头元素头指针 front 加一。头指针始终指向队列头元素，尾指针始终指向队列尾元素的下一个元素。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231617112.png"></p><p>但是这样的队列结构容易造成”假溢出”的现象。这是由”队尾入队，队头出队”这种限制的操作造成的。</p><p>解决”假溢出”的解决办法之一就是使用循环队列。</p><p>循环队列的核心在于对头尾指针进行取模操作。</p><p>但由于循环队列的特性，不能再使用头尾指针的值是否相同来判断队列空间是”满”还是”空”。面对这一情况有两种解决办法：</p><ol><li>少用一个元素空间，这样当头尾指针的值相同时可以判断队列为空，当尾指针在循环意义上加一后等于头指针的值，此时可以认为队列已满。循环队列中队空和队满的条件：<br>队空：<code>Q.front == Q.rear</code><br>队满：<code>(Q.rear + 1) % MAXSIZE == Q.front</code></li><li>另设一个标志位区分队列是”空”还是”满”。</li></ol><p>现在使用第一种方法实现循环队列。循环队列的类型定义和顺序队列是一样的。</p><h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4><p>初始化就是动态分配分配一个数组空间。</p><p><strong>算法步骤</strong></p><ol><li>为队列分配一个最大容量为 MAXSIZE 的数组空间，base 指向数组空间的首地址。</li><li>头指针和尾指针设置为 0，表示队列为空。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">status <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//构造空队列 Q</span><br>    Q.base = <span class="hljs-keyword">new</span> QElemType[MAXSIZE];  <span class="hljs-comment">//为队列分配一个最大容量为 MAXSIZE 的数组空间</span><br>    <span class="hljs-keyword">if</span>(!Q.base) <span class="hljs-built_in">exit</span>(OVERFLOW);       <span class="hljs-comment">//存储分配失败</span><br>    Q.front = Q.rear = <span class="hljs-number">0</span>;             <span class="hljs-comment">//头尾指针设置为0，队列为空</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="求队列长度"><a href="#求队列长度" class="headerlink" title="求队列长度"></a>求队列长度</h4><p>对于顺序队列而言，头尾指针之差就是队列长度。但对于循环队列而言显然不同，此时差值可能为负数。所以要给差值加上 MAXSIZE ，然后再求模。</p><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QueueLength</span><span class="hljs-params">(SqQueue Q)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (Q.rear-Q.front+MAXSIZE)%MAXSIZE;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><p><strong>算法步骤</strong></p><ol><li>判断队列是否为满，如果已满则返回 ERROR。</li><li>将新元素插入队尾。</li><li>队尾指针加一。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q,QElemType e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//插入元素 e 为 Q 的新的队尾元素</span><br>    <span class="hljs-keyword">if</span>((Q.rear<span class="hljs-number">+1</span>)%MAXSIZE==Q.front)   <span class="hljs-comment">//尾指针在循环意义上加一后等于头指针表示队列已满</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>    Q.base[Q.rear] = e;               <span class="hljs-comment">//新元素插入队尾</span><br>    Q.rear = (Q.rear + <span class="hljs-number">1</span>) % MAXSIZE;  <span class="hljs-comment">//队尾指针加一</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h4><p><strong>算法步骤</strong></p><ol><li>判断队列是否为空，若空则返回 ERROR。</li><li>保存队头元素。</li><li>队头指针加一。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q,QElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//删除 Q 的队头元素，用 e 返回其值</span><br>    <span class="hljs-keyword">if</span>(Q.front==Q.rear) <span class="hljs-keyword">return</span> ERROR;   <span class="hljs-comment">//队空</span><br>    e = Q.base[Q.front];                <span class="hljs-comment">//保存队头元素</span><br>    Q.front = (Q.front + <span class="hljs-number">1</span>) % MAXSIZE;  <span class="hljs-comment">//队头指针加一</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="取队头元素"><a href="#取队头元素" class="headerlink" title="取队头元素"></a>取队头元素</h4><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SElemType <span class="hljs-title">GetQueue</span><span class="hljs-params">(SqQueue Q)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//返回 Q 对队头元素，不修改队头指针</span><br>    <span class="hljs-keyword">if</span>(Q.front != Q.rear)        <span class="hljs-comment">//队列非空</span><br>        <span class="hljs-keyword">return</span> Q.base[Q.front];  <span class="hljs-comment">//返回队头元素的值，队头指针不变</span><br>&#125;<br></code></pre></td></tr></table></figure><p>循环队列说到底也属于顺序存储，还是有队列的最大长度。如果无法预测队列的最大长度，最好采用链队。</p><h3 id="链队——队列的链式表示和实现"><a href="#链队——队列的链式表示和实现" class="headerlink" title="链队——队列的链式表示和实现"></a>链队——队列的链式表示和实现</h3><p>链队通常用单链表来表示。一个链队需要两个分别指示队头和队尾的指针。为了操作方便可以给链队添加一个头结点，让头指针始终指向头结点。</p><p>队列的链式存储结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">QNode</span><br>&#123;<br>    QElemType data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">QNode</span> *next;<br>&#125;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    QueuePtr front;  <span class="hljs-comment">//队头指针</span><br>    QueuePtr rear;   <span class="hljs-comment">//队尾指针</span><br>&#125;<br></code></pre></td></tr></table></figure><p>链队的操作即为单链表插入和删除操作的特殊情况，就是需要再注意一下尾指针或头指针的修改。</p><h4 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h4><p>构造一个只有一个头结点的空对。</p><p><strong>算法步骤</strong></p><ol><li>生产新结点作为头结点，队头和队尾指针指向此结点。</li><li>头结点的指针域置空。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span><br><span class="hljs-function"></span>&#123;<br>    Q.front = Q.reat = <span class="hljs-keyword">new</span> QNode;  <span class="hljs-comment">//生成新结点作为头结点，队头和队尾指针指向此结点</span><br>    Q.front-&gt;next = <span class="hljs-literal">NULL</span>;          <span class="hljs-comment">//头结点的指针域置空</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h4><p>由于链队可以”无限”添加元素，所以不需要像顺序队列那样判断队列是否满，只需要为入队元素动态分配一个结点空间。</p><p><strong>算法步骤</strong></p><ol><li>为入队元素分配结点空间，用指针 p 指向。</li><li>将新结点数据域置为 e。</li><li>将新结点插入到队尾。</li><li>修改队尾指针为 p。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231617287.png"></p><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q,QElemType e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//插入元素 e 为 Q 的新的队尾元素</span><br>    p = <span class="hljs-keyword">new</span> QNode;     <span class="hljs-comment">//为入队元素分配结点空间，用指针 p 指向</span><br>    p-&gt;data = e;       <span class="hljs-comment">//将新结点指针域置为 e</span><br>    p-&gt;next = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//将新结点插入队尾</span><br>    Q.rear-&gt;next = p;<br>    Q.rear = p;        <span class="hljs-comment">//修改队尾指针</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h4><p>出队就需要判断链队是否为空了。并且链队出队后需要放出队头元素所占空间。</p><p><strong>算法步骤</strong></p><ol><li>判断队列是否为空，若空则返回 ERROR。</li><li>临时保存队头元素的空间，以备释放。</li><li>修改头结点的指针域，指向下一个结点。（头结点的优点就体现出来了）</li><li>判断出队元素是否为最后一个元素，若是则将队尾指针重新赋值，指向头结点。</li><li>释放原队头元素的空间。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q,QElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//删除 Q 的队头元素，用 e 返回其值</span><br>    <span class="hljs-keyword">if</span>(Q.front==Q.rear) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//若队列为空则返回 ERROR</span><br>    p = Q.front-&gt;next;                 <span class="hljs-comment">//p 指向队头元素</span><br>    e = p-&gt;data;                       <span class="hljs-comment">//e 保持队头元素的值</span><br>    Q.front-&gt;next = p-&gt;next;           <span class="hljs-comment">//修改头结点的指针域</span><br>    <span class="hljs-keyword">if</span>(Q.rear==p)                      <span class="hljs-comment">//如果最后一个元素被删</span><br>        Q.rear = Q.front;              <span class="hljs-comment">//那就将队尾指针指向头结点</span><br>    <span class="hljs-keyword">delete</span> p;                          <span class="hljs-comment">//释放原队头元素的空间</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>链队出队操作要考虑如果队列最后一个元素被删，队列尾指针也丢失了，要给队尾指针重新复制指向头结点。</p><h4 id="取队头元素-1"><a href="#取队头元素-1" class="headerlink" title="取队头元素"></a>取队头元素</h4><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SElemType <span class="hljs-title">GetHead</span><span class="hljs-params">(LinkQueue Q)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//返回 Q 的队头元素，不修改队头指针</span><br>    <span class="hljs-keyword">if</span>(Q.front!=Q.rear)              <span class="hljs-comment">//队列非空</span><br>        <span class="hljs-keyword">return</span> Q.front-&gt;next-&gt;data;  <span class="hljs-comment">//返回队头元素的值，队头指针不变</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231617730.png"></p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231617726.png"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表</title>
    <link href="/2025/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2025/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>线性结构的基本特点：除第一个元素无直接前驱，最后一个元素无直接后驱之外，其他每个数据元素都有一个前驱和后驱。</p><h2 id="线性表的定义和特点"><a href="#线性表的定义和特点" class="headerlink" title="线性表的定义和特点"></a>线性表的定义和特点</h2><p><strong>线性表</strong>：由 n 个数据特性相同的元素构成的有限序列称为线性表。</p><p>n&#x3D;0 时称为<strong>空表</strong>。</p><p>线性表既可以使用顺序存储也可以使用链式存储。</p><h2 id="线性表的类型定义"><a href="#线性表的类型定义" class="headerlink" title="线性表的类型定义"></a>线性表的类型定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ADT list&#123;<br>    数据对象:D=&#123;ai|ai属于ElemSet,i=<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,...,n,n&gt;=<span class="hljs-number">0</span>&#125;<br>    数据关系R=&#123;&lt;ai<span class="hljs-number">-1</span>,ai&gt;|ai<span class="hljs-number">-1</span>,ai属于D,i=<span class="hljs-number">2</span>,...,n&#125;<br>    基本操作:<br>        <span class="hljs-built_in">InitList</span>(&amp;L)<br>            操作结果:构造一个空的线性表L。<br>        <span class="hljs-built_in">DestroyList</span>(&amp;L)<br>            初始条件:线性表L已存在。<br>            操作结果:销毁线性表L。<br>        <span class="hljs-built_in">ClearList</span> (&amp;L)<br>            初始条件：线性表L已存在。<br>            操作结果：将L重置为空表。<br>        <span class="hljs-built_in">ListEmpty</span>(L)<br>            初始条件：线性表L已存在。<br>            操作结果：若L为空表， 则返回<span class="hljs-literal">true</span>, 否则返回<span class="hljs-literal">false</span>。<br>        <span class="hljs-built_in">ListLength</span>(L)<br>            初始条件：线性表L已存在。<br>            操作结果：返回L中数据元素个数。<br>        <span class="hljs-built_in">GetElem</span>(L,i,&amp;e)<br>            初始条件：线性表L巳存在， 且<span class="hljs-number">1</span>&lt;=s&lt;=<span class="hljs-built_in">ListLength</span>(L)。<br>            操作结果：用e返回L中第<span class="hljs-number">1</span>个数据元素的值。<br>        <span class="hljs-built_in">LocateElem</span>(L,e)<br>            初始条件：线性表L已存在。<br>            操作结果：返回L中第<span class="hljs-number">1</span>个值与e相同的元素在L中的位置。若这样的数据元素不存在， 则返回值为<span class="hljs-number">0</span>。<br>        <span class="hljs-built_in">PriorElem</span>(r,,cur_e,&amp;pre_e)<br>            初始条件：线性表L已存在。<br>            操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回其前驱，否则操作失败，pre_e无定义。<br>        <span class="hljs-built_in">NextElem</span>(L,cur_e,&amp;next_e)<br>            初始条件：线性表L已存在。<br>            操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回其后继，否则操作失败，next_e无定义。<br>        <span class="hljs-built_in">Listinsert</span>(&amp;L,i,e)<br>            初始条件： 线性表L已存在，且<span class="hljs-number">1</span>&lt;=s&lt;=<span class="hljs-built_in">ListLength</span>(L)+l。<br>            操作结果：在L中第<span class="hljs-number">1</span>个位置之前插入新的数据元素e, L的长度加<span class="hljs-number">1</span>。<br>        <span class="hljs-built_in">ListDelete</span>(&amp;L,i)<br>            初始条件：线性表L 已存在且非空，且<span class="hljs-number">1</span>&lt;=s&lt;=<span class="hljs-built_in">ListLength</span>(L)。<br>            操作结果：删除L的第<span class="hljs-number">1</span>个数据元素，L的长度减<span class="hljs-number">1</span>。<br>        <span class="hljs-built_in">TraverseList</span>(L)<br>            初始条件：线性表L已存在。<br>            操作结果：对线性表L进行遍历，在遍历过程中对L的每个结点访问一次。<br>&#125;ADT List;<br></code></pre></td></tr></table></figure><h2 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h2><h3 id="线性表的顺序存储表示"><a href="#线性表的顺序存储表示" class="headerlink" title="线性表的顺序存储表示"></a>线性表的顺序存储表示</h3><p><strong>线性表的顺序存储表示</strong>：用一组地址连续的存储单元依次存储线性表的数据元素。称这种存储结构的线性表为<strong>顺序表</strong>。</p><p>其<strong>特点</strong>是：逻辑上相邻的数据元素，其物理次序也是相邻的。</p><p>线性表的顺序存储是一种<strong>随机存取</strong>的存储结构，由于通常都用数组来描述数据结构中的顺序存储结构，并且线性表的长度可变，在 C 语言中可用动态分配的一维数组表示线性表，描述如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100    <span class="hljs-comment">//顺序表可能达到的最大长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    ElemType *elem;    <span class="hljs-comment">//存储空间的基地址</span><br>    <span class="hljs-type">int</span> length;        <span class="hljs-comment">//当前长度</span><br>&#125;SqList                <span class="hljs-comment">//顺序表的结构类型为SqList</span><br></code></pre></td></tr></table></figure><p>其中，ElemType 数据类型可以替换成具体定义表中数据元素的数据类型，既可以是基本数据类型，也可以是构造数据类型（如 struct 结构体类型）。</p><h3 id="顺序表中基本操作的实现"><a href="#顺序表中基本操作的实现" class="headerlink" title="顺序表中基本操作的实现"></a>顺序表中基本操作的实现</h3><p>当线性表以顺序表示时，表的长度是顺序表的一个”属性”，因此一些涉及表长度的基本操作算法的时间复杂度都是 O(1)</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>顺序表的初始化操作就是构造一个空的顺序表</p><p><strong>算法步骤</strong></p><ol><li>为顺序表 L 动态分配一个预定义大小的数组空间，使 elem 指向这段空间的基地址</li><li>将表的当前长度设为 0</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(SqList &amp;L)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//构造一个空的顺序表</span><br>    L.elem = <span class="hljs-keyword">new</span> ElemType[MAXSIZE];    <span class="hljs-comment">//为顺序表分配一个大小为MAXSIZE的数组空间</span><br>    <span class="hljs-keyword">if</span>(!L.elem) <span class="hljs-built_in">exit</span>(OVERFLOW);        <span class="hljs-comment">//存储分配失败退出</span><br>    L.length = <span class="hljs-number">0</span>;                      <span class="hljs-comment">//空表长度为0</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>采用动态分配线性表的存储区域可以更有效的利用系统资源，当不需要该线性表时，可以使用销毁操作及时释放占用的存储空间</p><h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><p>由于顺序存储结构具有随机存储的特点，可以直接通过数组下标定位得到，elem[i]单元存储第 i 个数据元素。</p><p><strong>算法步骤</strong></p><ol><li>判断指定的位置序号 i 值是否合理，如果不合理则返回 ERROR。</li><li>若 i 值合理，则将第 i 个数据元素 L.elem[i-1]赋给参数 e，通过 e 返回第 i 个数据元素的传值。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L,<span class="hljs-type">int</span> i,ElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length) <span class="hljs-keyword">return</span> ERROR;    <span class="hljs-comment">//判断i值是否合理，若不合理，返回ERROR</span><br>    e = L.elem[i<span class="hljs-number">-1</span>];                     <span class="hljs-comment">//elem[i-1]单元存储第i个数据元素</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>顺序表取值算法的时间复杂度为 O(1)。</p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>查找操作根据指定元素值 e，查找顺序表中第 1 个与 e 相等的元素 L.elem[i]，若查找成功返回该元素的序号 i+1；若查找失败，则返回 0.</p><p><strong>算法步骤</strong></p><ol><li>从第一个元素开始，依次与 e 相比较，若找到与 e 相等的元素 L.elem[i]，则查找成功，返回该元素的序号 i+1。</li><li>若查找整个顺序表都没找到，则查找失败，返回 0。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList L,ElemType e)</span></span><br><span class="hljs-function"></span>&#123;在顺序表L中查找值为e的数据元素，返回其序号<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;L.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(L.elem[i] == e)    <span class="hljs-comment">//查找成功，返回序号i+1</span><br>            <span class="hljs-keyword">return</span> i<span class="hljs-number">+1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                 <span class="hljs-comment">//查找失败，返回0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在顺序表中查找数据元素时，时间主要耗费在数据的比较上，比较的次数取决于被查元素在线性表中的位置。</p><p>设定查找算法在查找成功时的平均查找长度（ASL）为和给定值进行比较大数据元素个数的期望值。</p><p>顺序表按值查找算法的平均时间复杂度为 O(n)。</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>一般情况下，在线性表第 i 个位置插入一个元素时，需从最后一个元素即第 n 个元素开始，依次向后移动一个位置，直至第 i 个元素。</p><p><strong>算法步骤</strong></p><ol><li>判断插入位置 i 是否合法，若不合法则返回 ERROR</li><li>判断顺序表的存储空间是否已满，若满则返回 ERROR</li><li>将第 n 个至第 i 个位置的元素依次向后移动一个位置，空出第 i 个位置</li><li>将要插入的新元素 e 放入第 i 个位置</li><li>表长加 1</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//在顺序表L中第i个为位置之前插入新的元素e，i的合法范围是[1,L.length]</span><br>    <span class="hljs-keyword">if</span>((i &lt; <span class="hljs-number">1</span>) || (i &gt; L.length<span class="hljs-number">+1</span>)) <span class="hljs-keyword">return</span> ERROR;    <span class="hljs-comment">//i值不合法</span><br>    <span class="hljs-keyword">if</span>(L.length == MAXSIZE) <span class="hljs-keyword">return</span> ERROR;            <span class="hljs-comment">//当前存储空间已满</span><br>    <span class="hljs-keyword">for</span>(j=L.length<span class="hljs-number">-1</span>;j&gt;=i<span class="hljs-number">-1</span>;j--)&#123;<br>        L.elem[j<span class="hljs-number">+1</span>] = L.elem[j];                     <span class="hljs-comment">//插入位置及之后的元素后移</span><br>    &#125;<br>    L.elem[i<span class="hljs-number">-1</span>]=e;                                   <span class="hljs-comment">//将新元素e放入第i个位置</span><br>    ++L.length;                                      <span class="hljs-comment">//表长加1</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>顺序表插入算法的平均时间复杂度为 O(n)。</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除第 i 个元素时需将第 i+1 个至第 n 个元素依次向前移动一个位置</p><p><strong>算法步骤</strong></p><ol><li>判断删除位置 i 是否合法，若不合法返回 ERROR。</li><li>将第 i+1 个至第 n 个点元素依次向前移动一个位置。</li><li>表长减 1。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//在顺序表中删除第i个元素，i的合法范围是[1,L.length]</span><br>    <span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L.length)) <span class="hljs-keyword">return</span> ERROR;    <span class="hljs-comment">//i值不合法</span><br>    <span class="hljs-keyword">for</span>(j=i;j&lt;=L.length<span class="hljs-number">-1</span>;j++)<br>        L.elem[j<span class="hljs-number">-1</span>] = L.elem[j];             <span class="hljs-comment">//被删除元素之后的元素前移</span><br>    --L.length;                              <span class="hljs-comment">//表长减1</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>顺序表删除算法的平均时间复杂度为 O(n)。</p><p>在做插入或删除操作时，需要移动大量元素，同时导致操作过程相对复杂，导致存储空间的浪费，需要使用链式存储结构来解决这些难题。</p><h2 id="线性表的链式表示和实现"><a href="#线性表的链式表示和实现" class="headerlink" title="线性表的链式表示和实现"></a>线性表的链式表示和实现</h2><h3 id="单链表的定义和表示"><a href="#单链表的定义和表示" class="headerlink" title="单链表的定义和表示"></a>单链表的定义和表示</h3><p><strong>线性表链式存储结构的特点</strong>：用一组任意的存储单元存储线性表的数据元素。</p><p>为了实现这样的特点，对于每个数据元素，除去本身的信息，还需要存储一个指示其直接后继的信息，用来展示它们之间的逻辑关系。这两部分信息组成数据元素的存储映像，称作<strong>结点。</strong></p><p>结点包括两个域：</p><ul><li><strong>数据域</strong>：存储数据元素信息的域。</li><li><strong>指针域</strong>：存储直接后继存储位置的域。</li></ul><p>指针域中存储的信息被称作<strong>指针</strong>或<strong>链</strong>。</p><p>n 个结点链结成一个<strong>链表</strong>，即为<strong>线性表的链式存储结构</strong></p><p>这样的链表的每个结点中只包含一个指针域，所以又被称作<strong>线性链表</strong>或<strong>单链表</strong>。单链表、循环链表和双向链表用于实现线性链表的链式存储结构，其他形式多用于实现树和图等非线性结构。</p><p>整个链表的存取必须从头指针开始进行，头指针指示链表中的第一个结点的存储位置，单链表中最后一个结点的指针为空（NULL）。用单链表表示线性表时，数据元素之间的逻辑关系是由结点中的指针指示的，个个结点物理位置不相邻，并不关心它们的实际位置。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231606780.png"></p><p>单链表可由头指针唯一确定，在 C 语言中可用”结构指针”来描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span><br>&#123;<br>    ElemType data;         <span class="hljs-comment">//结点的数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> *next;    <span class="hljs-comment">//结点的指针域</span><br>&#125;LNode,*LinkList;          <span class="hljs-comment">//LinkList为指向结构体LNode的指针类型</span><br></code></pre></td></tr></table></figure><p>习惯上用 LinkList 定义单链表，使用 LNode*定义指向单链表中任意结点的指针变量。</p><p>注意区分指针变量和结点变量两个不同的概念，如果定义 LinkList p 或 LNode <em>p，则 p 为指向某结点的指针变量，表示该结点的地址；而</em>p 为对应的结点变量，表示该结点的名称。</p><p>一般情况下，为了处理方便，在单链表的第一个结点之前附设一个结点，称之为头结点。</p><p>头结点的优点：</p><ul><li>便于首元结点的处理<br>增加头结点后，首元结点的地址保存在头结点的指针域中，取消了首元结点的特殊性。</li><li>便于空表和非空表的统一处理<br>当链表不设头结点时，如果为空表，L 指针为空（NULL）<br>增加头结点后，无论链表是否为空，头指针都是指向头结点的非空指针，若为空表，则头结点的指针域为空（判定空表的条件：L-&gt;next &#x3D;&#x3D; NULL）</li></ul><p>区分首元结点、头结点、头指针：</p><ul><li>首元结点：链表中存储第一个数据元素的结点</li><li>头结点：首元结点之前附设的一个结点，其指针域指向首元结点</li><li>头指针：指向链表汇总第一个结点的指针，指向头结点（如果有）或首元结点（如果没有头结点）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231607496.png"></p><p>由于单链表是非随机存取的存储结构，要取得第 i 个元素必须从头指针出发顺链进行寻找，也就是顺序存取结构。</p><h3 id="单链表基本操作的实现"><a href="#单链表基本操作的实现" class="headerlink" title="单链表基本操作的实现"></a>单链表基本操作的实现</h3><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>单链表的初始化操作就是构造一个空表。</p><p><strong>算法步骤</strong></p><ol><li>生成新结点作为头结点，用头指针 L 指向头结点</li><li>头结点指针域置空</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(LinkList &amp;L)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//构造一个空的单链表L</span><br>    L = <span class="hljs-keyword">new</span> LNode;     <span class="hljs-comment">//生成新结点作为头结点，用头指针L指向头结点</span><br>    L-&gt;next = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//头结点指针域置空</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="取值-1"><a href="#取值-1" class="headerlink" title="取值"></a>取值</h4><p>由于链表非随机存取的特性，只能从链表的首元结点出发，顺着链域 next 逐个结点向下访问。</p><p><strong>算法步骤</strong></p><ol><li>用指针 p 指向首元结点，用 j 做计数器初值赋为 1。</li><li>从首元结点开始依次顺着链域 next 向下访问，只要指向当前结点的指针 p 不为空，并且没有到达序号为 i 的结点，则循环执行以下操作：</li></ol><ul><li>p 指向下一个结点</li><li>计数器 j 相应加 1</li></ul><ol start="3"><li>退出循环时，如果指针 p 为空，或者计数器 j 大于 i，说明指定的序号 i 值不合法，取值失败返回 ERROR；否则取值成功，此时 j&#x3D;i 时，p 所指的结点就是要找的第 i 个结点，用参数 e 保存当前结点的数据域，返回 OK。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L,<span class="hljs-type">int</span> i,ElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//在带头结点的单链表L中根据序号i获取元素的值，用e返回L中第i个数据元素的值</span><br>    p = L-&gt;next;j=<span class="hljs-number">1</span>;           <span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">while</span>(p&amp;&amp;j&lt;i)&#123;             <span class="hljs-comment">//顺链域扫描</span><br>        p = p-&gt;next;           <span class="hljs-comment">//p指向下一个结点</span><br>        ++j;                   <span class="hljs-comment">//计数器+1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p||j&gt;i) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//i值不合法</span><br>    e=p-&gt;data;                 <span class="hljs-comment">//取得第i个结点的数据域</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>算法的最坏时间复杂度为 O(n)，平均时间复杂度为 O(n)。</p><h4 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h4><p>链表中按值查找的过程和顺序表类似</p><p><strong>算法步骤</strong></p><ol><li>用指针 p 指向首元结点。</li><li>从首元结点开始依次顺着链域 next 向下查找，只要指向当前结点的指针 p 不为空，并且 p 所指结点的数据域不等于给定值 e，则循环执行以下操作：p 指向下一个结点。</li><li>返回 p，若查找成功，p 此时即为结点的地址值，若查找失败，p 的值即为 NULL。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">LNode *<span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L,Elemtype e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//在带头结点的单链表L中查找值为e的元素</span><br>    p = L-&gt;next;            <span class="hljs-comment">//初始化，p指向首元结点</span><br>    <span class="hljs-keyword">while</span>(P &amp;&amp; p-&gt;data!=e)  <span class="hljs-comment">//顺链域向后扫描</span><br>        p = p-&gt;next;        <span class="hljs-comment">//p指向下一结点</span><br>    <span class="hljs-keyword">return</span> p;               <span class="hljs-comment">//查找成功返回值为e的结点地址p，查找失败p为NULL</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该算法的平均时间复杂度为 O(n)。</p><h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><p>插入数据元素 x，要先生成一个数据域为 x 的结点，然后插入到单链表中。插入操作需要先修改前置结点中的指针域，令其指向结点 x，结点 x 中的指针域应指向后继结点，从而实现三个元素之间逻辑关系的变化。上述过程用代码描述即为：<code>s-&gt;next = p-&gt;next; p-&gt;next = s</code></p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231608867.png"></p><p><strong>算法步骤</strong></p><ol><li>查找结点 ai-1 并由指针 p 指向该结点</li><li>生成一个新结点*s</li><li>将新结点*s 的数据域置为 e</li><li>将新结点*s 的指针域指向结点 ai</li><li>将结点<em>p 的指针域指向新结点</em>s</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>    p = L;j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">0</span> &amp;&amp; (j&lt;i<span class="hljs-number">-1</span>))&#123;<br>        p = p-&gt;next;             <span class="hljs-comment">//查找第i-1个结点，p指向该结点</span><br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p||j&gt;i<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//i&gt;n+1或i&lt;1</span><br>    s = <span class="hljs-keyword">new</span> LNode;               <span class="hljs-comment">//生成新结点s</span><br>    s-&gt;data = e;                 <span class="hljs-comment">//将结点*s的数据域置为e</span><br>    s-&gt;next = p-&gt;next;           <span class="hljs-comment">//将结点*s的指针域指向结点ai</span><br>    p-&gt;next = s;                 <span class="hljs-comment">//将结点*p的指针域指向结点*s</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，单链表的插入操作虽然不需要像顺序表的插入操作一样移动元素，但是平均时间复杂度仍然是 O(n)。这是因为单链表是非随机存取的结构，要花费大量的时间找到第 i-1 个结点。</p><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>删除和插入一样，都要先找到该位置的前驱结点，所以时间复杂度是 O(n)。</p><p>要实现删除某一结点，只需要将前驱结点的指针域指向后继结点即可。不过需要注意的是，要实现真正的删除，还要释放目标结点所占的空间，在修改指针前，应该引入一个指针临时保存结点 b 的地址以备释放。</p><p><strong>算法步骤</strong></p><ol><li>查找结点 ai-1 并由指针 p 指向该结点</li><li>临时保存待删除结点 ai 的地址在 q 中，以备释放</li><li>将结点*p 的指针域指向 ai 的直接后继结点</li><li>释放结点 ai 的空间</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    p = L;j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>((p-&gt;next) &amp;&amp; (j&lt;i<span class="hljs-number">-1</span>))&#123;           <span class="hljs-comment">//查找第i个结点，p指向该结点</span><br>        p = p-&gt;next;<br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!(p-&gt;next)||(j&gt;i<span class="hljs-number">-1</span>)) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//当i&gt;n或i&lt;1时，删除位置不合理</span><br>    q = p-&gt;next;                           <span class="hljs-comment">//临时保存被删结点的地址以备释放</span><br>    p-&gt;next = q-&gt;next;                     <span class="hljs-comment">//改变删除结点前驱结点的指针域</span><br>    <span class="hljs-keyword">delete</span> q;                              <span class="hljs-comment">//释放删除结点的空间</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，删除操作的循环条件<code>(p-&gt;next) &amp;&amp; (j&lt;i-1)</code>和插入操作的循环条件<code>p&amp;&amp; (j&lt;i-1)</code>是有区别的——插入操作中合法的插入位置有 n+1 个，而删除操作中合法的删除操作只有 n 个，此时如果使用与插入操作相同的循环条件，则会出现引用空指针的情况，会使删除操作失败。</p><p>删除算法的时间复杂度也是 O(n)。</p><h4 id="创建单链表"><a href="#创建单链表" class="headerlink" title="创建单链表"></a>创建单链表</h4><p>链表是一种动态结构，整个可用存储空间可为多个链表共同享用（整体结构非常松散），每个链表占用的空间不需要预先分配划定，而是由系统按需即时生成。</p><p>根据结点插入位置不同，可以分为前插法和后插法</p><h5 id="前插法"><a href="#前插法" class="headerlink" title="前插法"></a>前插法</h5><p>前插法通过将新结点逐个插入链表的头部来创建链表。需要注意的是，前插法输入顺序和线性表中的逻辑顺序应该是相反的，要逆序输入数据。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231608909.png"></p><p><strong>算法步骤</strong></p><ol><li>创建一个只有头结点的空链表</li><li>根据待创建链表包括的元素个数 n，循环 n 次执行以下操作：</li></ol><ul><li>生成一个新结点*p</li><li>输入元素值赋给新结点*p 的数据域</li><li>将新结点*p 插入到头结点之后</li></ul><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_H</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    L = <span class="hljs-keyword">new</span> LNode;<br>    L-&gt;next = <span class="hljs-literal">NULL</span>;         <span class="hljs-comment">//先建立一个带头结点的空链表</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        p = <span class="hljs-keyword">new</span> LNode;      <span class="hljs-comment">//生成新结点*p</span><br>        cin&gt;&gt;p-&gt;data;       <span class="hljs-comment">//输入元素值符给新结点*p的数据域</span><br>        p-&gt;next = L-&gt;next;  <span class="hljs-comment">//将新结点*p插入到头结点之后</span><br>        L-&gt;next = p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然算法的时间复杂度为 O(n)。</p><h5 id="后插法"><a href="#后插法" class="headerlink" title="后插法"></a>后插法</h5><p>后插法可以按照顺序添加，但是与前插法不同的是，为了使新结点能够插入到表尾，需要增加一个尾指针 r 指向链表的尾结点。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231609169.png"></p><p><strong>算法步骤</strong></p><ol><li>创建一个只有头结点的空链表</li><li>尾指针 r 初始化，指向头结点</li><li>根据创建链表包括的元素个数 n，循环 n 次执行以下操作：</li></ol><ul><li>生成一个新结点*p</li><li>输入元素值赋给新结点*p 的数据域</li><li>将新结点<em>p 插入到尾结点</em>r 之后</li><li>尾指针指向新的尾结点*p</li></ul><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_R</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    L = <span class="hljs-keyword">new</span> LNode;<br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<br>    r = L;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        p = <span class="hljs-keyword">new</span> LNode;<br>        cin&gt;&gt;p-&gt;data;<br>        p-&gt;next = <span class="hljs-literal">NULL</span>;<br>        r-&gt;next = p;<br>        r = p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>算法的时间复杂度为 O(n</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表的特点是表中最后一个结点的指针域指向头结点。由此从表中任一结点出发均可找到表中其他结点。</p><p>循环单链表和单链表唯一的差别就在于：链表遍历时，判别当前指针 p 是否指向表尾结点的终止条件不同——单链表判别条件是<code>p!=NULL或p-&gt;next!-NULL</code>，而循环单链表的判别条件为<code>p!=L或p-&gt;next!=L</code></p><p>某些条件下若在循环链表中设立尾指针而不设头指针，可使一些操作简化。（说到底，头指针也只是为了操作简化，并不是必须的）</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>在单链表和循环单链表中，查找直接后继结点的执行时间为 O(1)，而查找直接前驱的执行时间为 O(n)。为了克服这个缺点可以使用双向链表。</p><p>双向链表有两个指针域，一个指向直接后继，另一个指向直接前驱，结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DulNode</span><br>&#123;<br>    ElemType data;          <span class="hljs-comment">//数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DulNode</span> *prior;  <span class="hljs-comment">//直接前驱</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DulNode</span> *next;   <span class="hljs-comment">//直接后继</span><br>&#125;DulNode,*DuLinkList;<br></code></pre></td></tr></table></figure><p>双向链表也可以有循环表。此时链表中有两个环。</p><p>在双向链表中，有些操作仅需涉及一个方向的指针，则它们的算法描述和线性链表的操作相同，但是插入、删除有很大的不同。双向链表中需要同时修改两个方向的指针——插入结点时需要修改四个指针，删除结点时需要修改两个指针，它们的时间复杂度都是 O(n)。</p><h4 id="双向链表的插入"><a href="#双向链表的插入" class="headerlink" title="双向链表的插入"></a>双向链表的插入</h4><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231610748.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">ListInsert_Dul</span><span class="hljs-params">(DulLinkList &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!(p=<span class="hljs-built_in">GetElem_DuL</span>(L,i)))  <span class="hljs-comment">//在L中确定第i个元素的位置指针</span><br>        <span class="hljs-keyword">return</span> ERROR;          <span class="hljs-comment">//p为NULL时，第i个元素不存在</span><br>    s = <span class="hljs-keyword">new</span> DulNode;           <span class="hljs-comment">//生成新结点*s</span><br>    s-&gt;data = e;               <span class="hljs-comment">//将结点*s数据域置为e</span><br>    s-&gt;prior = p-&gt;prior;       <span class="hljs-comment">//将结点*s插入L中</span><br>    p-&gt;prior-&gt;next = s;<br>    s-&gt;next = p;<br>    p-&gt;prior = s;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="双向链表的删除"><a href="#双向链表的删除" class="headerlink" title="双向链表的删除"></a>双向链表的删除</h4><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231611429.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(DULinkList &amp;L,<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!(p=<span class="hljs-built_in">GetElem_DuL</span>(L,i)))   <span class="hljs-comment">//在L中确定第i个元素的位置指针p</span><br>        <span class="hljs-keyword">return</span> ERROR;           <span class="hljs-comment">//p为NULL时，第i个元素不存在</span><br>    p-&gt;prior-&gt;next = p-&gt;next;   <span class="hljs-comment">//修改被删结点的前驱结点的后继指针</span><br>    p-&gt;next-&gt;prior = p-&gt;prior;  <span class="hljs-comment">//修改被删结点的后继结点的前驱指针</span><br>    <span class="hljs-keyword">delete</span> p;                   <span class="hljs-comment">//释放被删结点的空间</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="顺序表和链表比较"><a href="#顺序表和链表比较" class="headerlink" title="顺序表和链表比较"></a>顺序表和链表比较</h2><h3 id="空间性能比较"><a href="#空间性能比较" class="headerlink" title="空间性能比较"></a>空间性能比较</h3><h4 id="存储空间的分配"><a href="#存储空间的分配" class="headerlink" title="存储空间的分配"></a>存储空间的分配</h4><p>顺序表：存储空间必须预先分配，元素扩充受到限制，容易造成存储空间浪费或空间溢出。</p><p>链表：不需要预先分配空间，元素个数没有限制。</p><p><strong>结论</strong>：当线性表的长度变化较大，难以预估存储规模时，使用链表作为存储结构更好。</p><h4 id="存储密度的大小"><a href="#存储密度的大小" class="headerlink" title="存储密度的大小"></a>存储密度的大小</h4><p>链表每个结点要额外设置指针域，存储密度小于 1，而顺序表的存储密度为 1。</p><p><strong>结论</strong>：当线性表的长度变化不大，易于实先确定大小时，为了节约存储空间，使用顺序表作为存储结构更好。</p><h3 id="时间性能的比较"><a href="#时间性能的比较" class="headerlink" title="时间性能的比较"></a>时间性能的比较</h3><h4 id="存取元素的效率"><a href="#存取元素的效率" class="headerlink" title="存取元素的效率"></a>存取元素的效率</h4><p>顺序表：由数组实现，随机存取结构，时间复杂度为 O(1)，取值操作效率高。</p><p>链表：顺序存取结构，只能遍历链表，时间复杂度为 O(n)，取值操作效率低。</p><p><strong>结论</strong>：如果主要操作和元素位置紧密相关，很少插入或删除时，使用顺序表作为存储结构更好。</p><h4 id="插入和删除效率"><a href="#插入和删除效率" class="headerlink" title="插入和删除效率"></a>插入和删除效率</h4><p>链表：确定插入或删除位置后，插入或删除操作无需移动位置，只需要修改指针，时间复杂度为 O(1)。</p><p>顺序表：插入或删除平均要移动一半的结点，时间复杂度为 O(n)。</p><p><strong>结论</strong>：频繁进行插入或删除操作的线性表，使用链表作为存储结构更好。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>线性表的逻辑结构特性是指数据元素之间存在着线性关系，在计算机中表示这种关系的两类不同的存储结构是顺序存储结构（顺序表） 和链式存储结构（链表）。</li><li>对千顺序表，元素存储的相邻位置反映出其逻辑上的线性关系，可借助数组来表示。给定数组的下标， 便可以存取相应的元素，可称为随机存取结构。而对千链表，是依靠指针来反映其线性逻辑关系的，链表结点的存取都要从头指针开始，顺链而行，所以不属千随机存取结构，可称之为顺序存取结构。不同的特点使得顺序表和链表有不同的适用情况。<br><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231612782.png"></li><li>对于链表，除了常用的单链表外，在本章还讨论了两种不同形式的链表， 即循环链表和双向链表，它们有不同的应用场合。<br><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231612999.png"></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>引入</title>
    <link href="/2025/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BC%95%E5%85%A5/"/>
    <url>/2025/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BC%95%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h2><h3 id="数据、数据元素、数据项和数据对象"><a href="#数据、数据元素、数据项和数据对象" class="headerlink" title="数据、数据元素、数据项和数据对象"></a>数据、数据元素、数据项和数据对象</h3><ul><li>数据：客观事物的符号表示，所有能输入到计算机中并被计算机程序处理的符号的总称</li><li>数据元素：数据的基本单位，在计算机中通常作为一个整体进行考虑和处理</li><li>数据项：组成数据元素的、有独立含义的、不可分割的最小单位</li><li>数据对象：性质相同的数据元素的集合，数据的一个子集</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合</p><p>数据结构包含逻辑结构和存储结构</p><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>数据的逻辑结构是从逻辑关系上描述数据，与数据的存储无关，是独立于计算机的，可以看作是从具体问题抽象出来的数学模型</p><p>逻辑结构包含两个要素：</p><ul><li>数据元素：数据的基本单位，在计算机中通常作为一个整体进行考虑和处理</li><li>关系：数据元素间的逻辑关系</li></ul><p>关系通常由四种基本结构：</p><ul><li>集合结构</li><li>线性结构</li><li>树结构</li><li>图结构</li></ul><p>其中集合结构、树结构和图结构都属于非线性结构</p><p>线性结构包括线性表、栈和队列、字符串、数组、广义表。</p><p>非线性结构包括树和二叉树、有向图和无向图</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231604037.png"></p><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>数据的存储结构为数据对象在计算机中的存储表示。也被称作物理结构。</p><p>把数据对象存储到计算机时，既要存储各数据元素的数据，又要存储数据元素之间的逻辑关系。</p><p>数据元素在计算机中有两种基本的存储结构：</p><ul><li>顺序存储结构</li><li>链式存储结构</li></ul><h5 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h5><p>顺序结构结组元素在存储器中的相对位置来表示数据元素之间的逻辑关系，通常借助程序设计语言的数组类型来描述。需要一整块连续的存储空间</p><h5 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h5><p>链式存储结构不需要一整块存储空间，但为了表示每个节点之间的关系，需要给每个节点附加指针字段，用于存放后继元素的存储地址，通常结组程序设计语言的指针类型来描述</p><h3 id="数据类型和抽象数据类型"><a href="#数据类型和抽象数据类型" class="headerlink" title="数据类型和抽象数据类型"></a>数据类型和抽象数据类型</h3><p>数据类型：一个值的集合和定义在这个值集上的一组操作的总称</p><p>抽象数据类型（ADT）： 由用户定义的、表示应用问题的数学模型以及定义在这个模型上的一组操作的总称。</p><p>抽象数据类型具体包括三部分：</p><ul><li>数据对象</li><li>数据对象上关系的集合</li><li>对数据对象的基本操作的集合</li></ul><p>抽象数据类型的定义格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">ADT 抽象数据类型名&#123;<br>  数据对象:&lt;数据对象的定义&gt;<br>  数据关系:&lt;数据关系的定义&gt;<br>  基本操作:&lt;基本操作的定义&gt;<br>&#125;ADT 抽象数据类型名<br></code></pre></td></tr></table></figure><p>数据对象和数据关系的定义采用数学符号和自然语言描述，基本操作的定义格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">基本操作名(参数表)<br>  初始条件:&lt;初始条件描述&gt;<br>  操作结果:&lt;操作结果描述&gt;<br></code></pre></td></tr></table></figure><p><code>基本操作</code>有两种参数：</p><ul><li>赋值参数：只为操作提供输入值</li><li>引用参数：以”&amp;”打头，除可提供输入值外，还将返回操作结果</li></ul><p><code>初始条件</code>描述了操作执行之前数据结构和参数应满足的条件。<code>操作结果</code>说明了正常完成之后，数据结构的变化状况和应返回的结果</p><h2 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h2><h3 id="算法的定义及特性"><a href="#算法的定义及特性" class="headerlink" title="算法的定义及特性"></a>算法的定义及特性</h3><p>算法是为了解决某类问题而规定的一个有限长的操作序列</p><p>算法必须具有以下五个特性：</p><ul><li>有穷性</li><li>确定性</li><li>可行性</li><li>输入</li><li>输出</li></ul><h3 id="评价算法优劣的基本标准"><a href="#评价算法优劣的基本标准" class="headerlink" title="评价算法优劣的基本标准"></a>评价算法优劣的基本标准</h3><ul><li>正确性</li><li>可读性</li><li>健壮性</li><li>高效性</li></ul><h3 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h3><p>衡量算法效率的方法主要分为两类：</p><ul><li>事后统计法</li><li>事前分析估算法</li></ul><p>通常采用事前分析估算法</p><h4 id="问题规模和语句频度"><a href="#问题规模和语句频度" class="headerlink" title="问题规模和语句频度"></a>问题规模和语句频度</h4><p>问题规模是影响算法时间代价的最主要因素，是问题大小的本质表示，一般用整数 n 表示。</p><p>语句频度是一条语句的重复执行次数，语句的执行时间是该条语句的重复执行次数和执行一次所需要的时间</p><p>算法分析并非精确统计算法实际执行所需要的时间，而是针对算法中语句的执行次数做出估计，从中得到算法执行时间的信息</p><h4 id="算法的时间复杂度定义"><a href="#算法的时间复杂度定义" class="headerlink" title="算法的时间复杂度定义"></a>算法的时间复杂度定义</h4><p>为了客观地反映一个算法的执行时间，可以只用算法中的“基本语句”的执行次数来度量算法的工作量。“基本语句”指的是算法中重复执行次数和算法执行时间成正比的语句，它对算法运行时间的贡献最大。算法中基本语句重复执行的次数是问题规模 n 的某个函数 f(n)，用“O”表示数量级，算法的时间量度记作<code>T(n)=O(f(n))</code>。算法执行时间的增长率与 f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度。</p><p>定理：若<img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231605589.png">是一个 m 次多项式，则 T(n)&#x3D;O(n<sup>m</sup>)</p><p>以上定理说明，在计算算法时间复杂度时，可以忽略所有低次幂和最高次幂的系数</p><h4 id="最好、最坏和平均时间复杂度"><a href="#最好、最坏和平均时间复杂度" class="headerlink" title="最好、最坏和平均时间复杂度"></a>最好、最坏和平均时间复杂度</h4><p>最好时间复杂度：算法计算量可能达到的最小值</p><p>最坏时间复杂度：算法计算量可能达到的最大值</p><p>平均时间复杂度：算法在所有可能情况下，按照输入实例以等概率出现时，算法计算量的加权平均值</p><p>通常只讨论算法在最坏情况下的时间复杂度</p><h3 id="算法的空间复杂度"><a href="#算法的空间复杂度" class="headerlink" title="算法的空间复杂度"></a>算法的空间复杂度</h3><p>渐近空间复杂度简称空间复杂度，是问题规模 n 的函数，记作<img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231605856.png"></p><p>讨论算法的空间复杂度只需要分析该算法在实现时所需要的辅助空间就可以了。有的算法需要占用临时的工作单元数与问题规模 n 有关，例如归并排序算法。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>数据结构是一门研究非数值计算程序设计中操作对象， 以及这些对象之间的关系和操作的学科</li><li>数据结构包括两个方面的内容：数据的逻辑结构和存储结构。同一逻辑结构采用不同的存储方法， 可以得到不同的存储结构</li></ul><ol><li>逻辑结构是从具体问题抽象出来的数学模型，从逻辑关系上描述数据，它与数据的存储无关。根据数据元素之间关系的不同特性， 通常有四类基本逻辑结构：集合结构、线性结构、树形结构和图状结构</li><li>存储结构是逻辑结构在计算机中的存储表示，有两类存储结构：顺序存储结构和链式存储结构</li></ol><ul><li>抽象数据类型是指由用户定义的、表示应用问题的数学模型， 以及定义在这个模型上的一组操作的总称， 具体包括三部分：数据对象、数据对象上关系的集合， 以及对数据对象的基本操作的集合</li><li>算法是为了解决某类问题而规定的一个有限长的操作序列。算法具有五个特性：有穷性、确定性、可行性、输入和输出。一个算法的优劣应该从以下四方面来评价：正确性、可读性、健壮性和高效性</li><li>算法分析的两个主要方面是分析算法的时间复杂度和空间复杂度， 以考察算法的时间和空间效率。一般情况下， 鉴于运算空间较为充足， 故将算法的时间复杂度作为分析的重点。算法执行时间的数量级称为算法的渐近时间复杂度，<code>T(n) = 0(f(n))</code>, 它表示随着问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同， 简称时间复杂度</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>blog 上传出现 github css js 404 问题解决方案（自用）</title>
    <link href="/2025/03/23/blog-%E4%B8%8A%E4%BC%A0%E5%87%BA%E7%8E%B0-github-css-js-404-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E8%87%AA%E7%94%A8%EF%BC%89/"/>
    <url>/2025/03/23/blog-%E4%B8%8A%E4%BC%A0%E5%87%BA%E7%8E%B0-github-css-js-404-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E8%87%AA%E7%94%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本地运行 blog 正常，但是上传到 GitHub 之后出现问题，例如：</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231433008.png"></p><p>排查问题发现是 github css js 404 的问题，有以下解决方案：</p><ol><li><p>查看 URL 是否正确<br><code>url: https://nice2006.github.io/</code><br><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231434265.png"></p></li><li><p>在博客的 source 目录里加入.nojekyll 文件，然后更改 Hexo 的_config.yml 加入以下配置：<br><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231435407.png"><br>还不行的话在.deploy_git 里加入.nojekyll 文件。</p></li><li><p>在博客 source 目录下创建 assets&#x2F;static 文件夹，将<a href="https://github.com/dr34m-cn/hexo/tree/master/source/assets/static">此链接</a>下的内容全部拷贝到 assets&#x2F;static 文件夹中。<br>将_config.fluid.yml 文件中的 static_prefix 部分改成如下这样：</p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">static_prefix:</span><br>  <span class="hljs-comment"># 内部静态</span><br>  <span class="hljs-comment"># Internal static</span><br>  <span class="hljs-attr">internal_js:</span> <span class="hljs-string">/js</span><br>  <span class="hljs-attr">internal_css:</span> <span class="hljs-string">/css</span><br>  <span class="hljs-attr">internal_img:</span> <span class="hljs-string">/img</span><br><br>  <span class="hljs-attr">anchor:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">github_markdown:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">jquery:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">bootstrap:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">prismjs:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">tocbot:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">typed:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">fancybox:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">nprogress:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">mathjax:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">katex:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">busuanzi:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">clipboard:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">mermaid:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">valine:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">waline:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">gitalk:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">disqusjs:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">twikoo:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">discuss:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">hint:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">moment:</span> <span class="hljs-string">/assets/static/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂物</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设置文章信息（自用）</title>
    <link href="/2025/03/23/%E8%AE%BE%E7%BD%AE%E6%96%87%E7%AB%A0%E4%BF%A1%E6%81%AF%EF%BC%88%E8%87%AA%E7%94%A8%EF%BC%89/"/>
    <url>/2025/03/23/%E8%AE%BE%E7%BD%AE%E6%96%87%E7%AB%A0%E4%BF%A1%E6%81%AF%EF%BC%88%E8%87%AA%E7%94%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>Front-matter 是文件开头的 YAML 或 JSON 代码块，用于配置写作设置。 以 YAML 格式书写时，Front-matter 以三个破折号结束；以 JSON 格式书写时，Front-matter 以三个分号结束。</p><h3 id="设置-默认值"><a href="#设置-默认值" class="headerlink" title="设置 &amp; 默认值"></a>设置 &amp; 默认值</h3><table><thead><tr><th align="left">设置</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td><td align="left"><a href="https://hexo.io/docs/configuration#Writing"><code>config.default_layout</code></a></td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td><td align="left">文章的文件名</td></tr><tr><td align="left"><code>date</code></td><td align="left">建立日期</td><td align="left">文件建立日期</td></tr><tr><td align="left"><code>updated</code></td><td align="left">更新日期</td><td align="left">文件更新日期</td></tr><tr><td align="left"><code>comments</code></td><td align="left">开启文章的评论功能</td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>tags</code></td><td align="left">标签（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>categories</code></td><td align="left">分类（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">覆盖文章的永久链接. 永久链接应该以 <code>/</code> 或 <code>.html</code> 结尾</td><td align="left"><code>null</code></td></tr><tr><td align="left"><code>excerpt</code></td><td align="left">纯文本的页面摘要。 使用 <a href="https://hexo.io/zh-cn/docs/tag-plugins#%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%92%8C%E6%88%AA%E6%96%AD">该插件</a> 来格式化文本</td><td align="left"></td></tr><tr><td align="left"><code>disableNunjucks</code></td><td align="left">启用时禁用 Nunjucks 标签 <code>&#123;&#123; &#125;&#125;</code>&#x2F;<code>&#123;% %&#125;</code> 和 <a href="https://hexo.io/zh-cn/docs/tag-plugins">标签插件</a> 的渲染功能</td><td align="left">false</td></tr><tr><td align="left"><code>lang</code></td><td align="left">设置语言以覆盖 <a href="https://hexo.io/zh-cn/docs/internationalization#%E8%B7%AF%E5%BE%84">自动检测</a></td><td align="left">继承自 <code>_config.yml</code></td></tr><tr><td align="left"><code>published</code></td><td align="left">文章是否发布</td><td align="left">对于 <code>_posts</code> 下的文章为 <code>true</code>，对于 <code>_draft</code> 下的文章为 <code>false</code></td></tr></tbody></table><h2 id="隐藏文章"><a href="#隐藏文章" class="headerlink" title="隐藏文章"></a>隐藏文章</h2><p>如果想把某些文章隐藏，不在首页和其他归档分类页里展示，可以在文章开头 front-matter (opens new window)中配置 <code>hide: true</code> 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><span class="hljs-attr">hide:</span> <span class="hljs-literal">true</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><h2 id="归档文章"><a href="#归档文章" class="headerlink" title="归档文章"></a>归档文章</h2><p>如果只是想让文章在首页隐藏，但仍需要在归档分类页里展示，可以在文章开头 front-matter (opens new window)中配置 <code>archive: true</code> 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><span class="hljs-attr">archive:</span> <span class="hljs-literal">true</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂物</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
