<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MFC笔记</title>
    <link href="/2025/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/MFC%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/MFC%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>MFC是一种面向对象，用于开发windows应用程序的框架，突出特点是封装了大部分windows API，便于开发人员使用。</p><p>MFC程序的运行过程分为以下四步：</p><ol><li><p>利用全局应用程序对象 theApp 启动应用程序。</p></li><li><p>调用全局应用程序对象的构造函数，从而调用基类（CWinApp）的构造函数，完成应用程序的一些初始化工作，并将应用程序对象的指针保存起来。</p></li><li><p>进入WinMain函数。在 AfxWinMain 函数中获取子类的指针，利用指针实现上述的三个函数，从而完成窗口的创建注册等工作。</p></li><li><p>进入消息循环，一直到 WM_QUIT。</p></li></ol><p>因为其封装了大部分windows API，逆向起来也复杂了不少。</p><p>MFC 框架软件主要就是一堆 button，主要逆向也是 check button。</p><p>对于 MFC 逆向，我们主要需要知道的是，当我们执行某个操作（点击某个按钮）的时候，程序会执行什么处理函数。在 MFC 中，程序是使用消息机制来实现操作响应的，这个是消息映射表的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AFX_MSGMAP</span>&#123;<br>    AFX_MSGMAP * pBaseMessageMap;<br>    AFX_MSGMAP_ENTRY * lpEntries;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AFX_MSGMAP_ENTRY</span>&#123;<br>    UINT nMessage;    <span class="hljs-comment">//Windows Message</span><br>    UINT nCode        <span class="hljs-comment">//Control code or WM_NOTIFY code</span><br>    UINT nID;         <span class="hljs-comment">//control ID (or 0 for windows messages)</span><br>    UINT nLastID;     <span class="hljs-comment">//used for entries specifying a range of control id&#x27;s</span><br>    UINT nSig;        <span class="hljs-comment">//signature type(action) or pointer to message </span><br>    AFX_PMSG pfn;     <span class="hljs-comment">//routine to call (or specical value)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>AFX_MSGMAP_ENTRY</code> 中的最后一个成员 <code>AFX_PMSG</code> 是一个函数指针，指向当前控件绑定的函数。</p><p>同时 <code>nID</code> 成员描述的是当前控件的 ID，利用这个 ID 就可以确定我们寻找的控件。</p><p><code>AFX_MSGMAP</code> 结构体会记录一个指向 <code>AFX_MSGMAP_ENTRY</code> 的指针 <code>lpEntries</code> 。</p><p>由此，可以通过以下思路查找空间的注册函数：</p><ol><li>找到 <code>AFX_MSGMAP</code> 。</li><li>找到控件 ID。</li></ol><p>最关键的就是查找控件 ID。</p><p><code>AFX_MSGMAP</code> 存在于 .rdata 段，而 .rdata 段一般有 RTTI、虚函数表与 AFX_MSGMAP，所以 MSG_MAP 数据结构特征相对容易分辨，可以通过编写一个脚本找到。</p><p>存在一个 <code>GetMessageMap</code> 函数，可以获得 <code>AFX_MSGMAP</code>。而一般 <code>GetMessageMap</code> 在编译器自动生成的代码中会被调用，所以我们可以通过查找 <code>GetMessageMap</code> 调用者来完成对 <code>GetMessageMap</code> 的定位。</p><p>值得一提的是 <code>pBaseMessageMap</code> 指向的地址是 <code>GetMessageMap</code> 的地址。<code>GetMessageMap</code> 函数的作用是将 <code>AFX_MSGMAP</code> 的地址静态生成。</p><ol><li>搜索的起始地址从.rdata段的起始地址开始，以4为倍数增加。</li><li>起始地址+4保存的DWORD（<code>AFX_MSGMAP-&gt;lpEntries</code>）等于起始地址+8（第一个<code>AFX_MSGMAP_ENTRY</code>）。</li><li>根据定义，<code>AFX_MSGMAP_ENTYR</code> 以全 0 结束，可以作为判定结束条件。</li></ol><p>以下是别人写的 IDC 脚本查找可能满足条件的 <code>AFX_MSGMAP</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;idc.idc&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-title function_">NotEndAddr</span><span class="hljs-params">(pAddr)</span>&#123;<br> <span class="hljs-keyword">auto</span> i=<span class="hljs-number">0</span>;<br> <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;<br>  <span class="hljs-keyword">if</span> (Dword(i*<span class="hljs-number">4</span>+pAddr)!=<span class="hljs-number">0</span>)<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">//not end</span><br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">//reach the end</span><br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-title function_">isMsgMap</span><span class="hljs-params">(checkAddr,startVa,endVa)</span>&#123;<br> <span class="hljs-keyword">auto</span> tmp1=Dword(checkAddr);<br> <span class="hljs-keyword">auto</span> tmp2=Dword(checkAddr+<span class="hljs-number">4</span>);<br><br> <span class="hljs-keyword">auto</span> pAddr=checkAddr+<span class="hljs-number">8</span>;<br> <span class="hljs-keyword">if</span> (tmp2==checkAddr+<span class="hljs-number">8</span>)&#123;<br><br>  <span class="hljs-keyword">while</span>(NotEndAddr(pAddr))&#123;<br>   <span class="hljs-keyword">if</span>(Dword(pAddr+<span class="hljs-number">20</span>)&lt;startVa||Dword(pAddr+<span class="hljs-number">20</span>)&gt;endVa)&#123;<br><span class="hljs-comment">//    Message(&quot;Invalid Addr at %0x.\n&quot;,pAddr);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>   &#125;<br><br>   pAddr=pAddr+<span class="hljs-number">24</span>;  <br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br> <span class="hljs-keyword">auto</span> startRdataVa=<span class="hljs-number">0x0044E880</span>;   <span class="hljs-comment">//the start addr of .rdata</span><br> <span class="hljs-keyword">auto</span> size=<span class="hljs-number">0x0000DAA8</span>;     <span class="hljs-comment">//the size of .rdata</span><br><br> <span class="hljs-keyword">auto</span> startValidVa=<span class="hljs-number">0x00400000</span>;   <span class="hljs-comment">//check the addr is valid or not</span><br> <span class="hljs-keyword">auto</span> endValidVa=<span class="hljs-number">0x0046A000</span>;<br><br> <span class="hljs-keyword">auto</span> i=<span class="hljs-number">0</span>;<br> <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;size;i=i+<span class="hljs-number">4</span>)&#123;<br>  <span class="hljs-keyword">if</span>(isMsgMap(i+startRdataVa,startValidVa,endValidVa))&#123;<br>   Message(<span class="hljs-string">&quot;Found Possible MessageMap at %0x.\n&quot;</span>,i+startRdataVa);<br>  &#125;<br> &#125;  <br> Message(<span class="hljs-string">&quot;Finish searching.\n&quot;</span>);<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（若将脚本用于不同程序，建议修改startRdataVa，size，startValidVa以及endValidVa四项参数）</p><p>一般生成的可能地址非常少，可以通过以下三个依据手动过滤：</p><ul><li><code>AFX_MSGMAP–&gt;pBaseMessageMap</code> 是 <code>GetMessageMap</code>（封装函数，非常短，只返回 <code>AFX_MSGMAP</code> 地址）。</li><li>其中一定有不为 0 的元素。</li><li>其中一定存在你所查找的控件 ID（ <code>AFX_MSGMAP_ENTRY–&gt;nID</code> ），而且是全部 ID。</li></ul><p>还可以查询 <code>GetMessageMap</code> 的调用函数，然后逆向追溯 <code>AFX_MSGMAP</code>。</p><p><code>OnWndMsg</code> 调用了 <code>GetMessageMap</code> ，<code>OnWndMsg</code> 大体逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CWnd::OnWndMsg</span><span class="hljs-params">(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult)</span></span><br><span class="hljs-function"></span>&#123;<br>    LRESULT lResult = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">const</span> AFX_MSGMAP* pMessageMap;<br><br>     <span class="hljs-comment">//取得消息映射结构，GetMessageMap为虚函数，所以实际取的是CmainFrame的消息映射</span><br>    pMessageMap = <span class="hljs-built_in">GetMessageMap</span>();<br><br>    <span class="hljs-comment">// 查找对应的消息处理函数</span><br>    <span class="hljs-keyword">for</span> (pMessageMap != <span class="hljs-literal">NULL</span>; pMessageMap = pMessageMap-&gt;pBaseMap)<br>        <span class="hljs-keyword">if</span> (message &lt; <span class="hljs-number">0xC000</span>)<br>            <span class="hljs-keyword">if</span> ((lpEntry = <span class="hljs-built_in">AfxFindMessageEntry</span>(pMessageMap-&gt;lpEntries, message, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) != <span class="hljs-literal">NULL</span>)<br>                <span class="hljs-keyword">goto</span> LDispatch;<br>    ... ...<br>LDispatch:<br>    <span class="hljs-comment">//通过联合来匹配正确的函数指针类型</span><br>    <span class="hljs-keyword">union</span> <span class="hljs-title class_">MessageMapFunctions</span> mmf;<br>mmf.pfn = lpEntry-&gt;pfn;<br>……<br></code></pre></td></tr></table></figure><p>因此为了获取 <code>GetMessageMap</code> ，需要先获取 <code>Cwnd::OnWndMsg</code> ，这个函数在 IDA 中同样不会被识别，所以需要找到它的调用函数。同样，有其类似实现 <code>CWnd::WindowProc</code> ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LRESULT <span class="hljs-title">CWnd::WindowProc</span><span class="hljs-params">(UINT message, WPARAM wParam, LPARAM lParam)</span></span><br><span class="hljs-function"></span>&#123;<br>    LRESULT lResult = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">OnWndMsg</span>(message, wParam, lParam, &amp;lResult))<br><br>        lResult = <span class="hljs-built_in">DefWindowProc</span>(message, wParam, lParam);<br><br>    <span class="hljs-keyword">return</span> lResult;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 IDA 中表现大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __thiscall <span class="hljs-title function_">CWnd::WindowProc</span><span class="hljs-params">(CWnd *this, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a2, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a3, <span class="hljs-type">int</span> a4)</span><br>&#123;<br>  CWnd *v4; <span class="hljs-comment">// esi</span><br>  <span class="hljs-type">int</span> v6; <span class="hljs-comment">// [esp+4h] [ebp-4h]</span><br><br>  v6 = <span class="hljs-number">0</span>;<br>  v4 = this;<br>  <span class="hljs-keyword">if</span> ( !(*(<span class="hljs-type">int</span> (__thiscall **)(CWnd *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span> *))(*(_DWORD *)this + <span class="hljs-number">276</span>))(<br>          this,<br>          a2,<br>          a3,<br>          a4,<br>          &amp;v6) )<br>    v6 = (*(<span class="hljs-type">int</span> (__thiscall **)(CWnd *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">int</span>))(*(_DWORD *)v4 + <span class="hljs-number">280</span>))(v4, a2, a3, a4);<br>  <span class="hljs-keyword">return</span> v6;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么显然第一个 if 中嵌套的调用就是 <code>Cwnd::OnWndMsg</code>，由于没有识别出来，需要使用 OD 动态跟踪获取地址，然后在 IDA 中静态分析。</p><p>然后进去之后慢慢分析就可以找到 <code>AFX_MSGMAP</code> 结构。</p><p>对于在 IDA 中优化结构，使用的结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AFX_MSGMAP_ENTRY</span></span><br><span class="hljs-class"></span><br><span class="hljs-class">  &#123;</span><br><br>   UINT nMessage;<br><br>   UINT nCode;<br><br>   UINT nID;<br><br>   UINT nLastID;<br><br>   UINT_PTR nSig;<br><br>   <span class="hljs-type">void</span> (*pfn)(<span class="hljs-type">void</span>);<br><br>  &#125;;<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AFX_MSGMAP</span></span><br><span class="hljs-class"></span><br><span class="hljs-class">  &#123;</span><br><br>    <span class="hljs-type">const</span> AFX_MSGMAP *(__stdcall *pfnGetBaseMap)();<br><br>    <span class="hljs-type">const</span> AFX_MSGMAP_ENTRY *lpEntries;<br><br>  &#125;;<br></code></pre></td></tr></table></figure><p>首先IDA上方菜单–&gt;View–&gt;Open Subview–&gt;Local types，进入本地结构定义菜单。</p><p>右键Insert，在弹出的结构窗口中输入上述结构。</p><p>之后翻到最底部，找到上一步定义的两个结构体（一般就是最后两个），选择后右键Synchronize To idb。</p><p>最后回到 IDA-ViewA 窗口，选中需要改变的结构体 Alt+Q 进行结构变换。</p><p>查找控件 ID 的工具有以下几种：</p><ul><li>xspy</li><li>ResourceHacker</li><li>彗星小助手</li></ul><p>下面是一个简单的 MFC 题目：</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504111729452.png"></p><p>题目提示 flag 就在控件之间，那么我们要找标题对应的 flag 和 内容对应的 key。</p><p>我们使用 xspy 工具对其进行分析：</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504111732994.png"></p><p>因为窗口句柄叫做 HWND，首先找到了 flag：000F0D38(944c8d100f82f0c18b682f63e4dbaa207a2f1e72581c2f1b)</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504111733973.png"></p><p>随后发现一个特殊的 OnMsg <code>OnMsg:0464,func= 0x00402170(MFC1.exe+ 0x002170 )</code> 。其特殊性在于仅仅只有它不是以宏的形式出现，是作者自定义消息，并没有 button 等组件，所以无论怎么点击都无法触发效果，并且传入一个特殊数字 0464来触发效果。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504111735789.png"></p><p>那么接下来就是给这个窗口发送一个消息触发 func 函数获取需要的 key：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    HWND h = FindWindowA(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Flag就在控件里&quot;</span>);<br>    <span class="hljs-keyword">if</span> (h)<br>    &#123;<br>        SendMessage(h, <span class="hljs-number">0x0464</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;success&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;failure&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 API FindWindow 获取窗口句柄，SendMessage 发送消息，得到了 key{I am a Des key}：</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504111738776.png"></p><p>最后放进 DES 解密即可：</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504111740510.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>逆向</tag>
      
      <tag>MFC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓逆向——smali语言</title>
    <link href="/2025/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E2%80%94%E2%80%94smali%E8%AF%AD%E8%A8%80/"/>
    <url>/2025/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E2%80%94%E2%80%94smali%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="JVM、Dalvik、ART"><a href="#JVM、Dalvik、ART" class="headerlink" title="JVM、Dalvik、ART"></a>JVM、Dalvik、ART</h2><ul><li>JVM：Java 虚拟机，运行 Java 字节码程序。</li><li>Dalvik：Google 专门为 Android 设计的一个虚拟机，Dalvik 有专属的文件执行格式 dex（Dalvik executable）。</li><li>Art：Dalvik 的升级版，本质上与 Dalvik 没有区别。</li></ul><h2 id="Dalvik-虚拟机"><a href="#Dalvik-虚拟机" class="headerlink" title="Dalvik 虚拟机"></a>Dalvik 虚拟机</h2><p>Dalvik 虚拟机是 Android 平台上的虚拟机，它是专门为 Android 平台设计的虚拟机，用于执行 Android 应用程序的字节码。它有专属的字节码格式 dex，Dalvik 虚拟机的字节码文件是以 .dex 为后缀的文件。Dalvik 虚拟机的字节码文件是通过将 Java 字节码文件转换为 Dalvik 字节码文件生成的，这个过程叫做 dex 编译。</p><h2 id="smali-及其语法"><a href="#smali-及其语法" class="headerlink" title="smali 及其语法"></a>smali 及其语法</h2><p>smali 是 Dalvik 的寄存器语言，是 Dalvik 字节码的文本表示形式，smali 代码是 dex 反编译而来的。</p><p>smali 语言的指令是 Dalvik 字节码的指令，它是一种基于寄存器的指令集，每个指令都是一个操作码和操作数的组合。smali 语言的指令和 Java 语言的指令是一一对应的，通过 smali 语言可以很方便地查看和修改 Dalvik 字节码。我们在反编译 Android 应用程序时，无法直接修改 Java 源码，但可以通过修改 smali 代码来修改 Dalvik 字节码，从而实现对应用程序的修改。</p><p>反编译的时候无法直接修改 Java 代码，而是修改 smali 代码，因此学习 smali 是静态修改的一个前提条件。</p><p><strong>关键字</strong></p><table><thead><tr><th align="left">名称</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">.class</td><td align="left">类名</td></tr><tr><td align="left">.super</td><td align="left">父类名，继承的上级类名名称</td></tr><tr><td align="left">.source</td><td align="left">源名</td></tr><tr><td align="left">.field</td><td align="left">变量</td></tr><tr><td align="left">.method</td><td align="left">方法名</td></tr><tr><td align="left">.register</td><td align="left">寄存器</td></tr><tr><td align="left">.end method</td><td align="left">方法名的结束</td></tr><tr><td align="left">public</td><td align="left">公有</td></tr><tr><td align="left">protected</td><td align="left">半公开，只有同一家人才能用</td></tr><tr><td align="left">private</td><td align="left">私有，只能自己使用</td></tr><tr><td align="left">.parameter</td><td align="left">方法参数</td></tr><tr><td align="left">.prologue</td><td align="left">方法开始</td></tr><tr><td align="left">.line xxx</td><td align="left">位于第xxx行</td></tr></tbody></table><p><strong>数据类型对应</strong></p><table><thead><tr><th align="left">smali类型</th><th align="left">java类型</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">V</td><td align="left">void</td><td align="left">无返回值</td></tr><tr><td align="left">Z</td><td align="left">boolean</td><td align="left">布尔值类型，返回0或1</td></tr><tr><td align="left">B</td><td align="left">byte</td><td align="left">字节类型，返回字节</td></tr><tr><td align="left">S</td><td align="left">short</td><td align="left">短整数类型，返回数字</td></tr><tr><td align="left">C</td><td align="left">char</td><td align="left">字符类型，返回字符</td></tr><tr><td align="left">I</td><td align="left">int</td><td align="left">整数类型，返回数字</td></tr><tr><td align="left">J</td><td align="left">long （64位 需要2个寄存器存储）</td><td align="left">长整数类型，返回数字</td></tr><tr><td align="left">F</td><td align="left">float</td><td align="left">单浮点类型，返回数字</td></tr><tr><td align="left">D</td><td align="left">double （64位 需要2个寄存器存储）</td><td align="left">双浮点类型，返回数字</td></tr><tr><td align="left">string</td><td align="left">String</td><td align="left">文本类型，返回字符串</td></tr><tr><td align="left">Lxxx&#x2F;xxx&#x2F;xxx</td><td align="left">object</td><td align="left">对象类型，返回对象</td></tr></tbody></table><p><strong>常用指令</strong></p><table><thead><tr><th align="left">关键字</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">const</td><td align="left">重写整数属性，真假属性内容，只能是数字类型</td></tr><tr><td align="left">const-string</td><td align="left">重写字符串内容</td></tr><tr><td align="left">const-wide</td><td align="left">重写长整数类型，多用于修改到期时间。</td></tr><tr><td align="left">return</td><td align="left">返回指令</td></tr><tr><td align="left">if-eq</td><td align="left">全称equal(a&#x3D;b)，比较寄存器ab内容，相同则跳</td></tr><tr><td align="left">if-ne</td><td align="left">全称not equal(a!&#x3D;b)，ab内容不相同则跳</td></tr><tr><td align="left">if-eqz</td><td align="left">全称equal zero(a&#x3D;0)，z即是0的标记，a等于0则跳</td></tr><tr><td align="left">if-nez</td><td align="left">全称not equal zero(a!&#x3D;0)，a不等于0则跳</td></tr><tr><td align="left">if-ge</td><td align="left">全称greater equal(a&gt;&#x3D;b)，a大于或等于则跳</td></tr><tr><td align="left">if-le</td><td align="left">全称little equal(a&lt;&#x3D;b)，a小于或等于则跳</td></tr><tr><td align="left">goto</td><td align="left">强制跳到指定位置</td></tr><tr><td align="left">switch</td><td align="left">分支跳转，一般会有多个分支线，并根据指令跳转到适当位置</td></tr><tr><td align="left">iget</td><td align="left">获取寄存器数据</td></tr></tbody></table><p>其余 smali 指令也可以使用 smali 语法工具查询。</p><h2 id="smali-语法实例——VIP-会员绕过"><a href="#smali-语法实例——VIP-会员绕过" class="headerlink" title="smali 语法实例——VIP 会员绕过"></a>smali 语法实例——VIP 会员绕过</h2><p>教程 demo 提示充值大会员：</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504031030257.png"></p><p>在 jadx 中打开程序，查找 “大会员” ，查询到以下结果（有时候搜不出来是因为 UTF-8 编码被转换从 Unicode 编码，要手动转换一下）。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504031032554.png"></p><p>定位到目的 Java 代码，可以看到 if() 判断条件内调用了 isvip() 方法，用来检测是否是大会员。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504031036865.png"></p><p>跟进 isvip()，发现被设置成 false。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504031037792.png"></p><p>但是 jadx 是没法修改 Java 代码的，只能修改 smali 代码。</p><p>我们依照文件名查找 smali 代码：</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504031046223.png"></p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504031047230.png"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20250403104755721.png" alt="image-20250403104755721"></p><p>smali 代码如下：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs smali">//一个私有、静态、不可变的方法   方法名<br><span class="hljs-keyword">.method</span><span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span><span class="hljs-keyword"> final</span> onCreate$lambda-2(<span class="hljs-class">Lkotlin/jvm/internal/Ref$IntRef;</span><span class="hljs-class">Lcom/zj/wuaipojie/ui/ChallengeSecond;</span><span class="hljs-class">Landroid/widget/ImageView;</span><span class="hljs-class">Landroid/widget/ImageView;</span><span class="hljs-class">Landroid/widget/ImageView;</span><span class="hljs-class">Landroid/view/View;</span>)Z //(这里面是方法的参数)这里是方法返回值类型，表示布尔值类型，返回假或真<br><span class="hljs-keyword">    .registers</span> 7  //寄存器数量<br><br><span class="hljs-keyword">    .line</span> 33  //代码所在的行数<br>   <span class="hljs-built_in"> iget </span>p0, p0, <span class="hljs-class">Lkotlin/jvm/internal/Ref$IntRef;</span>-&gt;element:I  //读取p0(第一个参数，参考寄存器知识)中element的值赋值给p0<br><br>   <span class="hljs-built_in"> const/4 </span>p5, 0x1  //p5赋值1<br><br>   <span class="hljs-built_in"> const/16 </span>v0, 0xa //v0赋值10，在16进制里a表示10<br><br>   <span class="hljs-built_in"> if-ge </span>p0, v0,<span class="hljs-keyword"> :cond_15</span>  //判断p0的值是否大于或等于v0的值(即p0的值是否大于或等于10)，如果大于或等于则跳转到:cond_15<br><br><span class="hljs-keyword">    .line</span> 34  //以下是常见的Toast弹窗代码<br>   <span class="hljs-built_in"> check-cast </span>p1, <span class="hljs-class">Landroid/content/Context;</span> //检查Context对象引用<br><br>   <span class="hljs-built_in"> const-string </span>p0, <span class="hljs-string">&quot;请先获取10个硬币哦&quot;</span> //弹窗文本信息，把<span class="hljs-string">&quot;&quot;</span>里的字符串数据赋值给p0<br><br>   <span class="hljs-built_in"> check-cast </span>p0, <span class="hljs-class">Ljava/lang/CharSequence;</span> //检查CharSequence对象引用<br><br>   <span class="hljs-built_in"> invoke-static </span>&#123;p1, p0, p5&#125;, <span class="hljs-class">Landroid/widget/Toast;</span>-&gt;makeText(<span class="hljs-class">Landroid/content/Context;</span><span class="hljs-class">Ljava/lang/CharSequence;</span>I)<span class="hljs-class">Landroid/widget/Toast;</span> <br>    //将弹窗文本、显示时间等信息传给p1<br><br>   <span class="hljs-built_in"> move-result-object </span>p0  //结果传递给p0<br><br>   <span class="hljs-built_in"> invoke-virtual </span>&#123;p0&#125;, <span class="hljs-class">Landroid/widget/Toast;</span>-&gt;show()V  //当看到这个Toast;-&gt;show你就应该反应过来这里是弹窗代码<br><br>   <span class="hljs-built_in"> goto </span>:goto_31  //跳转到:goto_31<br><br>   <span class="hljs-keyword"> :cond_15</span> //跳转的一个地址<br><br>   <span class="hljs-built_in"> invoke-virtual </span>&#123;p1&#125;, <span class="hljs-class">Lcom/zj/wuaipojie/ui/ChallengeSecond;</span>-&gt;isvip()Z  //判断isvip方法的返回值是否为真(即结果是否为1)<br><br>   <span class="hljs-built_in"> move-result </span>p0  //结果赋值给p0<br><br>   <span class="hljs-built_in"> if-eqz </span>p0,<span class="hljs-keyword"> :cond_43</span> //如果结果为0则跳转cond_43地址<br><br>   <span class="hljs-built_in"> const </span>p0, 0x7f0d0018  //在arsc中的id索引，这个值可以进行查询<br><br><span class="hljs-keyword">    .line</span> 37<br>   <span class="hljs-built_in"> invoke-virtual </span>&#123;p2, p0&#125;, <span class="hljs-class">Landroid/widget/ImageView;</span>-&gt;setImageResource(I)V //设置图片资源<br><br>   <span class="hljs-built_in"> const </span>p0, 0x7f0d0008<br><br><span class="hljs-keyword">    .line</span> 38<br>   <span class="hljs-built_in"> invoke-virtual </span>&#123;p3, p0&#125;, <span class="hljs-class">Landroid/widget/ImageView;</span>-&gt;setImageResource(I)V<br><br>   <span class="hljs-built_in"> const </span>p0, 0x7f0d000a<br><br><span class="hljs-keyword">    .line</span> 39<br>   <span class="hljs-built_in"> invoke-virtual </span>&#123;p4, p0&#125;, <span class="hljs-class">Landroid/widget/ImageView;</span>-&gt;setImageResource(I)V<br><br><span class="hljs-keyword">    .line</span> 40<br>   <span class="hljs-built_in"> sget-object </span>p0, <span class="hljs-class">Lcom/zj/wuaipojie/util/SPUtils;</span>-&gt;INSTANCE:<span class="hljs-class">Lcom/zj/wuaipojie/util/SPUtils;</span> <br><br>   <span class="hljs-built_in"> check-cast </span>p1, <span class="hljs-class">Landroid/content/Context;</span><br><br>   <span class="hljs-built_in"> const/4 </span>p2, 0x2 //p2赋值2<br><br>   <span class="hljs-built_in"> const-string </span>p3, <span class="hljs-string">&quot;level&quot;</span> //sp的索引<br><br>   <span class="hljs-built_in"> invoke-virtual </span>&#123;p0, p1, p3, p2&#125;, <span class="hljs-class">Lcom/zj/wuaipojie/util/SPUtils;</span>-&gt;saveInt(<span class="hljs-class">Landroid/content/Context;</span><span class="hljs-class">Ljava/lang/String;</span>I)V //写入数据<br><br>   <span class="hljs-built_in"> goto </span>:goto_50 //跳转地址<br><br>   <span class="hljs-keyword"> :cond_43</span><br><br>   <span class="hljs-built_in"> check-cast </span>p1, <span class="hljs-class">Landroid/content/Context;</span><br><br>   <span class="hljs-built_in"> const-string </span>p0, <span class="hljs-string">&quot;\u8bf7\u5148\u5145\u503c\u5927\u4f1a\u5458\u54e6\uff01&quot;</span> //请先充值大会员哦！<br><br>   <span class="hljs-built_in"> check-cast </span>p0, <span class="hljs-class">Ljava/lang/CharSequence;</span><br><br>   <span class="hljs-built_in"> invoke-static </span>&#123;p1, p0, p5&#125;, <span class="hljs-class">Landroid/widget/Toast;</span>-&gt;makeText(<span class="hljs-class">Landroid/content/Context;</span><span class="hljs-class">Ljava/lang/CharSequence;</span>I)<span class="hljs-class">Landroid/widget/Toast;</span><br><br>   <span class="hljs-built_in"> move-result-object </span>p0<br><br>   <span class="hljs-built_in"> invoke-virtual </span>&#123;p0&#125;, <span class="hljs-class">Landroid/widget/Toast;</span>-&gt;show()V<br><br>   <span class="hljs-keyword"> :goto_50</span><br>   <span class="hljs-built_in"> return </span>p5  //返回p5的值<span class="hljs-keyword"></span><br><span class="hljs-keyword">.end method</span> //方法结束<br><br>//判断是否是大会员的方法<br><span class="hljs-keyword">.method</span><span class="hljs-keyword"> public</span><span class="hljs-keyword"> final</span> isvip()Z<br><span class="hljs-keyword">    .registers</span> 2<br><br>   <span class="hljs-built_in"> const/4 </span>v0, 0x0 //v0赋值0<br><br>   <span class="hljs-built_in"> return </span>v0 //返回v0的值<span class="hljs-keyword"></span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword">.end method</span><br></code></pre></td></tr></table></figure><p>也可以通过窗口 id 进行快速定位。</p><p>打开开发者助手，然后进入程序，进入目标界面，选择 【界面资源分析】</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504031537870.png"></p><p>然后点击目标按钮，获取按钮 ID：</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504031539669.png"></p><p>点击复制，然后进入 MT管理器，进入 class.dex，选择搜索，这里注意选择整数型，并勾选上【十六进制】。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504031541365.png"></p><p>搜完有两个，两个都跟进去看看就知道差不多找到位置了。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504031543056.png"></p><h3 id="修改寄存器的值"><a href="#修改寄存器的值" class="headerlink" title="修改寄存器的值"></a>修改寄存器的值</h3><p>可以看到，isvip 方法默认返回值为0，即不是大会员，我们可以通过修改这个方法的返回值来绕过大会员检测。我们可以将返回值改为1，即是大会员，这样就可以绕过大会员检测了。</p><p>其次我们需要先获取10个硬币，才能点亮一键三连，我们可以通过修改 onCreate$lambda-2 方法中的 <code>if-ge p0, v0, :cond_15</code> 这一行代码，将 v0 的值改为 0，这样就可以绕过硬币检测了。</p><p>接下来就是修改环节，用 MT管理器提取安装包后查看 classes.dex 文件。</p><p>选择 DEX 编辑 PLUS，搜索 isvip，找到对应的方法，将返回值改为1。</p><h3 id="修改判断法"><a href="#修改判断法" class="headerlink" title="修改判断法"></a>修改判断法</h3><p>也可以将 <code>if-ge p0, v0, :cond_15</code> 这一行代码的 <code>if-ge</code> 改成 <code>if-le</code>，然后将判断 isvip 的语句 if-eqz p0, :cond_43 加个 “#” 直接注释掉，这样也可以跳过 VIP 检测。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>逆向</tag>
      
      <tag>安卓逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓逆向——APK文件结构</title>
    <link href="/2025/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E2%80%94%E2%80%94APK%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <url>/2025/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E2%80%94%E2%80%94APK%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="APK-文件结构"><a href="#APK-文件结构" class="headerlink" title="APK 文件结构"></a>APK 文件结构</h2><p>APK 是 Android Package 的缩写，是 Android 平台上的应用程序包文件格式。APK 文件是一个 ZIP 压缩格式的文件，其中包含了应用程序的代码、资源文件和 META-INF 目录等文件。</p><table><thead><tr><th>文件</th><th>注释</th></tr></thead><tbody><tr><td>assets 目录</td><td>存放 APK 的静态资源文件，比如视频、音频、图片等</td></tr><tr><td>lib 目录</td><td>armeabi-v7a 基本通用所有的 Android 设备，arm64-v8a 只适用于 64 位的 Android 设备，x86 常见于 Android 模拟器，其目录下的 .so 文件是 C 或 C++ 编译的动态链接库文件</td></tr><tr><td>META-INF 目录</td><td>保存应用的签名信息，签名信息可以验证 APK 文件的完整性</td></tr><tr><td>res 目录</td><td>res 目录存放资源文件，包括图片、字符串等等</td></tr><tr><td>AndroidManifest.xml 文件</td><td>APK 的应用清单信息，它描述了应用的名字、版本、权限、引用的库文件等等信息</td></tr><tr><td>classes.dex 文件</td><td>classes.dex 是 java 源码编译后生成的 Java 字节码文件，APK 运行的主要逻辑</td></tr><tr><td>resources.arsc 文件</td><td>resources.arsc 是编译后的二进制资源文件，它是一个映射表，映射着资源和 ID，通过 R 文件中的 ID 就可以找到对应的资源</td></tr></tbody></table><h2 id="初识-AndroidManifest-xml"><a href="#初识-AndroidManifest-xml" class="headerlink" title="初识 AndroidManifest.xml"></a>初识 AndroidManifest.xml</h2><p>AndroidManifest.xml 文件是整个应用程序的信息描述文件，定义了应用程序中包含的 Activity，Service，Content provider 和 BroadcastReceiver 组件信息。每个应用程序在根目录下必须包含一个 AndroidManifest.xml 文件，且文件名不能修改。它描述了 package 中 暴露的组件，他们各自的实现类，各种能被处理的数据和启动位置。</p><p>AndroidManifest.xml文件是一个 XML 格式的文件，它的根元素是 manifest 元素，manifest 元素的几个常见属性如下：</p><table><thead><tr><th align="left">属性</th><th align="left">定义</th></tr></thead><tbody><tr><td align="left">versionCode</td><td align="left">版本号，主要用来更新，例如:12</td></tr><tr><td align="left">versionName</td><td align="left">版本名，给用户看的，例如:1.2</td></tr><tr><td align="left">package</td><td align="left">包名，每个应用程序都有一个唯一的包名</td></tr><tr><td align="left">uses-permission android:name&#x3D;””</td><td align="left">应用权限，例如：android.permission.INTERNET 代表网络权限</td></tr><tr><td align="left">android:label&#x3D;”@string&#x2F;app_name”</td><td align="left">应用名称</td></tr><tr><td align="left">android:icon&#x3D;”@mipmap&#x2F;ic_launcher”</td><td align="left">应用图标路径</td></tr><tr><td align="left">android:debuggable&#x3D;”true”</td><td align="left">应用是否开启 debug 权限</td></tr><tr><td align="left">application</td><td align="left">应用程序的信息，包括应用程序的名称、图标、主题、启动 Activity 等信息</td></tr><tr><td align="left">activity</td><td align="left">应用程序的 Activity 组件，每个 Activity 都需要在 AndroidManifest.xml 文件中进行声明</td></tr><tr><td align="left">intent-filter</td><td align="left">Activity 的过滤器，用于指定 Activity 的启动方式。</td></tr></tbody></table><p>每个应用程序在根目录下必须包含一个AndroidManifest.xml文件，且文件名不能修改。它描述了<br>package中暴露的组件，他们各自的实现类，各种能被处理的数据和启动位置。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504011639290.png"></p><h2 id="简单-Android-逆向举例——多开"><a href="#简单-Android-逆向举例——多开" class="headerlink" title="简单 Android 逆向举例——多开"></a>简单 Android 逆向举例——多开</h2><p>双开软件是一种可以在同一台手机上安装多个同一应用的软件，比如可以在同一台手机上安装两个微信，两个QQ等。双开有多种实现方式：</p><ul><li>多开分身：通过修改应用程序的包名和签名，实现多个应用程序的安装。</li><li>修改Framework：对于有系统修改权限的厂商，可以修改 Framework 来实现双开的目的。</li><li>Xposed框架：通过 Xposed 框架实现双开，通过 Hook 应用程序的启动逻辑，实现多个应用程序的安装。</li><li>虚拟化技术：通过虚拟化技术实现双开，虚拟 Framework 层、虚拟文件系统、模拟 Android 对组件的管理、虚拟应用进程管理等一整套虚拟技术，将 APK 复制一份到虚拟空间中运行。</li><li>以插件机制运行：利用反射替换，动态代（过）（滤）理，hook了系统的大部分与system—server进程通讯的函数，以此作为“欺上瞒下”的目的，欺骗系统“以为”只有一个apk在运行，瞒过插件让其“认为”自己已经安装。例如：VirtualApp</li></ul><p>由于其他几种方式比较复杂，涉及到系统层面的修改，这里主要介绍第一种方式：多开分身。多开分身的原理是通过修改应用程序的包名和签名，实现多个应用程序的安装。这里用 NP管理器简单示，具体步骤如下：先在菜单栏选择安装包提取，然后选择要提取的应用：</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504011645852.png"></p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504011646395.png"></p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504011647789.png"></p><p>提取完成后点击定位，即可定位到目的地址：</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504011648187.png"></p><p>然后选择目标文件，选择功能：</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504011649188.png"></p><p>选择 APK 共存，此时会在当前目录下生成一个新的 APK 文件，这个 APK 文件就是多开分身的 APK 文件：</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504011650123.png"></p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504031019224.png"></p><p>点击生成的安装包，可以看到生成的 APK 文件的包名和签名状态已经修改了，这样就实现了多开分身。这时候就可以点击安装了。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504031020589.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>逆向</tag>
      
      <tag>安卓逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>z3</title>
    <link href="/2025/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/z3/"/>
    <url>/2025/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/z3/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/Z3Prover/z3">Z3 solver</a> 是由微软开发的 <strong>可满足性模理论求解器</strong>（<strong>Satisfiability Modulo Theory solver</strong>， 即 <code>SMT solver</code>），用于检查逻辑表达式的可满足性，并可以找到一组约束中的其中一个可行解（无法找出所有的可行解）。</p></blockquote><h2 id="Z3-安装"><a href="#Z3-安装" class="headerlink" title="Z3 安装"></a>Z3 安装</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">pip install z3<span class="hljs-literal">-solver</span><br></code></pre></td></tr></table></figure><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="变量表示"><a href="#变量表示" class="headerlink" title="变量表示"></a>变量表示</h3><p>一阶命题逻辑公式由项（变量或常量）与扩展布尔结构组成，在 <code>z3</code> 当中我们可以通过如下方式创建变量实例。</p><ul><li><p>整型（integer，长度不限）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> z3<br>x = z3.Int(name = <span class="hljs-string">&#x27;x&#x27;</span>)  <span class="hljs-comment"># x is an integer</span><br></code></pre></td></tr></table></figure></li><li><p>实数类型（real number，长度不限）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">y = z3.Real(name = <span class="hljs-string">&#x27;y&#x27;</span>)  <span class="hljs-comment"># y is a real number</span><br></code></pre></td></tr></table></figure><p>可以用来创建有理数。</p><p>一次性创建多变量用如下表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">x, y, z = z3.Reals(<span class="hljs-string">&#x27;x y z&#x27;</span>)<br></code></pre></td></tr></table></figure><p>需要注意的是，<code>Real</code> 后面加了 <code>s</code> ，其余同理。</p></li><li><p>位向量（bit vector，长度需在创建时指定）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">z = z3.BitVec(name = <span class="hljs-string">&#x27;z&#x27;</span>, bv = <span class="hljs-number">32</span>)  <span class="hljs-comment"># z is a 32-bit vector</span><br></code></pre></td></tr></table></figure></li><li><p>布尔类型（bool）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p = z3.Bool(name = <span class="hljs-string">&#x27;p&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><p>整型和实数类型变量之间可以互相进行转换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">z3.ToReal(x)<br>z3.ToInt(y)<br></code></pre></td></tr></table></figure><h4 id="位向量"><a href="#位向量" class="headerlink" title="位向量"></a>位向量</h4><p>现代 CPU 和主流编程语言使用固定大小的位向量进行算术运算。 机器算术在 Z3 中可用作位向量。 它们实现无符号和有符号二补数算术的精确语义。</p><p>例如以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">x = BitVec(<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-number">16</span>)<br>y = BitVec(<span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(x + <span class="hljs-number">2</span>)<br><span class="hljs-comment"># Internal representation</span><br><span class="hljs-built_in">print</span>((x + <span class="hljs-number">2</span>).sexpr())<br><br><span class="hljs-comment"># -1 is equal to 65535 for 16-bit integers</span><br><span class="hljs-built_in">print</span>(simplify(x + y - <span class="hljs-number">1</span>))<br><br><span class="hljs-comment"># Creating bit-vector constants</span><br>a = BitVecVal(-<span class="hljs-number">1</span>, <span class="hljs-number">16</span>)<br>b = BitVecVal(<span class="hljs-number">65535</span>, <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(simplify(a == b))<br><br>a = BitVecVal(-<span class="hljs-number">1</span>, <span class="hljs-number">32</span>)<br>b = BitVecVal(<span class="hljs-number">65535</span>, <span class="hljs-number">32</span>)<br><span class="hljs-comment"># -1 is not equal to 65535 for 32-bit integers</span><br><span class="hljs-built_in">print</span>(simplify(a == b))<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">x + <span class="hljs-number">2</span><br>(bvadd x <span class="hljs-comment">#x0002)</span><br><span class="hljs-number">65535</span> + x + y<br>True<br>False<br></code></pre></td></tr></table></figure><p>其中 <code>sexpr()</code> 是 Z3 求解器 API 中的一个方法，用于将 Z3 表达式转换为 S-表达式（Symbolic Expression） 的字符串形式，方便开发者查看 Z3 内部如何表示复杂的表达式或约束。</p><p>在 Z3Py 中，运算符 <code>&lt;</code> ，<code>&lt;=</code> ，<code>&gt;</code> ，<code>&gt; =</code> ，<code>/</code> ，<code>％</code> 和 <code>&gt;&gt;</code>对应于有符号的版本。 相应的，无符号运算符是 <code>ULT</code> ，<code>ULE</code> ，<code>UGT</code> ，<code>UGE</code> ，<code>UDiv</code> ，<code>URem</code> 和 <code>LShR</code> 。</p><p>算子 <code>&gt;&gt;</code> 是算术右移，而 <code>&lt;&lt;</code> 是左移。 位移符号是左结合的。</p><h3 id="常量表示"><a href="#常量表示" class="headerlink" title="常量表示"></a>常量表示</h3><p>除了 python 原有的常量数据类型外，也可以使用 <code>z3</code> 自带的常量类型参与运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">z3.IntVal(val = <span class="hljs-number">123456</span>)<br>z3.RealVal(val = <span class="hljs-number">123456</span>)<br>z3.BitVecVal(val = <span class="hljs-number">123456</span>, bv = <span class="hljs-number">32</span>)<br></code></pre></td></tr></table></figure><p>需要注意的是，有可能会发生自动截断，尤其是向量表示。</p><p>创建有理数也可以使用 <code>Q(num, den)</code> 函数，其中 <code>num</code> 是分子，<code>den</code> 是分母。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">rational_num = Q(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p><code>set_option</code> 用于配置 Z3 环境。 它用于设置全局配置选项，如结果如何显示，<code>rational_to_decimal</code> 用来控制是按照分数显示还是按照十进制近似显示。<code>rational_to_decimal = False</code> 时按照分数显示，<code>True</code> 时按照十进制显示。</p><p>需要注意的是：不要用 <code>num/den</code> 来表示有理数，这个在 python 中表示一个整数，例如 1&#x2F;3 会被视作 0。</p><h3 id="化简器"><a href="#化简器" class="headerlink" title="化简器"></a>化简器</h3><p>Z3 公式&#x2F;表达式简化器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x = Int(<span class="hljs-string">&#x27;x&#x27;</span>)<br>y = Int(<span class="hljs-string">&#x27;y&#x27;</span>)<br><span class="hljs-built_in">print</span> simplify(x + y + <span class="hljs-number">2</span>*x + <span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span> simplify(x &lt; y + x + <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span> simplify(And(x + <span class="hljs-number">1</span> &gt;= <span class="hljs-number">3</span>, x**<span class="hljs-number">2</span> + x**<span class="hljs-number">2</span> + y**<span class="hljs-number">2</span> + <span class="hljs-number">2</span> &gt;= <span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">3</span> + <span class="hljs-number">3</span>*x + y<br>Not(y &lt;= <span class="hljs-literal">-2</span>)<br>And(x &gt;= <span class="hljs-number">2</span>, <span class="hljs-number">2</span>*x**<span class="hljs-number">2</span> + y**<span class="hljs-number">2</span> &gt;= <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>使用 <code>rith-lhs</code> 参数让 z3 在输出化简表达式时所有参数都放在左手边，右手边只留下常数 constant。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x, y = Reals(<span class="hljs-string">&#x27;x y&#x27;</span>)<br><span class="hljs-built_in">print</span>(simplify(x == y + <span class="hljs-number">2</span>, arith_lhs=<span class="hljs-literal">True</span>))<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">x + <span class="hljs-literal">-1</span>*y == <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="表达式分析"><a href="#表达式分析" class="headerlink" title="表达式分析"></a>表达式分析</h3><p>z3 提供遍历表达式的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">x = Int(<span class="hljs-string">&#x27;x&#x27;</span>)<br>y = Int(<span class="hljs-string">&#x27;y&#x27;</span>)<br>n = x + y &gt;= <span class="hljs-number">3</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;num args: &quot;</span>, n.num_args())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;children: &quot;</span>, n.children())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1st child:&quot;</span>, n.arg(<span class="hljs-number">0</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;2nd child:&quot;</span>, n.arg(<span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;operator: &quot;</span>, n.decl())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;op name:  &quot;</span>, n.decl().name())<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">num args:  <span class="hljs-number">2</span><br>children:  [<span class="hljs-type">x</span> + <span class="hljs-type">y</span>, <span class="hljs-number">3</span>]<br><span class="hljs-number">1</span>st child: x + y<br><span class="hljs-number">2</span>nd child: <span class="hljs-number">3</span><br>operator:  &gt;=<br>op name:   &gt;=<br></code></pre></td></tr></table></figure><h3 id="精度设置"><a href="#精度设置" class="headerlink" title="精度设置"></a>精度设置</h3><p>选项 <code>set_option(precision = 30)</code> 设置显示结果时使用的小数位数，<code>precision</code> 用于控制显示位数。 这个 <code>？</code> 标记在 <code>1.2599210498？</code> 中表示输出被截断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">x = Real(<span class="hljs-string">&#x27;x&#x27;</span>)<br>y = Real(<span class="hljs-string">&#x27;y&#x27;</span>)<br>solve(x**<span class="hljs-number">2</span> + y**<span class="hljs-number">2</span> == <span class="hljs-number">3</span>, x**<span class="hljs-number">3</span> == <span class="hljs-number">2</span>)<br><br>set_option(precision=<span class="hljs-number">30</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Solving, and displaying result with 30 decimal places&quot;</span>)<br>solve(x**<span class="hljs-number">2</span> + y**<span class="hljs-number">2</span> == <span class="hljs-number">3</span>, x**<span class="hljs-number">3</span> == <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">[<span class="hljs-type">x</span> = <span class="hljs-number">1.2599210498</span>?, <span class="hljs-type">y</span> = -<span class="hljs-number">1.1885280594</span>?]<br>Solving, and displaying result with <span class="hljs-number">30</span> decimal places<br>[<span class="hljs-type">x</span> = <span class="hljs-number">1.259921049894873164767210607278</span>?,<br> <span class="hljs-type">y</span> = -<span class="hljs-number">1.188528059421316533710369365015</span>?]<br></code></pre></td></tr></table></figure><h3 id="求解器"><a href="#求解器" class="headerlink" title="求解器"></a>求解器</h3><p>在使用 <code>z3</code> 进行约束求解之前，先得获得一个 <strong>求解器</strong> 类实例，本质其实就是一组约束的集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s = z3.Solver()<br></code></pre></td></tr></table></figure><h3 id="添加约束"><a href="#添加约束" class="headerlink" title="添加约束"></a>添加约束</h3><p>可以通过求解器的 <code>add()</code> 方法为指定求解器添加约束条件，约束条件可以直接通过 <code>z3</code> 变量组成的式子进行表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s.add(x * <span class="hljs-number">5</span> == <span class="hljs-number">10</span>)<br>s.add(y * <span class="hljs-number">1</span>/<span class="hljs-number">2</span> == x)<br></code></pre></td></tr></table></figure><p>对于布尔类型的式子而言，可以使用 <code>z3</code> 内置的 <code>Add()</code> 、<code>Or()</code> 、<code>Not()</code> 、<code>Implies()</code> 等方法进行布尔逻辑运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s.add(z3.Implies(p, q))  <span class="hljs-comment"># 如果 P 为真，则 Q 必须为真；否则 Q 可为真或假</span><br>s.add(r == z3.Not(q))<br>s.add(z3.Or(z3.Not(p), r))<br></code></pre></td></tr></table></figure><p><code>Implies</code> 是一个 <strong>逻辑蕴含</strong> 运算符，表示“如果…那么…”的条件关系。它的作用类似于数学或逻辑中的 <strong>→</strong> 符号，用于构建条件约束。</p><h3 id="约束求解"><a href="#约束求解" class="headerlink" title="约束求解"></a>约束求解</h3><p>在添加约束条件后，可以使用 <code>check()</code> 方法检查约束是否是可满足的。</p><ul><li><code>z3.sat</code> ：约束可满足</li><li><code>z3.unsat</code> ：约束无法被满足</li></ul><p>例如：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">&gt;&gt;&gt; z3.check()<br>sat<br></code></pre></td></tr></table></figure><p>如果约束可以被满足，则我们可以使用 <code>model()</code> 方法获取到一组解。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">&gt;&gt;&gt; s.model()<br>[<span class="hljs-type">q</span> = <span class="hljs-type">True</span>, <span class="hljs-type">p</span> = <span class="hljs-type">False</span>, <span class="hljs-type">x</span> = <span class="hljs-number">2</span>, <span class="hljs-type">y</span> = <span class="hljs-number">4</span>, <span class="hljs-type">r</span> = <span class="hljs-type">False</span>]<br></code></pre></td></tr></table></figure><p>对于约束条件比较少的情况，也可以不创建求解器，直接使用 <code>solve()</code> 方法进行求解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">z3.solve(z3.Implies(p, q), r == z3.Not(q), z3.Or(z3.Not(p), r))<br></code></pre></td></tr></table></figure><p>需要注意的是：z3 只能求解非线形多项式约束，例如解决不了 <code>2**x ==3</code> 这个方程，因为 <code>2**x</code> 不是一个多项式</p><h3 id="POP-PUSH-断言堆栈"><a href="#POP-PUSH-断言堆栈" class="headerlink" title="POP&#x2F;PUSH 断言堆栈"></a>POP&#x2F;PUSH 断言堆栈</h3><p>在一些应用中，我们想要探索几个共享几个约束的类似问题。我们可以使用 <code>push</code> 和 <code>pop</code> 命令来做到这一点。每个求解器维护一堆断言。命令 <code>push</code> 通过保存当前堆栈大小来创建一个新的作用域。命令 <code>pop</code> 删除它与匹配推送之间执行的任何断言。</p><p>例如以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> *<br><br>x = Int(<span class="hljs-string">&#x27;x&#x27;</span>)<br>y = Int(<span class="hljs-string">&#x27;y&#x27;</span>)<br><br>s = Solver()<br><span class="hljs-built_in">print</span>(s)<br><br>s.add(x &gt; <span class="hljs-number">10</span>, y == x + <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(s)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Solving constraints in the solver s ...&quot;</span>)<br><span class="hljs-built_in">print</span>(s.check())<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Create a new scope...&quot;</span>)<br>s.push()<br>s.add(y &lt; <span class="hljs-number">11</span>)<br><span class="hljs-built_in">print</span>(s)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Solving updated set of constraints...&quot;</span>)<br><span class="hljs-built_in">print</span>(s.check())<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Restoring state...&quot;</span>)<br>s.pop()<br><span class="hljs-built_in">print</span>(s)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Solving restored set of constraints...&quot;</span>)<br><span class="hljs-built_in">print</span>(s.check())<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">[]<br>[<span class="hljs-type">x</span> &gt; <span class="hljs-number">10</span>, <span class="hljs-type">y</span> == <span class="hljs-type">x</span> + <span class="hljs-number">2</span>]<br>Solving constraints <span class="hljs-keyword">in</span> the solver s ...<br>sat<br>Create a new scope...<br>[<span class="hljs-type">x</span> &gt; <span class="hljs-number">10</span>, <span class="hljs-type">y</span> == <span class="hljs-type">x</span> + <span class="hljs-number">2</span>, <span class="hljs-type">y</span> &lt; <span class="hljs-number">11</span>]<br>Solving updated <span class="hljs-built_in">set</span> of constraints...<br>unsat<br>Restoring state...<br>[<span class="hljs-type">x</span> &gt; <span class="hljs-number">10</span>, <span class="hljs-type">y</span> == <span class="hljs-type">x</span> + <span class="hljs-number">2</span>]<br>Solving restored <span class="hljs-built_in">set</span> of constraints...<br>sat<br></code></pre></td></tr></table></figure><h3 id="常见与比较运算符有关的函数"><a href="#常见与比较运算符有关的函数" class="headerlink" title="常见与比较运算符有关的函数"></a>常见与比较运算符有关的函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">UGT(x, y)       <span class="hljs-comment"># 大于（Greater Than）</span><br>ULT(x, y)       <span class="hljs-comment"># 小于（Less Than）</span><br>UGE(x, y)       <span class="hljs-comment"># 大于等于（Greater Than or Equal To）</span><br>ULE(x, y)       <span class="hljs-comment"># 小于等于（Less Than or Equal To）</span><br>EQ(x, y)        <span class="hljs-comment"># 等于（Equal To）</span><br>DISTINCT(x, y)  <span class="hljs-comment"># 不等于（Distinct）</span><br></code></pre></td></tr></table></figure><p>这些函数与标准的关系运算符（如 <code>&gt;</code> , <code>&lt;</code> , <code>&gt;=</code> , <code>&lt;=</code> , <code>==</code> , <code>!=</code> ）等效，只是提供了一些不同的表示方式。认识一下，防止真碰到了又不认识。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>例如 IDA 分析有如下函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">sub_400770</span><span class="hljs-params">(_DWORD *a1)</span><br>&#123;<br>  __int64 result; <span class="hljs-comment">// rax</span><br><br>  <span class="hljs-keyword">if</span> ( a1[<span class="hljs-number">2</span>] - a1[<span class="hljs-number">3</span>] == <span class="hljs-number">2225223423LL</span><br>    &amp;&amp; a1[<span class="hljs-number">3</span>] + a1[<span class="hljs-number">4</span>] == <span class="hljs-number">4201428739LL</span><br>    &amp;&amp; a1[<span class="hljs-number">2</span>] - a1[<span class="hljs-number">4</span>] == <span class="hljs-number">1121399208LL</span><br>    &amp;&amp; *a1 == <span class="hljs-number">-548868226</span><br>    &amp;&amp; a1[<span class="hljs-number">5</span>] == <span class="hljs-number">-2064448480</span><br>    &amp;&amp; a1[<span class="hljs-number">1</span>] == <span class="hljs-number">550153460</span> )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;good!&quot;</span>);<br>    result = <span class="hljs-number">1LL</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Wrong!&quot;</span>);<br>    result = <span class="hljs-number">0LL</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>z3</code> 库进行求解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> z3<br><br>x = [<span class="hljs-number">0</span>] * <span class="hljs-number">6</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):                        <span class="hljs-comment"># 这个循环的作用是将 x[i] 这个整体当作变量名使用</span><br>    x[i] = z3.Int(<span class="hljs-string">&#x27;x[&#x27;</span> + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;]&#x27;</span>)<br><br>s = z3.Solver()<br>s.add(x[<span class="hljs-number">0</span>] == <span class="hljs-number">0xDF48EF7E</span>)<br>s.add(x[<span class="hljs-number">5</span>] == <span class="hljs-number">0x84F30420</span>)<br>s.add(x[<span class="hljs-number">1</span>] == <span class="hljs-number">0x20CAACF4</span>)<br>s.add(x[<span class="hljs-number">2</span>]-x[<span class="hljs-number">3</span>] == <span class="hljs-number">0x84A236FF</span>)<br>s.add(x[<span class="hljs-number">3</span>]+x[<span class="hljs-number">4</span>] == <span class="hljs-number">0xFA6CB703</span>)<br>s.add(x[<span class="hljs-number">2</span>]-x[<span class="hljs-number">4</span>] == <span class="hljs-number">0x42D731A8</span>)<br><br><span class="hljs-keyword">if</span> s.check() == z3.sat:<br>    <span class="hljs-built_in">print</span>(s.model())<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;NO SOLUTION!&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>逆向</tag>
      
      <tag>Z3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDAPython</title>
    <link href="/2025/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/IDAPython/"/>
    <url>/2025/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/IDAPython/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>IDAPython 核心有如下 3 个 python 模块：</p><ol><li>idc 模块负责提供 IDC 中所有的函数功能。</li><li>idautils 提供大量的实用函数，其中许多函数可生成各种数据库相关对象(如函数或交叉引用)的 python 列表。</li><li>idaapi 允许使用者通过类的形式，访问更多底层的数据 。</li></ol><p>需要注意的是 IDAPython 会自动导入 idc 和 idautils 模块，idaapi 模块需要自己手工导入。</p><p>为了使用的清晰性，建议在开头都进行手工的 import 这三个模块。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>由于 idaPython 的升级，导致一些函数给改没了，文档中不再对之前版本的函数进行说明，但是这些函数都用新函数进行了实现，新旧关系的对应在文件 <code>idc_bc695.py</code> ，可以进行对照说明。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>在 IDAPython 中，地址作为 <code>ea</code> 被使用，地址可以通过几个不同的函数手动访问。</p><h3 id="获取当前地址"><a href="#获取当前地址" class="headerlink" title="获取当前地址"></a>获取当前地址</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.here()<br>idc.get_screen_ea()<br></code></pre></td></tr></table></figure><h3 id="获取当前地址空间的最小地址和最大地址"><a href="#获取当前地址空间的最小地址和最大地址" class="headerlink" title="获取当前地址空间的最小地址和最大地址"></a>获取当前地址空间的最小地址和最大地址</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.get_inf_attr(INF_MIN_EA)<br>idc.get_inf_attr(INF_MAX_EA)<br></code></pre></td></tr></table></figure><p>或者是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ida_ida.inf_get_min_ea()<br>ida_ida.inf_get_max_ea()<br></code></pre></td></tr></table></figure><h3 id="获取指令信息"><a href="#获取指令信息" class="headerlink" title="获取指令信息"></a>获取指令信息</h3><p>对于任意一个指令，都可以通过函数获取信息</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">.text:0040162F  mov cx, eax<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Python&gt;idc.get_segm_name(here())<br><span class="hljs-string">&#x27;.text&#x27;</span><br>Python&gt;idc.GetDisasm(here())<br><span class="hljs-string">&#x27;mov     ecx, eax&#x27;</span><br>Python&gt;idc.print_insn_mnem(here())<br><span class="hljs-string">&#x27;mov&#x27;</span><br>Python&gt;idc.print_operand(here(),<span class="hljs-number">0</span>)<br><span class="hljs-string">&#x27;ecx&#x27;</span><br>Python&gt;idc.print_operand(here(),<span class="hljs-number">1</span>)<br><span class="hljs-string">&#x27;eax&#x27;</span><br>Python&gt;idaapi.BADADDR<br><span class="hljs-number">0</span>xffffffffffffffff<br></code></pre></td></tr></table></figure><h4 id="获取段名的字符串"><a href="#获取段名的字符串" class="headerlink" title="获取段名的字符串"></a>获取段名的字符串</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.get_segm_name(ea)<br></code></pre></td></tr></table></figure><h4 id="打印反汇编的字符串"><a href="#打印反汇编的字符串" class="headerlink" title="打印反汇编的字符串"></a>打印反汇编的字符串</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.GetDisasm(ea)<br>idc.generate_disasm_line(ea, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h4 id="获取助记符或者指令名称"><a href="#获取助记符或者指令名称" class="headerlink" title="获取助记符或者指令名称"></a>获取助记符或者指令名称</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.print_insn_mnem(ea)<br></code></pre></td></tr></table></figure><h4 id="获取操作数的助记符"><a href="#获取操作数的助记符" class="headerlink" title="获取操作数的助记符"></a>获取操作数的助记符</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.print_operand(ea, n)<br></code></pre></td></tr></table></figure><p>第一个参数是地址，第二个 <code>long n</code> 是操作数索引（第一个操作数是 0，第二个是 1）。</p><h4 id="检验有效地址"><a href="#检验有效地址" class="headerlink" title="检验有效地址"></a>检验有效地址</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idaapi.BADADDR<br></code></pre></td></tr></table></figure><h2 id="Segments（段）"><a href="#Segments（段）" class="headerlink" title="Segments（段）"></a>Segments（段）</h2><h3 id="遍历所有段的指令"><a href="#遍历所有段的指令" class="headerlink" title="遍历所有段的指令"></a>遍历所有段的指令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> idc<br><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> idaapi<br><br><span class="hljs-keyword">for</span> seg <span class="hljs-keyword">in</span> idautils.Segments():<br>    <span class="hljs-built_in">print</span>(idc.get_segm_name(seg),idc.get_segm_start(seg),idc.get_segm_end(seg))<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">.text <span class="hljs-number">4198400</span> <span class="hljs-number">4399104</span><br>.rdata <span class="hljs-number">4399104</span> <span class="hljs-number">4411392</span><br>.data <span class="hljs-number">4411392</span> <span class="hljs-number">4440064</span><br>.idata <span class="hljs-number">4440064</span> <span class="hljs-number">4444160</span><br>.<span class="hljs-number">2333</span> <span class="hljs-number">4452352</span> <span class="hljs-number">4456448</span><br></code></pre></td></tr></table></figure><h3 id="遍历段"><a href="#遍历段" class="headerlink" title="遍历段"></a>遍历段</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idautils.Segments()<br></code></pre></td></tr></table></figure><p>有这个函数就可以通过 for 循环遍历所有段，列表中每一个项都是段的起始地址。地址可以被用来获取名称。</p><h3 id="获取开始和结束的段"><a href="#获取开始和结束的段" class="headerlink" title="获取开始和结束的段"></a>获取开始和结束的段</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.get_segm_start(ea)<br>idc.get_segm_end(ea)<br></code></pre></td></tr></table></figure><h3 id="查找下一个段"><a href="#查找下一个段" class="headerlink" title="查找下一个段"></a>查找下一个段</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.get_next_seg(ea)<br></code></pre></td></tr></table></figure><h3 id="通过名称获取一个段的起始地址"><a href="#通过名称获取一个段的起始地址" class="headerlink" title="通过名称获取一个段的起始地址"></a>通过名称获取一个段的起始地址</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.get_segm_by_name(segname)<br></code></pre></td></tr></table></figure><h2 id="Functions（函数）"><a href="#Functions（函数）" class="headerlink" title="Functions（函数）"></a>Functions（函数）</h2><h3 id="遍历所有函数"><a href="#遍历所有函数" class="headerlink" title="遍历所有函数"></a>遍历所有函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> func <span class="hljs-keyword">in</span> idautils.Functions():<br>    <span class="hljs-built_in">print</span>(func,idc.get_func_name(func))<br></code></pre></td></tr></table></figure><p>返回一个已知函数列表：<code>idautils.Functions()</code> 这个列表包含起始地址的每一个函数。这个函数可在传递的参数范围内搜索，格式如下：<code>idautils.Funtions(start_addr, end_addr)</code> 。</p><p>找到一个函数的名称：<code>idc.GetFunctionName(ea)</code> ，ea 可以是函数边界的任何地址。</p><h3 id="遍历函数"><a href="#遍历函数" class="headerlink" title="遍历函数"></a>遍历函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idautils.Functions()<br></code></pre></td></tr></table></figure><p>这个函数返回一个保存已知函数首地址的数组，此函数也可以用来查找在指定地址范围的函数列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idautils.Funtions(start_addr, end_addr)<br></code></pre></td></tr></table></figure><h3 id="获取函数名"><a href="#获取函数名" class="headerlink" title="获取函数名"></a>获取函数名</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.GetFunctionName(ea)<br></code></pre></td></tr></table></figure><p><code>ea</code> 可以是处于函数中的任何地址</p><h3 id="获取-binary-中识别的函数个数"><a href="#获取-binary-中识别的函数个数" class="headerlink" title="获取 binary 中识别的函数个数"></a>获取 binary 中识别的函数个数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idaapi.get_func_qty()<br></code></pre></td></tr></table></figure><h3 id="获取第一个函数对象"><a href="#获取第一个函数对象" class="headerlink" title="获取第一个函数对象"></a>获取第一个函数对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idaapi.getn_func(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="获取函数的边界信息"><a href="#获取函数的边界信息" class="headerlink" title="获取函数的边界信息"></a>获取函数的边界信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idaapi.get_func(ea)<br></code></pre></td></tr></table></figure><h3 id="获取-ea-地址的前后函数"><a href="#获取-ea-地址的前后函数" class="headerlink" title="获取 ea 地址的前后函数"></a>获取 ea 地址的前后函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.get_next_func(ea)<br>idc.get_prev_func(ea)<br></code></pre></td></tr></table></figure><p>ea 的值需要在被分析的函数地址之内。</p><p>在枚举函数的时候，只有 IDA 将这段代码标记为函数的时候才行，不然会在枚举的过程中被跳过。</p><p>还可以使用如下两个 api 来获取函数的边界地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.get_func_attr(here(), FUNCATTR_START)<br>idc.get_func_attr(here(), FUNCATTR_END)<br></code></pre></td></tr></table></figure><p><code>get_func_attr()</code> 的第二个参数有如下值：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">FUNCATTR_START = 0 # function start address<br>FUNCATTR_END = 4 # function end address<br>FUNCATTR_FLAGS = 8 # function flags<br>FUNCATTR_FRAME = 10 # function frame id<br>FUNCATTR_FRSIZE = 14 # size of local variables<br>FUNCATTR_FRREGS = 18 # size of saved registers area<br>FUNCATTR_ARGSIZE = 20 # number of bytes purged from the stack<br>FUNCATTR_FPD = 24 # frame pointer delta<br>FUNCATTR_COLOR = 28 # function color code<br>FUNCATTR_OWNER = 10 # chunk owner (valid only for tail chunks)<br>FUNCATTR_REFQTY = 14 # number of chunk parents (valid only for tail chunks)<br></code></pre></td></tr></table></figure><h3 id="利用函数名获取一个函数的地址"><a href="#利用函数名获取一个函数的地址" class="headerlink" title="利用函数名获取一个函数的地址"></a>利用函数名获取一个函数的地址</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.get_name_ea_simple(func_name)<br></code></pre></td></tr></table></figure><h3 id="遍历函数的所有指令"><a href="#遍历函数的所有指令" class="headerlink" title="遍历函数的所有指令"></a>遍历函数的所有指令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> idc<br><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> idaapi<br><br>start = idc.get_func_attr(here(),FUNCATTR_START)<br>end = idc.get_func_attr(here(), FUNCATTR_END)<br><br>curr_addr = start<br><br><span class="hljs-keyword">while</span> curr_addr &lt;= end:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(curr_addr),idc.GetDisasm(curr_addr))<br>    curr_addr = idc.next_head(curr_addr,end)<br></code></pre></td></tr></table></figure><h3 id="返回某范围内指令的地址"><a href="#返回某范围内指令的地址" class="headerlink" title="返回某范围内指令的地址"></a>返回某范围内指令的地址</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.next_head(curr_addr,end)<br></code></pre></td></tr></table></figure><p>这个函数返回处于 <code>curr_addr</code> 和 <code>end</code> 之间的下一条指令的地址，如果没有指令则返回 <code>idc.BADADDR</code> 。</p><p>这种方法的一个缺陷是它依赖于指令被包含在函数开始和结束的边界内。打个比方说，函数内有个 jmp 指令，它跳转到比这个函数结束地址还要高的地址中去，意思是这个函数的所有指令可能并不是线性的，它可能会通过 jmp 跳出函数边界（起始地址和结束地址），但其实这段指令仍是属于这个函数的，那么我们使用上述的方法就不能够遍历到该函数要执行的所有指令。这种跳转在代码混淆中非常的常见，所以说我们最好还是使用 <code>idautils.FuncItems(ea)</code> 来循环函数内的指令。</p><h3 id="获取某指令上一条指令的地址"><a href="#获取某指令上一条指令的地址" class="headerlink" title="获取某指令上一条指令的地址"></a>获取某指令上一条指令的地址</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.prev_head(ea)<br></code></pre></td></tr></table></figure><h3 id="获取函数的详细信息"><a href="#获取函数的详细信息" class="headerlink" title="获取函数的详细信息"></a>获取函数的详细信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">GetFrame</span>(<span class="hljs-params">ea</span>): <span class="hljs-keyword">return</span> get_func_attr(ea, FUNCATTR_FRAME)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">GetFrameLvarSize</span>(<span class="hljs-params">ea</span>): <span class="hljs-keyword">return</span> get_func_attr(ea, FUNCATTR_FRSIZE)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">GetFrameRegsSize</span>(<span class="hljs-params">ea</span>): <span class="hljs-keyword">return</span> get_func_attr(ea, FUNCATTR_FRREGS)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">GetFrameArgsSize</span>(<span class="hljs-params">ea</span>): <span class="hljs-keyword">return</span> get_func_attr(ea, FUNCATTR_ARGSIZE)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">GetFunctionFlags</span>(<span class="hljs-params">ea</span>): <span class="hljs-keyword">return</span> get_func_attr(ea, FUNCATTR_FLAGS)<br></code></pre></td></tr></table></figure><p>对于最后一个函数，作用是获取函数的标志，各种标志的含义如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs powershell">FUNC_NORET: 这个标志表示某个函数是否有返回值，它本身的值是 <span class="hljs-number">1</span>，下面是一个没有返回值的函数，<br>注意它没有函数的最后并不是 ret 或者 leave 指令<br><br>FUNC_FAR: 这个标志非常少的出现，标志程序是否使用分段内存，它的值为 <span class="hljs-number">2</span>。<br><br>FUNC_USERFAR: 这个标志也非常少见，也很少有文档，HexRays 把它描述为“user has specified far<span class="hljs-literal">-ness</span> of the function”，它的值是 <span class="hljs-number">32</span>.<br><br>FUNC_LIB: 这个表示用于寻找库函数的代码。识别库函数代码是非常有必要的，因为我们在分析的<br>时候一般将其跳过，它的值是 <span class="hljs-number">4</span>。下面的例子展示了如何使用这个标志。<br><br><span class="hljs-keyword">for</span> func <span class="hljs-keyword">in</span> idautils.Functions():<br>    flags = idc.get_func_attr(func, FUNCATTR_FLAGS)<br><br>    <span class="hljs-keyword">if</span> flags &amp; FUNC_LIB:<br>        print(hex(func), <span class="hljs-string">&quot;FUNC_LIB&quot;</span>,get_func_name(func))<br><br>FUNC_STATIC: 这个标志作用在于识别该函数在编译的是否是一个静态函数。在 c 语言中静态函数被默<br>认为是全局的。如果作者把这个函数定义为静态函数，那么这个函数在只能被本文件中的函<br>数访问。利用静态函数的判定我们可以更好的理解源代码的结构。<br><br>FUNC_FRAME: 这个标志表示函数是否使用了 <span class="hljs-built_in">ebp</span> 寄存器（帧指针），使用 <span class="hljs-built_in">ebp</span> 寄存器的函数通常有如<br>下的语法设定，目的是为了保存栈帧。<br><br>.text:<span class="hljs-number">00404</span>C90                 push    <span class="hljs-built_in">ebp</span><br>.text:<span class="hljs-number">00404</span>C91                 mov     <span class="hljs-built_in">ebp</span>, esp<br>.text:<span class="hljs-number">00404</span>C96                 sub     esp, <span class="hljs-number">65</span>Ch<br><br>FUNC_BOTTOMBP: 和 FUNC_FRAME 一样，该标志用于跟踪帧指针（<span class="hljs-built_in">ebp</span>）。它作用是识别函数中帧指针是<br>否等于堆栈指针（esp）。<br><br>FUNC_HIDDEN: 带有 FUNC_HIDDEN 标志的函数意味着它们是隐藏的，这个函数需要展开才能查看。如<br>果我们跳转到一个标记为 <span class="hljs-keyword">HIDDEN</span> 的地址的话，它会自动的展开。<br><br>FUNC_THUNK: 表示这个函数是否是一个 thunk 函数，thunk 函数表示的是一个简单的跳转函数。<br><br>.text:<span class="hljs-number">1</span>A710606 Process32Next proc near<br>.text:<span class="hljs-number">1</span>A710606 jmp ds:__imp_Process32Next<br>.text:<span class="hljs-number">1</span>A710606 Process32Next endp<br><br>需要注意的是一个函数可能拥有多个标志的组合。<br></code></pre></td></tr></table></figure><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>如果我们拥有一个函数中的指令地址，我们可以使用 <code>idautils.FuncItems(ea)</code> 来获取该函数中所有指令地址的集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> idc<br><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> idaapi<br><br>items = idautils.FuncItems(here())<br><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(item),idc.GetDisasm(item))<br></code></pre></td></tr></table></figure><h3 id="获取目的地址所在函数的所有指令的地址"><a href="#获取目的地址所在函数的所有指令的地址" class="headerlink" title="获取目的地址所在函数的所有指令的地址"></a>获取目的地址所在函数的所有指令的地址</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idautils.FuncItems(ea)<br></code></pre></td></tr></table></figure><p>这个函数实际返回一个迭代器类型但是被强转成一个 list。</p><p>以下是一个非常有用的例子：</p><p>有时候我们会逆向一个加壳的代码，这时知道代码中哪里进行了动态调用对分析是非常有帮助的。一个动态的调用可能是由 call 或者 jump 加上一个操作数来实现的，比如说 call eax，或者 jmp edi。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> idc<br><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> idaapi<br><br><span class="hljs-comment"># 遍历IDA数据库中所有函数</span><br><span class="hljs-keyword">for</span> func <span class="hljs-keyword">in</span> idautils.Functions():<br>    <span class="hljs-comment"># 获取当前函数的属性标志</span><br>    flags = idc.get_func_attr(func, FUNCATTR_FLAGS)<br><br>    <span class="hljs-comment"># 跳过库函数和thunk函数</span><br>    <span class="hljs-keyword">if</span> flags &amp; FUNC_LIB <span class="hljs-keyword">or</span> flags &amp; FUNC_THUNK:<br>        <span class="hljs-keyword">continue</span><br><br>    <span class="hljs-comment"># 获取函数中的所有指令地址</span><br>    dism_addr = idautils.FuncItems(func)<br><br>    <span class="hljs-comment"># 遍历函数中的每条指令</span><br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> dism_addr:<br>        <span class="hljs-comment"># 获取当前指令的助记符(操作码)</span><br>        m = idc.print_insn_mnem(line)<br><br>        <span class="hljs-comment"># 检查是否是call或jmp指令</span><br>        <span class="hljs-keyword">if</span> m == <span class="hljs-string">&quot;call&quot;</span> <span class="hljs-keyword">or</span> m == <span class="hljs-string">&quot;jmp&quot;</span>:<br>            <span class="hljs-comment"># 获取第一个操作数的类型</span><br>            op = idc.get_operand_type(line, <span class="hljs-number">0</span>)<br><br>            <span class="hljs-comment"># 检查操作数是否是寄存器类型</span><br>            <span class="hljs-keyword">if</span> op == o_reg:<br>                <span class="hljs-comment"># 打印指令地址(十六进制)和反汇编文本</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(line), idc.GetDisasm(line))<br></code></pre></td></tr></table></figure><h3 id="获取操作数类型"><a href="#获取操作数类型" class="headerlink" title="获取操作数类型"></a>获取操作数类型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">get_operand_type(ea,n)<br></code></pre></td></tr></table></figure><p>n &#x3D; 0 表示第一个操作数，n &#x3D; 1 表示第二个操作数。</p><h3 id="获取当前指令的上、下一条指令的地址"><a href="#获取当前指令的上、下一条指令的地址" class="headerlink" title="获取当前指令的上、下一条指令的地址"></a>获取当前指令的上、下一条指令的地址</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.prev_head()<br>idc.next_head()<br></code></pre></td></tr></table></figure><h3 id="获取当前指令的上、下一个指令的地址"><a href="#获取当前指令的上、下一个指令的地址" class="headerlink" title="获取当前指令的上、下一个指令的地址"></a>获取当前指令的上、下一个指令的地址</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.prev_addr()<br>idc.next_addr()<br></code></pre></td></tr></table></figure><h2 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h2><p>操作数在逆向分析中经常被使用，所以说了解所有的操作数类型对逆向分析是非常有帮助的。在前面文中提到我们可以使用 <code>idc.get_operand_type(ea,n)</code> 来获取操作数类型，ea 是一个地址，n 是一个索引。操作数总共有八种不同的类型。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">o_void</span>: 如果指令没有任何操作数，它将返回 <span class="hljs-number">0</span>。<br><br><span class="hljs-attribute">o_reg</span>: 如果操作数是寄存器，则返回这种类型，它的值为 <span class="hljs-number">1</span><br><br><span class="hljs-attribute">o_mem</span>: 如果操作数是直接寻址的内存，那么返回这种类型，它的值是 <span class="hljs-number">2</span>，这种类型对寻找 DATA 的引用非常有帮助。<br><br><span class="hljs-attribute">o_phrase</span>: 如果操作数是利用基址寄存器和变址寄存器的寻址操作的话，那么返回该类型，值为<span class="hljs-number">3</span><br><br><span class="hljs-attribute">o_displ</span>: 如果操作数是利用寄存器和位移的寻址操作的话，返回该类型，值为<span class="hljs-number">4</span>，这在获取结构体中的某个数据是非常常见的。<br><br><span class="hljs-attribute">o_imm</span>: 如果操作数是一个确定的数值的话，那么返回类型，值为 <span class="hljs-number">5</span><br><br><span class="hljs-attribute">o_far</span>: 这种返回类型在 x86 和 x86_64 的逆向中不常见。它用来判断直接访问远端地址的操作数，值为<span class="hljs-number">6</span><br><br><span class="hljs-attribute">o_near</span>: 这种返回类型在 x86 和 x86_64 的逆向中不常见。它用来判断直接访问近端地址的操作数，值为<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h3><p>当我们在逆向一个可执行文件的时候，我们可能会注意到一些代码会不断的重复使用某个偏移量。这种操作感觉上是代码在传递某个结构体给不同的函数使用。接下来的这个例子的目的是创建一个 python 的字典，字典包含了可执行文件中使用的所有偏移量，让偏移量作为字典的 key，而每个 key 对应的 value 存储着所有使用该偏移量的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> idc<br><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> idaapi<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict  <span class="hljs-comment"># 导入defaultdict用于创建字典</span><br><br><span class="hljs-comment"># 创建一个默认值为列表的字典，用于存储位移值和对应地址</span><br>displace = defaultdict(<span class="hljs-built_in">list</span>)<br><br><span class="hljs-comment"># 遍历 IDA 数据库中所有函数</span><br><span class="hljs-keyword">for</span> func <span class="hljs-keyword">in</span> idautils.Functions():<br>    <span class="hljs-comment"># 获取当前函数的属性标志</span><br>    flags = idc.get_func_attr(func, FUNCATTR_FLAGS)<br><br>    <span class="hljs-comment"># 跳过库函数和 thunk 函数，thunk 函数表示的是一个简单的跳转函数。</span><br>    <span class="hljs-keyword">if</span> flags &amp; FUNC_LIB <span class="hljs-keyword">or</span> flags &amp; FUNC_THUNK:<br>        <span class="hljs-keyword">continue</span><br><br>    <span class="hljs-comment"># 获取函数中的所有指令地址</span><br>    dism_addr = idautils.FuncItems(func)<br><br>    <span class="hljs-comment"># 遍历函数中的每条指令</span><br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> dism_addr:<br>        <span class="hljs-comment"># 初始化操作数和索引变量</span><br>        op = <span class="hljs-literal">None</span><br>        index = <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># 创建指令结构体并解码当前指令</span><br>        tmp = idaapi.insn_t()  <span class="hljs-comment"># 创建指令结构体</span><br>        idaapi.decode_insn(tmp, line)  <span class="hljs-comment"># 解码当前指令</span><br><br>        <span class="hljs-comment"># 检查第一个操作数是否是位移类型</span><br>        <span class="hljs-keyword">if</span> tmp.Op1.<span class="hljs-built_in">type</span> == idaapi.o_displ:<br>            op = <span class="hljs-number">1</span>  <span class="hljs-comment"># 标记第一个操作数为位移</span><br><br>        <span class="hljs-comment"># 检查第二个操作数是否是位移类型</span><br>        <span class="hljs-keyword">if</span> tmp.Op2.<span class="hljs-built_in">type</span> == idaapi.o_displ:<br>            op = <span class="hljs-number">2</span>  <span class="hljs-comment"># 标记第二个操作数为位移</span><br><br>        <span class="hljs-comment"># 如果没有找到位移操作数，跳过当前指令</span><br>        <span class="hljs-keyword">if</span> op == <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">continue</span><br><br>        <span class="hljs-comment"># 检查操作数中是否包含 &quot;bp&quot; (基址指针)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;bp&quot;</span> <span class="hljs-keyword">in</span> idc.print_operand(line, <span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;bp&quot;</span> <span class="hljs-keyword">in</span> idc.print_operand(line, <span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># 如果是 bp 相关的位移，进行特殊处理(取反并减1)</span><br>            <span class="hljs-keyword">if</span> op == <span class="hljs-number">1</span>:<br>                index = (~(<span class="hljs-built_in">int</span>(tmp.Op1.addr) - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xFFFFFFFF</span>)<br>            <span class="hljs-keyword">else</span>:<br>                index = (~(<span class="hljs-built_in">int</span>(tmp.Op2.addr) - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xFFFFFFFF</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 普通位移直接取值</span><br>            <span class="hljs-keyword">if</span> op == <span class="hljs-number">1</span>:<br>                index = <span class="hljs-built_in">int</span>(tmp.Op1.addr)<br>            <span class="hljs-keyword">else</span>:<br>                index = <span class="hljs-built_in">int</span>(tmp.Op2.addr)<br><br>        <span class="hljs-comment"># 如果成功提取到索引值，将地址添加到字典中</span><br>        <span class="hljs-keyword">if</span> index:<br>            displace[index].append(<span class="hljs-built_in">hex</span>(line))  <span class="hljs-comment"># 以十六进制格式存储地址</span><br><br><span class="hljs-comment"># 打印所有收集到的位移值和对应地址</span><br><span class="hljs-built_in">print</span>(displace)<br></code></pre></td></tr></table></figure><p><code>idaapi.decode_insn(tmp,line)</code> 是解析指令的另一种底层的方法，但是表示偏移的意思。</p><p>我们已经获取了操作符的字符串表示，那么我们检查操作符中是否包含了 “bp” 字符串，这是一个快速判断操作符的中寄存器是否为 bp，ebp 或者 rbp 的方法。检查 ”bp” 字符串的目的在于确定偏移量是否是一个负数。我们使用 <code>idaapi.cmd.Op1.addr</code> 来获取偏移量，这个方法会返回一个字符串。然后我们把他转换成为一个 <code>integer</code> 类型，如果需要的话把它转换为正数，然后我们把它放进脚本最开始定义的字典 display 中去。这样就完成了我们的操作，之后如果你想要查找使用某个偏移量的所有地址，直接读取就可以了。</p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子 2"></a>例子 2</h3><p>有时候我们在逆向分析一个可执行文件的内存转储的时候，有些操作数就不是一个偏移量了。看如下代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-number">0Ch</span><br><span class="hljs-keyword">push</span> <span class="hljs-number">0BC10B8h</span><br><span class="hljs-keyword">push</span> [<span class="hljs-built_in">esp</span>+<span class="hljs-number">10h</span>+arg_0]<br><span class="hljs-keyword">call</span> <span class="hljs-built_in">ds</span>:_strnicmp<br></code></pre></td></tr></table></figure><p>第二个被 push 的值是一个存在内存中的偏移。如果我们通过右键把这个偏移定义为 data 类型，我们可以看到这个偏移其实是一个字符串，当然完成这个定义操作很简单，但是,有时候这种操作太多了话就需要写一个脚本来自动完成这件事情。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> idc<br><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> idaapi<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-comment"># 获取IDA数据库中程序的最小和最大有效地址范围</span><br><span class="hljs-built_in">min</span> = idc.get_inf_attr(INF_MIN_EA)  <span class="hljs-comment"># 获取程序最小地址</span><br><span class="hljs-built_in">max</span> = idc.get_inf_attr(INF_MAX_EA)  <span class="hljs-comment"># 获取程序最大地址</span><br><br><span class="hljs-comment"># 遍历IDA数据库中所有已知函数</span><br><span class="hljs-keyword">for</span> func <span class="hljs-keyword">in</span> idautils.Functions():<br>    <span class="hljs-comment"># 获取当前函数的属性标志</span><br>    flags = idc.get_func_attr(func, FUNCATTR_FLAGS)<br><br>    <span class="hljs-comment"># 跳过库函数和thunk函数</span><br>    <span class="hljs-keyword">if</span> flags &amp; FUNC_LIB <span class="hljs-keyword">or</span> flags &amp; FUNC_THUNK:<br>        <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 如果是库函数或thunk函数则跳过处理</span><br><br>    <span class="hljs-comment"># 获取当前函数的所有指令地址列表</span><br>    dism_addr = <span class="hljs-built_in">list</span>(idautils.FuncItems(func))<br><br>    <span class="hljs-comment"># 遍历当前函数的每条指令</span><br>    <span class="hljs-keyword">for</span> curr_addr <span class="hljs-keyword">in</span> dism_addr:<br>        <span class="hljs-comment"># 检查第一个操作数是否为立即数地址(类型5)且在有效地址范围内</span><br>        <span class="hljs-keyword">if</span> idc.get_operand_type(curr_addr, <span class="hljs-number">0</span>) == <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> \<br>        (<span class="hljs-built_in">min</span> &lt; idc.get_operand_value(curr_addr,<span class="hljs-number">0</span>) &lt; <span class="hljs-built_in">max</span>):<br>            <span class="hljs-comment"># 将第一个操作数转换为普通偏移量</span><br>            idc.op_plain_offset(curr_addr, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>            <span class="hljs-comment"># 调试用：打印处理过的地址(已注释掉)</span><br>            <span class="hljs-comment"># print(hex(curr_addr))</span><br><br>        <span class="hljs-comment"># 检查第二个操作数是否为立即数地址(类型5)且在有效地址范围内</span><br>        <span class="hljs-keyword">if</span> idc.get_operand_type(curr_addr, <span class="hljs-number">1</span>) == <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> (<span class="hljs-built_in">min</span> &lt; idc.get_operand_value(curr_addr,<span class="hljs-number">1</span>) &lt; <span class="hljs-built_in">max</span>):<br>            <span class="hljs-comment"># 将第二个操作数转换为普通偏移量</span><br>            idc.op_plain_offset(curr_addr, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br>            <span class="hljs-comment"># 调试用：打印处理过的地址(已注释掉)</span><br>            <span class="hljs-comment"># print( hex(curr_addr) )</span><br><br></code></pre></td></tr></table></figure><p><code>idc.get_operand_value(ea,n)</code>获取操作数的值。</p><p><code>idc.op_plain_offset(ea,n,base)</code>,将操作数转换为一个偏移地址，该函数的第一个参数为地址，第二个参数为操作数的索引，第三个参数是基地址，该例子中只需要设置为 0 即可。</p><h2 id="交叉引用（Xrefs）"><a href="#交叉引用（Xrefs）" class="headerlink" title="交叉引用（Xrefs）"></a>交叉引用（Xrefs）</h2><p>能够定位 data 段和 code 段的交叉引用非常重要，交叉引用的重要性在于它能够提供某个确定的数据或者某个函数被调用的位置。举个栗子，如果我们想要知道哪些地址调用了 WriteFile() 函数，我们所要做的就是在导入表中找到 WriteFile() 函数，然后查看其交叉引用即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> idc<br><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> idaapi<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br>addr = idc.get_name_ea_simple(<span class="hljs-string">&quot;StartServiceCtrlDispatcherW&quot;</span>)<br><br><span class="hljs-built_in">print</span>( idc.GetDisasm(addr) )<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> idautils.CodeRefsTo(addr,<span class="hljs-number">0</span>):<br>    <span class="hljs-built_in">print</span>( <span class="hljs-built_in">hex</span>(i),idc.GetDisasm(i) )<br></code></pre></td></tr></table></figure><h3 id="获取-API-函数的地址"><a href="#获取-API-函数的地址" class="headerlink" title="获取 API 函数的地址"></a>获取 API 函数的地址</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.get_name_ea_simple(<span class="hljs-string">&quot;func_name&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="获取-API-的所有交叉引用"><a href="#获取-API-的所有交叉引用" class="headerlink" title="获取 API 的所有交叉引用"></a>获取 API 的所有交叉引用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idautils.CodeRefsTo(ea,flow)<br></code></pre></td></tr></table></figure><p>在这个函数中，ea 参数是我们想要寻找交叉引用的地址，flow 参数是一个 bool 值，它用于指定是否遵循正常的代码流。</p><p>不过需要注意的是，使用这个函数的限制是，动态导入并手动重命名的 API 不会显示为交叉引用。</p><h3 id="获取任意地址所引用的代码"><a href="#获取任意地址所引用的代码" class="headerlink" title="获取任意地址所引用的代码"></a>获取任意地址所引用的代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idautisl.CodeRefsFrom(ea,flow)<br></code></pre></td></tr></table></figure><h3 id="获取任何函数的相关信息"><a href="#获取任何函数的相关信息" class="headerlink" title="获取任何函数的相关信息"></a>获取任何函数的相关信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idautils.Names()<br></code></pre></td></tr></table></figure><p>这个函数返回一个类型为 (ea, str_name) 的元组。</p><h3 id="查找数据的交叉引用"><a href="#查找数据的交叉引用" class="headerlink" title="查找数据的交叉引用"></a>查找数据的交叉引用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">idautils.DataRefsTo(e)<br>idautils.DataRefsFrom(ea)<br></code></pre></td></tr></table></figure><p>idautils.DataRefsTo(e) 函数只有一个参数，它返回该数据地址的所有交叉引用（迭代器）。</p><p>idautils.DataRefsFrom(ea)只携带一个地址作为参数，它返回改、该地址所引用的数据地址。</p><h3 id="获取所有交叉引用地址和调用地址"><a href="#获取所有交叉引用地址和调用地址" class="headerlink" title="获取所有交叉引用地址和调用地址"></a>获取所有交叉引用地址和调用地址</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">idautils.XrefsTo(ea, flags=<span class="hljs-number">0</span>)<br>idautils.XrefsFrom(ea,flags=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>这两种方法更加通用，可以同时实现对查找数据和代码的交叉引用。代价就是多了好多标志位。</p><p>例如以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> idc<br><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> idaapi<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br>addr = here()  <span class="hljs-comment"># 获取当前光标所在位置的地址</span><br><br><span class="hljs-comment"># 打印当前地址的十六进制形式和反汇编指令</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(addr), idc.GetDisasm(addr))<br><br><span class="hljs-comment"># 遍历所有引用到当前地址的交叉引用</span><br><span class="hljs-keyword">for</span> xref <span class="hljs-keyword">in</span> idautils.XrefsTo(addr, <span class="hljs-number">1</span>):<br>    <span class="hljs-comment"># 打印每个交叉引用的类型、类型名称、来源地址、目标地址、是否是代码引用</span><br>    <span class="hljs-built_in">print</span>(xref.<span class="hljs-built_in">type</span>, idautils.XrefTypeName(xref.<span class="hljs-built_in">type</span>), <span class="hljs-built_in">hex</span>(xref.frm), <span class="hljs-built_in">hex</span>(xref.to), xref.iscode)<br></code></pre></td></tr></table></figure><p><code>xref.type</code> 来指明该交叉引用的类型，<code>idautils.XrefTypeName(xref.type)</code> 用来打印表示该类型的含义。</p><p><code>xref.frm</code> 打印出该地址的交叉引用，<code>xref.to</code> 打印出改地址本身，<code>xref.iscode</code> 打印出该交叉引用是否在代码段中，上述的代码我们使用了 <code>idautils.XrefsTo(ea, 1)</code> 并将其 flag 位设为了 1，如果我们将 flag 设为 0 的话，那么它将会显示该地址的任意交叉引用。设置 flag 为 0 获取的交叉引用不只是来自于分支跳转指令，同时还会来自正常的指令流程，设置 flag 为 1 可以略过正常指令流程造成的交叉引用。</p><h3 id="交叉引用的类型"><a href="#交叉引用的类型" class="headerlink" title="交叉引用的类型"></a>交叉引用的类型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">xref.<span class="hljs-built_in">type</span><br></code></pre></td></tr></table></figure><p>xref.type 来指明该交叉引用的类型</p><p>这其中有 12 中类型</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">0</span>= <span class="hljs-string">&#x27;Unknown&#x27;</span><br><span class="hljs-attr">1</span>= <span class="hljs-string">&#x27;Offset&#x27;</span><br><span class="hljs-attr">2</span>= <span class="hljs-string">&#x27;Write&#x27;</span><br><span class="hljs-attr">3</span>= <span class="hljs-string">&#x27;Read&#x27;</span><br><span class="hljs-attr">4</span>= <span class="hljs-string">&#x27;Text&#x27;</span><br><span class="hljs-attr">5</span> = <span class="hljs-string">&#x27;Data_Informational&#x27;</span><br><span class="hljs-attr">16</span>= <span class="hljs-string">&#x27;Far_Call&#x27;</span><br><span class="hljs-attr">17</span>= <span class="hljs-string">&#x27;Near_Call&#x27;</span><br><span class="hljs-attr">18</span>= <span class="hljs-string">&#x27;Far_Jump&#x27;</span><br><span class="hljs-attr">19</span>= <span class="hljs-string">&#x27;Near_Jump&#x27;</span><br><span class="hljs-attr">20</span>= <span class="hljs-string">&#x27;Code_User&#x27;</span><br><span class="hljs-attr">21</span> = <span class="hljs-string">&#x27;Ordinary_Flow&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="打印交叉引用类型的含义"><a href="#打印交叉引用类型的含义" class="headerlink" title="打印交叉引用类型的含义"></a>打印交叉引用类型的含义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idautils.XrefTypeName(xref.<span class="hljs-built_in">type</span>)<br></code></pre></td></tr></table></figure><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="搜索特定的字节"><a href="#搜索特定的字节" class="headerlink" title="搜索特定的字节"></a>搜索特定的字节</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.find_binary(ea,flag,searchstr,radix=<span class="hljs-number">16</span>)<br></code></pre></td></tr></table></figure><p><code>flag</code> 代表搜索方向或条件。<code>flag</code> 有以下几种类型：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">SEARCH_UP</span> = <span class="hljs-number">0</span><br><span class="hljs-attr">SEARCH_DOWN</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">SEARCH_NEXT</span> = <span class="hljs-number">2</span><br><span class="hljs-attr">SEARCH_CASE</span> = <span class="hljs-number">4</span><br><span class="hljs-attr">SEARCH_REGEX</span> = <span class="hljs-number">8</span><br><span class="hljs-attr">SEARCH_NOBRK</span> = <span class="hljs-number">16</span><br><span class="hljs-attr">SEARCH_NOSHOW</span> = <span class="hljs-number">32</span><br><span class="hljs-attr">SEARCH_IDENT</span> = <span class="hljs-number">128</span><br><span class="hljs-attr">SEARCH_BRK</span> = <span class="hljs-number">256</span><br></code></pre></td></tr></table></figure><p>以上有几个常用类型：</p><ul><li><code>SEARCH_UP</code> 和 <code>SEARCH_DOWN</code> 用来指明搜索的方向</li><li><code>SEARCH_NEXT</code> 用来获取下一个已经找到的对象</li><li><code>SEARCH_CASE</code> 用来指明是否区分大小写</li><li><code>SEARCH_NOSHOW</code> 用来指明是否显示搜索的进度</li></ul><p><code>searchstr</code> 是我们要查找的形态，<code>radix</code> 参数在写处理器模块时使用（平常可以将这个参数留空）。</p><p>例如我们要查找 0x55, 0x8b, 0xec，也就是汇编语言中的：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br></code></pre></td></tr></table></figure><p>我们可以编写以下脚本实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> idc<br><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> idaapi<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-comment"># 定义要搜索的字节模式（这里是函数开头的常见汇编指令）</span><br>pattern = <span class="hljs-string">&quot;55 8B EC&quot;</span>  <span class="hljs-comment"># 55 8B EC对应push ebp; mov ebp, esp（函数序言）</span><br><br><span class="hljs-comment"># 获取IDA数据库中最低的地址（通常是.text段的起始地址）</span><br>addr = idc.get_inf_attr(INF_MIN_EA)<br><br><span class="hljs-comment"># 循环5次，查找5个匹配该模式的位置</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>):<br>    <span class="hljs-comment"># 从当前地址向下搜索二进制模式</span><br>    addr = idc.find_binary(addr, SEARCH_DOWN, pattern)<br><br>    <span class="hljs-comment"># 检查是否找到有效地址（不是BADADDR表示找到）</span><br>    <span class="hljs-keyword">if</span> addr != idc.BADADDR:<br>        <span class="hljs-comment"># 打印找到的地址（16进制）和对应的反汇编指令</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(addr), idc.GetDisasm(addr))<br></code></pre></td></tr></table></figure><p>以上脚本第一行定义了要搜索的形式，搜索形式可以是 16 进制格式，比如 <code>0x55 0x8B 0xEC</code> 和 <code>55 8B EC</code> 都可以，但是 <code>\x55\x8B\xEC</code> 这种格式可不行，除非你使用 <code>idc.find_text(ea, flag,y, x, searchstr)</code> 这个函数。</p><p>但是以上脚本在搜索的时候，地址并没有增长，是因为写程序时没有增加 <code>SEARCH_NEXT</code> 这个标记。正确修改如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> idc<br><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> idaapi<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-comment"># 定义要搜索的字节模式（这里是函数开头的常见汇编指令）</span><br>pattern = <span class="hljs-string">&quot;55 8B EC&quot;</span>  <span class="hljs-comment"># 55 8B EC对应push ebp; mov ebp, esp（函数序言）</span><br><br><span class="hljs-comment"># 获取IDA数据库中最低的地址（通常是.text段的起始地址）</span><br>addr = idc.get_inf_attr(INF_MIN_EA)<br><br><span class="hljs-comment"># 循环5次，查找5个匹配该模式的位置</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>):<br>    <span class="hljs-comment"># 从当前地址向下搜索二进制模式</span><br>    addr = idc.find_binary(addr, SEARCH_DOWN|SEARCH_NEXT, pattern)<br><br>    <span class="hljs-comment"># 检查是否找到有效地址（不是BADADDR表示找到）</span><br>    <span class="hljs-keyword">if</span> addr != idc.BADADDR:<br>        <span class="hljs-comment"># 打印找到的地址（16进制）和对应的反汇编指令</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(addr), idc.GetDisasm(addr))<br></code></pre></td></tr></table></figure><h3 id="搜索特定字符串"><a href="#搜索特定字符串" class="headerlink" title="搜索特定字符串"></a>搜索特定字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.find_text(ea, flag, y, x, searchstr, from_bc695=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p><code>ea</code> 参数是地址；<code>flag</code> 参数是搜索方向和搜索类型；<code>y</code> 是从 <code>ea</code> 开始搜索的行数，<code>x</code> 是行中的坐标，这两个参数通常设置为 0。</p><p>以下例子实现查找字符串 “Accept” 的出现次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> idc<br><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> idaapi<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-comment"># 获取IDA数据库中最小和最大地址</span><br>addr = idc.get_inf_attr(INF_MIN_EA)  <span class="hljs-comment"># 获取IDA数据库的最小有效地址</span><br>end = idc.get_inf_attr(INF_MAX_EA)   <span class="hljs-comment"># 获取IDA数据库的最大有效地址</span><br><br><span class="hljs-comment"># 开始循环遍历整个地址空间</span><br><span class="hljs-keyword">while</span> addr &lt; end:<br>    <span class="hljs-comment"># 从当前地址向下搜索包含&quot;accept&quot;文本的指令</span><br>    addr = idc.find_text(addr, SEARCH_DOWN, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;accept&quot;</span>)<br><br>    <span class="hljs-comment"># 检查是否找到有效地址</span><br>    <span class="hljs-keyword">if</span> addr == idc.BADADDR:  <span class="hljs-comment"># 如果返回BADADDR表示未找到</span><br>        <span class="hljs-keyword">break</span>               <span class="hljs-comment"># 退出循环</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 打印找到的地址(16进制)和反汇编指令</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(addr), idc.GetDisasm(addr))<br>        <span class="hljs-comment"># 移动到下一个指令头继续搜索</span><br>        addr = idc.next_head(addr)<br></code></pre></td></tr></table></figure><p>由于这个代码中使用 <code>idc.next_head(ea)</code> 使当前地址不断增长，所以不需要往 <code>idc.find_text()</code> 中添加 <code>SEARCH_NEXT</code> 的标志。不过也是因为在一行字符串中可能出现多次要查找的字符串，所以要手动增长地址，而不是使用 <code>SEARCH_NEXT</code> 标志。</p><h3 id="判断地址的类型"><a href="#判断地址的类型" class="headerlink" title="判断地址的类型"></a>判断地址的类型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.is_code(f) <span class="hljs-comment"># 判断是否是代码</span><br>idc.is_data(f) <span class="hljs-comment"># 判断是否是数据</span><br>idc.is_tail(f) <span class="hljs-comment"># 判断 IDA 是否将其判定为尾部。</span><br>idc.is_unknown(f) <span class="hljs-comment"># 判断 IDA 是否将其判定为未知，即既不是数据，也不是代码。</span><br>idc.is_head(f) <span class="hljs-comment"># 判断 IDA 是否将其判定为头部。</span><br></code></pre></td></tr></table></figure><p>这些 API 返回 bool 值。</p><p>其中 <code>f</code> 参数是新出现的，相比传递地址，我们要先通过 <code>idc.get_full_flags(ea)</code> 获取地址的内部标志表示，然后再传给 <code>idc.is_</code> 系列函数当参数，例如以下代码：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Python&gt;idc.get_full_flags(here())<br><span class="hljs-number">0</span>x4001078d<br>Python&gt;idc.is_code( idc.get_full_flags(here()))<br>True<br></code></pre></td></tr></table></figure><h3 id="寻找代码或数据的地址"><a href="#寻找代码或数据的地址" class="headerlink" title="寻找代码或数据的地址"></a>寻找代码或数据的地址</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.find_code(ea,flag)<br>idc.find_code(ea,flag)<br>idc.find_code(ea,flag)<br>idc.find_defined(ea, flag)<br>idc.find_imm(ea, flag, value)<br>idc.imm()<br></code></pre></td></tr></table></figure><p><code>idc.find_code(ea,flag)</code> 用于寻找被标志为代码的下一个地址。</p><p>如果<code>ea</code> 是代码地址，那么该函数返回下一个代码地址；<code>flag</code> 参数同 <code>idc.find_text</code> 中的参数。</p><p>这个函数会跳过一些数据段的地址，得到最近一个代码段的首地址。</p><p><code>idc.find_code(ea,flag)</code> 用于寻找被标志为数据的下一个地址。</p><p><code>idc.find_unknown(ea,flag)</code> 用于寻找 IDA 未识别为代码或数据的字节地址。</p><p><code>idc.find_defined(ea, flag)</code> 用于查找 IDA 标识为代码或数据的地址</p><p><code>idc.find_imm(ea, flag, value)</code> 用于查找立即数。</p><p><code>idc.imm</code> 这个函数返回一个元组，元组的第一项为地址，第二项为标识是第几个操作数。这里操作数的算法和 <code>idc.print_operand</code> 一样，都是从 0 开始的。循环使用搜索需要添加 <code>SEARCH_ DOWN|SEARCH_NEXT</code> 标志。</p><h2 id="数据提取"><a href="#数据提取" class="headerlink" title="数据提取"></a>数据提取</h2><p>IDA 可以获取到用户使用鼠标选中高亮的部分的代码。可以使用以下两个函数获取到选中部分的起始地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.read_selection_start()<br>idc.read_selection_end()<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Python&gt;idc.read_selection_start()<br><span class="hljs-number">0</span>x404cdb<br>Python&gt;idc.read_selection_end()<br><span class="hljs-number">0</span>x404d70<br></code></pre></td></tr></table></figure><p>需要注意的是：<code>idc.read_selection_end()</code> 获取的的并不是这一段代码的末尾地址，选中部分的最后一条指令的下一条指令的起始地址。</p><p>函数 <code>idaapi.read_selection()</code> 也可以实现上面的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">p0 = idaapi.twinpos_t()<br>p1 = idaapi.twinpos_t()<br>view = idaapi.get_current_viewer()<br>idaapi.read_selection(view, p0, p1)<br></code></pre></td></tr></table></figure><h2 id="注释和重命名"><a href="#注释和重命名" class="headerlink" title="注释和重命名"></a>注释和重命名</h2><p>注释一共有两种，第一种是常规注释，第二种是重复性注释。重复性注释会因为某些地址引用了当前地址的内容，而会自动添加上注释。</p><h3 id="增加（重复性）注释"><a href="#增加（重复性）注释" class="headerlink" title="增加（重复性）注释"></a>增加（重复性）注释</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.set_cmt(ea, cmt, <span class="hljs-number">0</span>)  <span class="hljs-comment"># 增加注释</span><br>idc.set_cmt(ea, cmt, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 增加重复性注释</span><br></code></pre></td></tr></table></figure><p><code>ea</code> 是要添加的地址，<code>cmt</code> 是要添加的注释。</p><p>实际上这两个函数定义是这样的，<code>idc.set_cmt(ea, cmt, repeatable)</code> ，当把 <code>repeatable</code> 定义为 <code>0</code> 时为普通注释，当定义为 <code>1</code> 时为重复性注释。</p><h3 id="获取-常规-重复性-注释"><a href="#获取-常规-重复性-注释" class="headerlink" title="获取 常规&#x2F;重复性 注释"></a>获取 常规&#x2F;重复性 注释</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.get_cmt(ea, <span class="hljs-number">0</span>)  <span class="hljs-comment"># 获取常规注释</span><br>idc.get_cmt(ea, <span class="hljs-number">0</span>)  <span class="hljs-comment"># 获取重复性注释</span><br></code></pre></td></tr></table></figure><h3 id="对函数的注释"><a href="#对函数的注释" class="headerlink" title="对函数的注释"></a>对函数的注释</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.set_func_cmt(ea, cmt, repeatable)<br>idc.get_func_cmt(ea, repeatable)<br></code></pre></td></tr></table></figure><p><code>ea</code> 可以是函数中的任何地址，<code>cmt</code> 就是我们需要添加的注释，<code>repeatable</code> 同上面一样。将函数的注释标记为可重复性的话，那么它会在任何调用该函数的地方增加注释。</p><h3 id="重命名函数"><a href="#重命名函数" class="headerlink" title="重命名函数"></a>重命名函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.set_name(ea, name, SN_CHECK)<br></code></pre></td></tr></table></figure><p>重命名函数和地址是一项非常常见的自动化任务，特别是在一些地址无关的代码 (PIC) ，加壳或者封装函数中，因为在 PIC 代码和脱壳代码中，导入表可能并不存在于转储中。而封装函数的功能只是简单的调用 API 而已。</p><p>需要注意的是 <code>rename_wrapper</code> 中的 <code>idc.MakeNameEx(ea,name, flag)</code> 用法。因为使用 <code>idc.MakeName</code> 的话，如果某一个函数名称已经被使用了，那么 IDA 会抛出一个警告的对话。</p><p>为了跳过该对话框，我们将 flag 的值设置为 256 或者 SN_NOWARN 即可。我们可以应用一些逻辑来将函数重命名为 w_HeapFree_1 等，但为简洁起见，我们会将其忽略。为了跳过该对话框，我们将 flag 的值设置为 <code>256</code> 或者 <code>SN_NOWARN</code> 即可。我们可以应用一些逻辑来将函数重命名为 w_HeapFree_1 等，但为简洁起见，我们会将其忽略。</p><h2 id="访问原始数据"><a href="#访问原始数据" class="headerlink" title="访问原始数据"></a>访问原始数据</h2><p>在逆向工程中获取原始数据是非常重要的，原始数据是 16 进制的字节，它们被解释为数据或代码，IDA 中我们可以在反汇编代码窗口的左侧看到这些原始数据。（IDA 中显示的设置方法： 菜单栏–&gt;选项–&gt;常规–&gt;反汇编–&gt;机器码字节数，填入一个数就 ok 了–&gt;确定 ）</p><p>要获取原始数据的话我们首先要指定获取的单元大小，这些获取原始数据 API 的命名规则就是以单元大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.get_wide_byte(ea)   <span class="hljs-comment"># 获取单字节</span><br>idc.get_wide_word(ea)   <span class="hljs-comment"># 获取一个字</span><br>idc.get_wide_dword(ea)  <span class="hljs-comment"># 获取双字</span><br>idc.get_qword(ea)       <span class="hljs-comment"># 获取四字</span><br>idc.GetFloat(ea)        <span class="hljs-comment"># 获取 float</span><br>idc.GetDouble(ea)       <span class="hljs-comment"># 获取 Double</span><br>idc.get_bytes(ea, size, use_dbg = <span class="hljs-literal">False</span>)  <span class="hljs-comment"># 获取某个地址开始的更多的字节</span><br></code></pre></td></tr></table></figure><p>在编写解码脚本是获取单个字节或者单个字并没有太多卵用，所以我们可以使用 <code>idc.get_bytes(ea, size, use_dbg = False)</code> 来获取某个地址开始的更多的字节。最后一个参数是可选的，用来指定是否正在调试内存。</p><p>不过需要注意的是，<code>idc.get_bytes</code> 返回的是 bytes 类型，跟 <code>idc.get_wide_byte(ea)</code> 返回的整型有区别。</p><h2 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h2><p>有时候我们在逆向一个恶意软件的时候，样本会有被加密的字符串。这会阻碍我们分析的过程和组织我们通过字符串来定位关键点。这种情况下给 idb 文件打补丁就很有用了。重命名地址但是好像并没有卵用，因为命名是有约束限制的，所以我们需要给某些地址做 patch 了，我们可以使用如下的函数来 patch：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">patch_byte(ea, value)<br>patch_word(ea, value)<br>patch_dword(ea, value)<br>patch_qword(ea, value)<br></code></pre></td></tr></table></figure><p><code>ea</code> 是地址，<code>value</code> 是值。选择对应的函数进行 <code>patch</code> 即可。</p><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p>在 IDAPython 中当我们并不知道文件的位置或者并不知道用户想要把他们的数据存储在什么地方，输入输出文件就很重要了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ida_kernwin.ask_file(for_saving, mask, prompt)<br></code></pre></td></tr></table></figure><p>当 <code>forsave</code> 参数为 0，打开一个文件对话框，当 <code>forsave</code> 的参数为 1，打开一个文件保存对话框，<code>mask</code> 用来指定文件后缀或者模式，比如我只想打开.dll 文件的话就可已使用”*.dll”作为 <code>mask</code> 的参数，<code>prompt</code> 是窗口的名称。</p><h2 id="批生成文件"><a href="#批生成文件" class="headerlink" title="批生成文件"></a>批生成文件</h2><p>有时，为目录中的所有文件创建 IDB 或 ASM 可能很有用。 在分析属于同一系列恶意软件的一组样本时，这可以帮助节省时间。比起手工做这件事情，写一个批处理文件会容易许多，我们只需要将 <code>-B</code> 该参数传给 <code>idaw.exe</code> 即可，下面的代码可以被复制到包含我们想为其生成文件的所有文件的目录中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> idc<br><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> idaapi<br><br><span class="hljs-comment"># 导入Python标准库模块</span><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict  <span class="hljs-comment"># 提供默认字典数据结构</span><br><span class="hljs-keyword">import</span> os         <span class="hljs-comment"># 提供操作系统相关功能</span><br><span class="hljs-keyword">import</span> subprocess <span class="hljs-comment"># 用于启动新进程</span><br><span class="hljs-keyword">import</span> glob       <span class="hljs-comment"># 用于文件路径模式匹配</span><br><br><span class="hljs-comment"># 使用glob模块获取当前目录下所有文件和文件夹的路径列表</span><br>paths = glob.glob(<span class="hljs-string">&quot;*&quot;</span>)<br><br><span class="hljs-comment"># 构建IDA Pro可执行文件的完整路径</span><br><span class="hljs-comment"># 从环境变量中获取Program Files目录，然后拼接IDA的安装路径和可执行文件名</span><br>ida_path = os.path.join(os.environ[<span class="hljs-string">&#x27;PROGRAMFILES&#x27;</span>], <span class="hljs-string">&quot;IDA&quot;</span>, <span class="hljs-string">&quot;idaw.exe&quot;</span>)<br><br><span class="hljs-comment"># 遍历当前目录下的所有文件和文件夹</span><br><span class="hljs-keyword">for</span> file_path <span class="hljs-keyword">in</span> paths:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> file_path.endswith(<span class="hljs-string">&quot;.py&quot;</span>):  <span class="hljs-comment"># 只处理非Python文件</span><br>        subprocess.call([ida_path, <span class="hljs-string">&quot;-B&quot;</span>, file_path])<br></code></pre></td></tr></table></figure><p>脚本运行完成后，会在当前目录下生成 ASM 文件和 IDB 文件。</p><h2 id="可执行脚本"><a href="#可执行脚本" class="headerlink" title="可执行脚本"></a>可执行脚本</h2><p>ipapython 脚本可以在命令行中执行，我们也可以使用下面计算 IDB 拥有指令个数的脚本，然后将其个数写进一个叫做 “instru_count.txt” 文件中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> idc<br><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> idaapi<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-comment"># 等待IDA自动分析完成</span><br>idaapi.auto_wait()<br><br><span class="hljs-comment"># 初始化计数器，用于统计指令数量</span><br>count = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 遍历IDA数据库中所有函数</span><br><span class="hljs-keyword">for</span> func <span class="hljs-keyword">in</span> idautils.Functions():<br>    <span class="hljs-comment"># 获取当前函数的属性标志</span><br>    flags = idc.get_func_attr(func, FUNCATTR_FLAGS)<br><br>    <span class="hljs-comment"># 如果函数是库函数(由FUNC_LIB标志标识)，则跳过不统计</span><br>    <span class="hljs-keyword">if</span> flags &amp; idc.FUNC_LIB:<br>        <span class="hljs-keyword">continue</span><br><br>    <span class="hljs-comment"># 遍历当前函数中的所有指令</span><br>    <span class="hljs-keyword">for</span> instru <span class="hljs-keyword">in</span> idautils.FuncItems(func):<br>        <span class="hljs-comment"># 对每条指令计数</span><br>        count += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 打开文件&quot;instru_count.t&quot;用于写入结果</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;instru_count.t&quot;</span>,<span class="hljs-string">&#x27;w&#x27;</span>)<br><br><span class="hljs-comment"># 格式化输出字符串，包含统计的指令总数</span><br>writeContent = <span class="hljs-string">&quot;Instruction count is &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(count)<br><br><span class="hljs-comment"># 在IDA输出窗口打印结果</span><br><span class="hljs-built_in">print</span>(writeContent)<br><br><span class="hljs-comment"># 将结果写入文件</span><br>f.write(writeContent)<br><span class="hljs-comment"># 关闭文件</span><br>f.close()<br><br><span class="hljs-comment"># 退出IDA，返回状态码0表示成功</span><br>idc.qexit(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>上面两个十分重要的函数，一个是 <code>idaapi.auto_wait()</code> ,一个是 <code>idc.qexit(0)</code> ,当 ida 打开一个文件的时候，等待 IDA 分析完成是很重要的，因为 IDA 分析一个文件需要花大量的时间。这时候你不能执行 IDAPython 脚本，所以你可使用 <code>idaapi.auto_wait()</code> 来等待 IDA 文件分析结束，它会在 IDA 分析完成之前一直等待，一旦分析完成，控制权就会交到脚本身上。然后我们同样需要使用 <code>idc.qexit(0)</code> 来结束脚本的执行，如果不这么做的话，IDB 可以会在关闭的时候出问题。</p><h3 id="等待-IDA-分析完成"><a href="#等待-IDA-分析完成" class="headerlink" title="等待 IDA 分析完成"></a>等待 IDA 分析完成</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idaapi.auto_wait()<br></code></pre></td></tr></table></figure><h3 id="计算-IDB-包含多少行"><a href="#计算-IDB-包含多少行" class="headerlink" title="计算 IDB 包含多少行"></a>计算 IDB 包含多少行</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idat.exe -A -S<span class="hljs-string">&quot;test.py&quot;</span> .\Trojan.Win32.AntiAV.aaa.json.idb<br></code></pre></td></tr></table></figure><p><code>-A</code> 表示自动化分析，<code>-S</code> 表示 idb 被打开之后立即执行的脚本。</p><p>同时自动化脚本也是支持参数的，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idat.exe -A -S<span class="hljs-string">&quot;test.py test&quot;</span> .\Trojan.Win32.AntiAV.aaa.json.idb<br></code></pre></td></tr></table></figure><p>以上指令就能够向脚本中传参数 test ，可以使用<code>idc.ARGV</code>获取。</p><h2 id="函数栈帧的访问"><a href="#函数栈帧的访问" class="headerlink" title="函数栈帧的访问"></a>函数栈帧的访问</h2><p>在 x86 程序中，EBP 寄存器通常专门用做栈帧指针，例外 gun&#x2F;g++提供 -fomit-frame-pointer 编译选项，可以生成不依赖于固定帧指针寄存器的函数。</p><p>基于 ebp 做栈帧指针的函数，正偏移是函数参数，负偏移是则用于访问函数的局部变量。</p><p>很明显函数的栈帧是一个运行时的概念，没有栈和运行时的程序，栈帧就不可能存在。话虽如此，但是并不意味者 ida 在做静态的分析的时候就会忽略掉栈帧的概念。二进制文件中包含配置每个函数栈帧所需的所有代码，通过仔细分析这些代码，我们就可以深入了解任何函数的栈帧结构，即使这个函数并未运行。在 IDA 中也会有一些复杂的分析来确定 IDA 反汇编的每个函数的栈帧布局。在分析的过程中，IDA 会记住每一次 push&#x2F;pop 操作，以及其他的任何可能改变栈指针的运算，如增加或者减去常量，尽可能的去观察栈指针在函数执行时的行为。</p><p>IDA 提供一个摘要视图，列出了栈帧内被直接引用的每一个变量，以及变量的大小和与它们与帧指针的偏移距离。</p><p>例如下面所示：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">404C90 <span class="hljs-comment">; int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)</span><br><span class="hljs-symbol">.text:</span>00404C90 _WinMain@<span class="hljs-number">16</span>     proc <span class="hljs-built_in">near</span>               <span class="hljs-comment">; CODE XREF: start+186↓p</span><br><span class="hljs-symbol">.text:</span>00404C90<br><span class="hljs-symbol">.text:</span>00404C90 phkResult       = <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> -<span class="hljs-number">658h</span><br><span class="hljs-symbol">.text:</span>00404C90 Data            = <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> -<span class="hljs-number">654h</span><br><span class="hljs-symbol">.text:</span>00404C90 var_650         = WNDCLASSEXW <span class="hljs-built_in">ptr</span> -<span class="hljs-number">650h</span><br><span class="hljs-symbol">.text:</span>00404C90 String1         = <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> -<span class="hljs-number">620h</span><br><span class="hljs-symbol">.text:</span>00404C90 var_61E         = <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> -<span class="hljs-number">61Eh</span><br><span class="hljs-symbol">.text:</span>00404C90 anonymous_0     = <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> -<span class="hljs-number">41Ah</span><br><span class="hljs-symbol">.text:</span>00404C90 var_418         = <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> -<span class="hljs-number">418h</span><br><span class="hljs-symbol">.text:</span>00404C90 var_416         = <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> -<span class="hljs-number">416h</span><br><span class="hljs-symbol">.text:</span>00404C90 anonymous_1     = <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> -<span class="hljs-number">212h</span><br><span class="hljs-symbol">.text:</span>00404C90 String2         = <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> -<span class="hljs-number">210h</span><br><span class="hljs-symbol">.text:</span>00404C90 var_20E         = <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> -<span class="hljs-number">20Eh</span><br><span class="hljs-symbol">.text:</span>00404C90 anonymous_2     = <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> -<span class="hljs-number">0Ah</span><br><span class="hljs-symbol">.text:</span>00404C90 StackCookie     = <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> -<span class="hljs-number">4</span><br><span class="hljs-symbol">.text:</span>00404C90 hInstance       = <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span>  <span class="hljs-number">8</span><br><span class="hljs-symbol">.text:</span>00404C90 hPrevInstance   = <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span>  <span class="hljs-number">0Ch</span><br><span class="hljs-symbol">.text:</span>00404C90 lpCmdLine       = <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span>  <span class="hljs-number">10h</span><br><span class="hljs-symbol">.text:</span>00404C90 nShowCmd        = <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span>  <span class="hljs-number">14h</span><br></code></pre></td></tr></table></figure><p>不过需要注意的是：<code>arg_0</code> 对应的偏移是 <code>ebp+0x4</code> ，<code>arg_4</code> 对应的偏移是 <code>ebp+0x8</code> 。</p><p>IDAPython 也提供获取此函数栈帧的 API，获取到之后是一个结构体，操作结构体成员就可以获取到函数栈帧内的所有变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">idaapi.get_func(ea)                     <span class="hljs-comment"># 获取地址ea 处函数的func_t结构体</span><br>idaapi.get_frame(func_t foo)            <span class="hljs-comment"># 返回 foo 指定函数帧的 struct_t 结构体</span><br>idautils.DecodeInstruction(ea)          <span class="hljs-comment">#  返回地址 ea 处指令的 inst_t 表示，功能与函数idaapi.decode_insn相同</span><br>idaapi.get_stkvar(op_t op, sval_t v)    <span class="hljs-comment"># op 是指令的引用，v 是操作数中的立即值。通常直接使用 op.addr。返回一个元组 (member_t, val)，其中 member_t 是指向栈变量的指针（这是我们需要的），val 与栈变量 member_t 中的 soff 字段值相同。</span><br>idaapi.xreflist_t()                     <span class="hljs-comment"># 创建一个新的 xreflist_entry_t 类型交叉引用列表</span><br>idaapi.build_stkvar_xrefs(xreflist_t xrefs, func_t func, member_t member)  <span class="hljs-comment"># 用 member 在 func 中表示的栈变量交叉引用填充 xrefs 列表（填充 xreflist_entry_t 类型数据）</span><br>struct_t.get_member(x)                  <span class="hljs-comment"># 可通过此方法遍历帧中的所有栈变量来获取所有 member_t。若需要为所有栈变量构建交叉引用，这种方法通常更简便</span><br>idc.get_member_name(<span class="hljs-built_in">id</span>, member_offset)  <span class="hljs-comment"># id 是结构体 sid，member_offset 是成员偏移量。获取在名称中定义的成员名称</span><br>idc.get_member_offset(<span class="hljs-built_in">id</span>,name)          <span class="hljs-comment"># 获取成员偏移量</span><br></code></pre></td></tr></table></figure><p>对于函数 <code>idautils.DecodeInstruction(ea)</code> ，这是一个指令解码的 API，如果解码失败返回 None，否则将返回一个包含该指令及操作数的指令对象。</p><p>比较重要的指令属性如下：</p><ul><li><code>inst.itype</code> ：标志当前指令的类型，是一个整数，不同的 opcode 可能有相同的 itype，但是 opcode 不是 itype。</li><li><code>inst.size</code> ：表示解码后的指令长度</li><li><code>inst.ops[]</code> ：以 0 为索引的数组，用来保存操作数的相关信息</li><li><code>inst.Op1...inst.OpN</code> ：以 1 位索引起始操作数组别名,和 inst.ops[n+1]等价。</li><li><code>inst.ea</code> ：指令的线性地址。</li></ul><p>你可能会想知道 opcode 和它的 <code>itype</code> 之间到底是什么关系。其实很简单，在 IDA 中，开源数据库处理器模块负责根据 opcode 来填充 <code>itype</code> 字段。在 IDA SDK 中，你可以找到一个 <code>allins.hpp</code> 的头文件。该头文件包含了所有支持的处理器模块的枚举数据其中包含了受支持的所有指令：</p><p><code>NN_</code> 前缀用来表示 x86&#x2F;x64 处理器上的指令。</p><p>至于操作数，可以通过访问 <code>inst.Operands[]</code> 或者 <code>inst.OpN</code> 来访问。要获取被解码指令使用的操作数数量不应依赖 <code>Operands</code> 数组的长度，因为它总是被解析成 <code>UA_MAXOP==8</code> （参阅 ida.hpp），因此应该使用遍历每个操作数并检查操作数的类型是否是 <code>o_void</code> 类型。</p><p>操作数的定义是 <code>ua.hpp</code> 中的 <code>op_t</code> 结构。</p><ul><li><code>op.flags</code> ：操作数的标志</li><li><code>op.dtype</code> ：操作数的长度类型。<code>idaapi.dt_xxx</code> 常量，可以通过该常量来获取操作数的字节大小（1 &#x3D;&#x3D; idaapi.dt_byte, 2 &#x3D;&#x3D; idaapi.dt_word 等等）。</li><li><code>op.type</code> ：操作数类型。<code>idc.o_xxx</code>常量。</li><li><code>specflags1</code>…<code>specflags4</code> ：处理器相关标志。</li></ul><p>以下是受支持的操作数类型（ <code>o_xxx</code> ）:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">o_void：没有该操作数。<br>o_reg：该操作数是寄存器（<span class="hljs-built_in">ax</span>,<span class="hljs-built_in">al</span>,<span class="hljs-built_in">es</span>,<span class="hljs-built_in">ds</span>等等）<br>o_mem：直接寻址（数据）<br>o_phrase：[基址+变址]寻址<br>o_displ：[基址+变址+偏移]寻址<br>o_imm：立即数<br>o_far：直接远地址（<span class="hljs-built_in">far</span> address，代码）<br>o_near：直接近地址（<span class="hljs-built_in">near</span> address，代码）<br>o_dispspec0...o_dispspec5：处理器相关标志。<br></code></pre></td></tr></table></figure><p>还有一些操作数成员的含义因操作数的类型而异：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">op<span class="hljs-emphasis">_reg：寄存器编号（o_reg）</span><br><span class="hljs-emphasis">op_phrase：内存访问中的索引寄存器（o_phrase）</span><br><span class="hljs-emphasis">op_value：立即数（o_imm）或偏移（o_displ）</span><br><span class="hljs-emphasis">op_addr： 操作数使用的内存地址（o_mem，o_far，o_displ，o_</span>near）<br></code></pre></td></tr></table></figure><p>当操作数的类型是 <code>o_reg</code> 或者 <code>o_phrase</code> 的时候，<code>op_reg</code> &#x2F; <code>op_phrase</code> 值包含了对应寄存器的枚举值。就像 <code>NN_xxx</code> 专有标签，IDA SDK 同样提供了寄存器的名称常量，以及其对应的值；但是，这只适用于 <code>x86</code> &#x2F; <code>x64</code> 处理器模块。</p><p>可以利用如下代码获取某个函数栈帧的所有成员以及偏移。注意获取的 frame 不仅包括函数栈帧还包括返回地址以及形参。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> idc<br><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> idaapi<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-comment"># 获取当前光标所在位置的地址</span><br>addr = here()<br><br><span class="hljs-comment"># 获取包含当前地址的函数对象</span><br>func = idaapi.get_func(addr)<br><br><span class="hljs-comment"># 获取该函数的栈帧(frame)信息</span><br>frame = idaapi.get_frame(func)<br><br><span class="hljs-comment"># 打印栈帧对象信息</span><br><span class="hljs-built_in">print</span>(frame)<br><br><span class="hljs-comment"># 初始化计数器</span><br>x = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 创建一个空字典，用于存储成员变量名和偏移量的映射</span><br>dictMem = &#123;&#125;<br><br><span class="hljs-comment"># 遍历栈帧中的所有成员变量</span><br><span class="hljs-keyword">while</span>(x &lt; frame.memqty):<br>    <span class="hljs-comment"># 获取第x个成员变量的名称</span><br>    <span class="hljs-comment"># frame.id: 栈帧结构的ID</span><br>    <span class="hljs-comment"># frame.get_member(x).soff: 获取第x个成员的偏移量</span><br>    name = idc.get_member_name(frame.<span class="hljs-built_in">id</span>, frame.get_member(x).soff)<br><br>    <span class="hljs-comment"># 将成员变量名和其偏移量(转换为16进制字符串)存入字典</span><br>    <span class="hljs-comment"># idc.get_member_offset: 获取成员变量的偏移量</span><br>    dictMem[name] = <span class="hljs-built_in">hex</span>(idc.get_member_offset(frame.<span class="hljs-built_in">id</span>,name))<br><br>    <span class="hljs-comment"># 计数器递增</span><br>    x = x+<span class="hljs-number">1</span><br><br><span class="hljs-comment"># 打印包含所有成员变量名和偏移量的字典</span><br><span class="hljs-built_in">print</span>(dictMem)<br></code></pre></td></tr></table></figure><p>注意此偏移都是相对于当前栈帧的栈底(也就是 esp )来说的。注意两个非常重要的成员” r”和” s”，其中” r”代表返回地址存储的偏移，” s”代表当前函数栈帧中 ebp 距离 esp 的位置(也就是函数栈帧的大小)。<strong>注意有个空格</strong>。</p><p>也可以利用此 frame 的结构来获取 x86 中当前函数参数的字节数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取函数返回地址在栈帧结构中的偏移量</span><br><span class="hljs-comment"># frame.id 是当前函数的栈帧结构ID</span><br><span class="hljs-comment"># &quot; r&quot; 是IDA中表示返回地址的成员名称(注意前面有个空格)</span><br>ret_off = idc.get_member_offset(frame.<span class="hljs-built_in">id</span>, <span class="hljs-string">&quot; r&quot;</span>)<br><br><span class="hljs-comment"># 计算第一个参数的偏移量</span><br><span class="hljs-comment"># 在x86架构中，返回地址占用4字节，所以第一个参数位于返回地址之后4字节处</span><br>first_arg_off = ret_off + <span class="hljs-number">4</span><br><br><span class="hljs-comment"># 计算所有参数的总大小</span><br><span class="hljs-comment"># 用整个栈帧结构的大小减去第一个参数的偏移量，得到所有参数占用的总空间</span><br>args_size = idc.get_struc_size(frame.<span class="hljs-built_in">id</span>) - first_arg_off<br><br><span class="hljs-comment"># 打印参数总大小</span><br><span class="hljs-built_in">print</span>(args_size)<br></code></pre></td></tr></table></figure><p>获取某个函数的某一条指令中引用的函数栈帧变量的名字以及在 frame 中的偏移，并获取其他地方引用此变量的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这段代码用于分析IDA Pro中函数的栈变量引用情况</span><br><br><span class="hljs-comment"># 0x00404C90 是目标函数的地址</span><br><span class="hljs-comment"># 0x00404CA4 是一条引用栈变量的指令地址</span><br><span class="hljs-comment"># 示例指令：</span><br><span class="hljs-comment"># .text:00404CA4  mov     [esp+668h+StackCookie], eax</span><br><span class="hljs-comment"># .text:00404CBF  mov     ecx, [esp+668h+StackCookie] ; StackCookie</span><br><br><span class="hljs-comment"># 获取地址0x00404C90处的函数对象</span><br>pFunc = idaapi.get_func(<span class="hljs-number">0x00404C90</span>)<br><br><span class="hljs-comment"># 获取该函数的栈帧(frame)对象</span><br><span class="hljs-comment"># 栈帧包含了函数中局部变量和参数的信息</span><br>pFrame = idaapi.get_frame(pFunc)<br><br><span class="hljs-comment"># 解码地址0x00404CA4处的指令</span><br><span class="hljs-comment"># 返回一个指令对象，包含操作码、操作数等信息</span><br>inst = idautils.DecodeInstruction(<span class="hljs-number">0x00404CA4</span>)<br><br><span class="hljs-comment"># 获取指令的第一个操作数</span><br><span class="hljs-comment"># 注意：这个操作数必须引用栈帧变量，否则下一条指令会报错</span><br>op = inst[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 获取栈变量信息：</span><br><span class="hljs-comment"># pMember - 指向栈帧结构体中的成员</span><br><span class="hljs-comment"># val - 该变量在栈帧中的偏移量</span><br>pMember, val = idaapi.get_stkvar(inst, op, op.addr)<br><br><span class="hljs-comment"># 创建一个交叉引用列表对象，用于存储结果</span><br>xrefs = idaapi.xreflist_t()<br><br><span class="hljs-comment"># 构建该栈变量的交叉引用列表：</span><br><span class="hljs-comment"># 1. pFunc - 所属函数</span><br><span class="hljs-comment"># 2. pMember - 栈变量成员</span><br><span class="hljs-comment"># 这个函数会找出所有引用该栈变量的指令地址</span><br>idaapi.build_stkvar_xrefs(xrefs, pFunc, pMember)<br><br><span class="hljs-comment"># 遍历所有交叉引用并打印它们的地址</span><br><span class="hljs-keyword">for</span> xref <span class="hljs-keyword">in</span> xrefs:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(xref.ea))  <span class="hljs-comment"># 以十六进制格式打印交叉引用地址</span><br></code></pre></td></tr></table></figure><p>也可以使用如下代码找具体的某个栈帧变量在函数中的引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取地址0x00404C90处的函数对象</span><br><span class="hljs-comment"># idaapi.get_func()用于获取指定地址的函数信息</span><br>pFunc = idaapi.get_func(<span class="hljs-number">0x00404C90</span>)<br><br><span class="hljs-comment"># 获取该函数的栈帧(frame)信息</span><br><span class="hljs-comment"># 栈帧包含函数的局部变量、参数等信息</span><br>pFrame = idaapi.get_frame(pFunc)<br><br><span class="hljs-comment"># 创建一个空字典用于存储栈成员信息</span><br><span class="hljs-comment"># 键为成员名称，值为成员对象</span><br>dictMem = <span class="hljs-built_in">dict</span>()<br><br><span class="hljs-comment"># 初始化计数器</span><br>x = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 遍历栈帧中的所有成员</span><br><span class="hljs-comment"># pFrame.memqty表示栈帧中成员的数量</span><br><span class="hljs-keyword">while</span>(x &lt; pFrame.memqty):<br>    <span class="hljs-comment"># 获取当前成员的名称和成员对象，并存入字典</span><br>    <span class="hljs-comment"># idc.get_member_name()获取成员名称</span><br>    <span class="hljs-comment"># pFrame.get_member(x)获取第x个成员对象</span><br>    <span class="hljs-comment"># soff表示成员在栈帧中的偏移量</span><br>    dictMem[idc.get_member_name(pFrame.<span class="hljs-built_in">id</span>, pFrame.get_member(x).soff)] = pFrame.get_member(x)<br>    <span class="hljs-comment"># 计数器递增</span><br>    x = x+<span class="hljs-number">1</span><br><br><span class="hljs-comment"># 现在可以通过变量名从字典中获取对应的成员对象</span><br><span class="hljs-comment"># 这里获取名为&quot;hInstance&quot;的栈变量成员</span><br>pMem = dictMem[<span class="hljs-string">&quot;hInstance&quot;</span>]<br><br><span class="hljs-comment"># 创建一个交叉引用列表对象</span><br><span class="hljs-comment"># 用于存储找到的交叉引用</span><br>xrefs = idaapi.xreflist_t()<br><br><span class="hljs-comment"># 构建指定栈变量的交叉引用</span><br><span class="hljs-comment"># 参数：xrefs(存储结果的列表), pFunc(函数对象), pMem(栈成员对象)</span><br>idaapi.build_stkvar_xrefs(xrefs, pFunc, pMem)<br><br><span class="hljs-comment"># 遍历并打印所有交叉引用地址</span><br><span class="hljs-keyword">for</span> xref <span class="hljs-keyword">in</span> xrefs:<br>    <span class="hljs-comment"># 以十六进制格式打印引用地址</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(xref.ea)) <span class="hljs-comment">#print xrefs to var_4</span><br></code></pre></td></tr></table></figure><h2 id="程序入口点"><a href="#程序入口点" class="headerlink" title="程序入口点"></a>程序入口点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.get_entry_qty()           <span class="hljs-comment"># 获取入口点个数</span><br>idc.get_entry_ordinal(index)  <span class="hljs-comment"># 获取入口点地址</span><br>idc.get_entry_name(ordinal)   <span class="hljs-comment"># 入口名</span><br></code></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>安装调试的 hook 使用如下 API：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">debugger = idaapi.DBG_Hooks()<br>debugger.hook()<br></code></pre></td></tr></table></figure><p>现在运行调试器，hook 会捕捉所有的调试事件，这样就能非常精确的控制 IDA 调试器。 下面的函数在调试的时候非常有用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.add_bpt( long Address )                     <span class="hljs-comment"># 在指定的地点设置软件断点。</span><br>idc.get_bpt_qty()                               <span class="hljs-comment">#返回当前设置的断点数量。</span><br>idc.get_reg_value(string Register)              <span class="hljs-comment"># 获取寄存器的值 ,dbg必须处于运行状态</span><br>idc.set_reg_Value(long Value, string Register)  <span class="hljs-comment"># 通过寄存器名获得寄存器值。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>逆向</tag>
      
      <tag>IDAPython</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux进程间通信</title>
    <link href="/2025/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <url>/2025/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>大型操作系统往往需要很多进程协作，因此需要进程间通信。</p><h3 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h3><p>进程隔离是为了保护操作系统中进程互不干扰。能够避免进程 A 写入进程 B 的情况发生。进程隔离通过使用虚拟地址空间的方法保护了各进程的独立运行。</p><h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><p>创建一个进程时，操作系统会分配 4GB（一个指针长度为 4 字节，寻址能力为 0x00000000~0xFFFFFFFF）大小的虚拟地址内存空间。这个虚拟地址不是真实存在的，是对物理地址的映射。每个进程只能访问自己虚拟地址中的数据，而无法访问别的进程中的数据，这样就实现了进程间的地址隔离。</p><p>Linux 操作系统将 1G（0xC0000000~0xFFFFFFFF）分配给内核使用，称作内核空间；3G（0x00000000~0xBFFFFFFF）供各个进程使用，称作用户空间。每个进程都可以通过系统调用进入内核。在 Linux 中，进程的用户空间是独立的，内核空间是公共的。进程切换时，用户空间切换，内核空间不改变。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/916005-20200620154201928-350653204.png"></p><h3 id="系统调用-内核态-用户态"><a href="#系统调用-内核态-用户态" class="headerlink" title="系统调用&#x2F;内核态&#x2F;用户态"></a>系统调用&#x2F;内核态&#x2F;用户态</h3><p>用户空间访问内核空间的唯一方式就是系统调用。通过统一入口接口，对所有资源的访问都在内核的控制下完成，保证系统的安全与稳定。</p><p>当一个进程执行系统调用而陷入内核代码中执行时，就称进程处于内核态，此时处理器处于特权级最高的内核代码中执行；当进程执行用户代码时，则称其处于用户态，此时处理器在特权级最低的用户代码中执行。</p><h2 id="IPC-通信原理"><a href="#IPC-通信原理" class="headerlink" title="IPC 通信原理"></a>IPC 通信原理</h2><p>进程间通信通常做法如下：</p><p>消息发送方将要发送的数据存放在用户态空间的内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间中分配内存，调用<code>copy_from_user()</code>函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。接收方进程在接受数据时在自己的用户空间开辟一块内存缓存区，然后内核调用<code>copy_to_user()</code>函数将数据从内核缓存区拷贝到接收进程的用户态缓存区。这样就实现一次数据传输。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/1167421-ec941da22668e065.webp"></p><h2 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h2><ul><li>管道（pipe）（匿名管道、命名管道）</li><li>信号（signal）</li><li>消息队列（queue）</li><li>共享内存</li><li>信号量</li><li>套接字</li></ul><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道本质是一个内核缓存区，它需要通信的两个进程在管道的两端，进程使用管道传递信息。</p><p>管道对于两个进程而言，是一个只存在于内存中而不属于文件系统的特殊文件。</p><p>操作系统为管道提供操作方法有文件操作与 fork 共享管道。</p><p>管道分为匿名管道与命名管道。</p><p>匿名管道有几个重要限制：</p><ol><li>匿名管道是单向的</li><li>管道只能用于有亲缘关系的进程中通信</li></ol><p>命名管道允许没有亲缘关系的进程进行通信。命名管道提供了一个路径名与管道进行关联，这样就算其他进程与该进程没有亲缘关系，只要能访问路径，就可以通过命名管道互相通信。</p><h4 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> fileds[<span class="hljs-number">2</span>])</span>;<br></code></pre></td></tr></table></figure><p><code>pipe()</code>函数接受一个参数，即包含两个整数的数组。例如<code>int pipe(int pipefd[2])</code>。如果调用成功，会通过<code>pipefd[2]</code>传出用户程序的两个文件描述符。需要注意的是<code>pipefd[0]</code>指向管道的读端，<code>pipefd[1]</code>指向管道的写端。此时这个管道对于用户程序就是一个文件，可以通过<code>read(pipefd[0])</code>或者<code>write(pipefd[1])</code>进行读写操作。<code>pipe()</code>函数调用成功返回 0，否则返回-1。</p><p>需要注意的是必须在<code>fork()</code>之前调用<code>pipe()</code>，否则子进程不会继承文件描述符。两个进程不共享祖先进程，就不能使用<code>pipe()</code></p><p>匿名管道通信的步骤：</p><ul><li>父进程创建管道，得到两个文件描述符指向管道的两端。<br><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503251155363.png"></li><li>利用<code>fork()</code>函数创建子进程，子进程也得到两个文件描述符指向同一管道。<br><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503251155391.png"></li><li>父进程关闭读端（pipefd[0]），子进程关闭写端（pipefd[1]），此时父进程可以往管道进行写操作，子进程可以从管道进行读操作（也可以反着来关闭），从而实现进程间通信。<br><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503251155417.png"></li></ul><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>], nbytes;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">char</span> <span class="hljs-built_in">string</span>[] = <span class="hljs-string">&quot;hello world, my pipe!&quot;</span>;<br>    <span class="hljs-type">char</span> readbuffer[<span class="hljs-number">100</span>];<br><br>    <span class="hljs-type">int</span> *write_fd = &amp;fd[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> *read_fd = &amp;fd[<span class="hljs-number">0</span>];<br><br>    result = pipe(fd);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> == result)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fail to create pipe\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    pid = fork();<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">-1</span> == pid)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fail to fork\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == pid)<br>    &#123;<br>        close(*read_fd);<br>        result = write(*write_fd, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>));<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        close(*write_fd);<br>        nbytes = read(*read_fd, readbuffer, <span class="hljs-keyword">sizeof</span>(readbuffer));<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the parent receive %d bytes data: %s \n&quot;</span>, nbytes, readbuffer);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503251155445.png"></p><h4 id="匿名管道的特点"><a href="#匿名管道的特点" class="headerlink" title="匿名管道的特点"></a>匿名管道的特点</h4><ul><li>只能单向通信（两个文件描述符只能分别给两个不同的进程用，不用的另一个要 close）</li><li>只能在有血缘关系的进程中进行通信</li><li>依赖于文件系统</li><li>生命周期随进程</li><li>面向字节流的服务<br>面向字节流：数据无规则，没有明显边界，收发数据比较灵活<br>面向字节包：数据有明显边界，数据只能整条接受</li><li>管道内部提供了同步机制<br>临界资源：大家都能访问到的共享资源<br>临界区：对临界资源进行操作的代码<br>同步：临界资源访问的可控时序性（一个操作完才能执行另一个操作）<br>互斥：对临界资源同一时间的唯一访问性</li></ul><p>匿名管道可以通过父进程把文件描述符传递给子进程，实现父子之间通信，也可以父进程传递给两个子进程，然后实现两个子进程之间的通信。最重要的一点就在于需要 fork 传递文件描述符使得两个进程都能访问同一个管道。</p><p>当管道进行写入操作的时候，如果写入的数据小于 128K 则是非原子的，如果大于 128K 字节，缓冲区的数据将被连续地写入管道，直到全部数据写完为止，如果没有进程读取数据，则将一直阻塞。</p><p>几种特殊情况：</p><ol><li>写端关闭，仍有进程从读端读取数据，在剩余数据全部读取后，再次 read 会返回 0。</li><li>写端没关闭，但是持有写端的进程没有往管道中写入数据，此时有进程从管道读端读取数据，在剩余数据全部读取后，再次 read 会阻塞，直到管道中有数据可读了才读取数据并返回。</li><li>读端关闭，仍有进程从写端写入数据，则该进程会收到信号 SIGPIPE，通常会导致进程异常终止。</li><li>读端没关闭，但是持有读端的进程没有从管道中读取数据，此时有进程从管道写端写入数据，在管道被写满时再 write 会阻塞，直到管道中有空位置了才写入数据返回。</li></ol><h4 id="命名管道（FIFO）"><a href="#命名管道（FIFO）" class="headerlink" title="命名管道（FIFO）"></a>命名管道（FIFO）</h4><p>命名管道提供一个路径名与管道进行关联，以 FIFO 的文件形式存储在文件系统中。命名管道是一个设备文件，即使进程与创建 FIFO 的进程不存在亲缘关系，只要能访问路径，就能够使用 FIFO 相互通信。FIFO 按照先进先出的原则工作。不过 FIFO 是单向数据流，也就是半双工</p><p>命名管道通过<code>mknod()</code>和<code>mkfifo()</code>创建，两个函数定义在头文件 sys&#x2F;stat.h 中。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mknod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">mode_t</span> mod, <span class="hljs-type">dev_t</span> dev)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">mkfifo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">mode_t</span> mod)</span>;<br></code></pre></td></tr></table></figure><p>path：命名管道的全路径名</p><p>mod：命名管道的模，指明其存取权限</p><p>dev：文件创建的种类，只有创建设备文件时才会用上</p><p>命名管道打开特性：</p><ol><li>如果用只读打开命名管道，<code>open</code>函数将阻塞等待至有其他进程以写的方式打开这个命名管道</li><li>如果用只写打开命名管道，<code>open</code>函数将阻塞等待至有其他进程以读的方式打开这个命名管道</li><li>如果用读写打开命名管道，则不会阻塞，但是管道是单向的</li></ol><p>使用 FIFO 时需要注意的是：</p><ul><li>fifo 管道是先调用 mkfifo 创建，然后再用 open 打开得到 fd 来使用</li><li>在打开 fifo 时要注意,它是半双工的的,一般不能使用 O_RDWR 打开,而只能用只读或只写打开</li></ul><p>fifo 可以用在非亲缘关系的进程间，而它的真正用途是在服务器和客户端之间。由于它是半双工的所以，如果要进行客户端和服务器双方的通信的话，每个方向都必须建立两个管道，一个用于读，一个用于写。</p><h3 id="System-V-IPC"><a href="#System-V-IPC" class="headerlink" title="System V IPC"></a>System V IPC</h3><p>IPC 是指多个进程之间相互通信的方法，System V 是 Unix 操作系统最早的商业发行版。System V IPC 是指 Linux 引入自 System V 的进程通信机制，一共有三种：</p><ul><li>信号量，用来管理对共享资源的访问</li><li>共享内存，用来高效实现进程间的数据共享</li><li>消息队列，用来实现进程间数据的传递</li></ul><p>这三种统称 IPC 资源，每个 IPC 资源都是请求时动态创建的，都是永驻内存，除非被进程显式释放，都是可以被任一进程使用。每个 IPC 资源都使用一个 32 位的 IPC 关键字和 32 位的 IPC 标识符，前者类似文件系统中的路径名，程序自由定制，后者类似文件描述符，由内核统一分配。多个进程使用同一个 IPC 资源通信时需要该资源的 IPC 标识符。</p><p>创建新的 IPC 资源时需要指定 IPC 关键字，如果没有与之关联的 IPC 资源，则创建一个新的 IPC 资源，如果已经存在，则判断当前进程是否具有访问权限，是否超过资源使用限制等。如果符合条件则返回该资源的 IPC 标识符。为了避免不同的 IPC 资源使用同一个 IPC 关键字，创建时可以指定 IPC 关键字为<code>IPC_PRIVATE</code>，由内核负责生成一个唯一的关键字。</p><p>创建新的 IPC 资源时最后一个参数可以包括三个标志：<code>PC_CREAT</code>说明如果 IPC 资源不存在则必须创建它，<code>IPC_EXCL</code>说明如果资源已经存在且设置了<code>PC_CREAT</code>标志则创建失败，<code>IPC_NOWAIT</code>说明访问 IPC 资源时进程从不阻塞。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量多用于进程间的同步与互斥。</p><ul><li>同步：处理竞争、安排进程执行的先后顺序</li><li>互斥：互斥访问不可共享的临界资源（特殊的同步）</li><li>竞争：当并发进程竞争使用同一个资源时，就称为竞争进程</li></ul><p>共享资源分为两类：</p><ul><li>互斥共享资源，任一时刻只允许一个进程访问该资源</li><li>同步共享资源，同一时刻允许多个进程访问该资源</li></ul><p>信号量是解决互斥共享资源的同步问题而引入的机制。</p><h4 id="信号量的工作机制"><a href="#信号量的工作机制" class="headerlink" title="信号量的工作机制"></a>信号量的工作机制</h4><p>信号量由初值&gt;0，每当有进程申请使用信号量，通过 P 操作对信号量进行-1 操作，当计数器减到 0 时就说明没有资源了，其他进程想要访问就必须等待。当该进程执行完这段工作（临界区）之后，就执行 V 操作对信号量进行+1 操作。</p><ul><li>临界区，一个访问共用资源的程序片段，而这些共用资源又无法被多个线程访问的特性</li><li>临界资源，只能被一个进程同时使用，要用到互斥</li></ul><p>有进程要求使用共享资源时，需要执行以下操作：</p><ol><li>系统检测该资源的信号量</li><li>若信号量的值大于 0，则可以使用该资源，此时进程将该资源的信号量值减一</li><li>若信号量的值为 0，则进程进入等待状态，直到信号量大于 0 时被进程唤醒，访问该资源</li><li>当进程不再使用由一个信号量控制的共享资源时，该信号量的值加一，如果有进程处于等待状态，则该进程会被唤醒</li></ol><h4 id="信号量集的结构"><a href="#信号量集的结构" class="headerlink" title="信号量集的结构"></a>信号量集的结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Data structure describing a set of semaphores.  */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semid_ds</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipc_perm</span> <span class="hljs-title">sem_perm</span>;</span>   <span class="hljs-comment">/* operation permission struct */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sem</span> *<span class="hljs-title">sem_base</span>;</span>       <span class="hljs-comment">/* ptr to array of semaphores in set */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> sem_nsems;   <span class="hljs-comment">/* # of semaphores in set */</span><br>    <span class="hljs-type">time_t</span> sem_otime;           <span class="hljs-comment">/* last-semop() time */</span><br>    <span class="hljs-type">time_t</span> sem_ctime;           <span class="hljs-comment">/* last-change time */</span><br>&#125;;<br><br><span class="hljs-comment">/* Data structure describing each of semaphores.  */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sem</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> semval;  <span class="hljs-comment">/* semaphore value, always &gt;= 0 */</span><br>    <span class="hljs-type">pid_t</span>          sempid;  <span class="hljs-comment">/* pid for last successful semop(), SETVAL, SETALL */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> semncnt; <span class="hljs-comment">/* # processes awaiting semval &gt; curval */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> semzcnt; <span class="hljs-comment">/* # processes awaiting semval == 0 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>结构上示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503251155479.png"></p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是消息的链接表，存放在内核中。一个消息队列由一个标识符来表示，特点如下：</p><ul><li>消息队列是面向记录的，期中的消息具有特定的格式以及特定的优先级</li><li>消息队列独立于发送与接收进程，进程终止时，消息队列及其内容不会被删除</li><li>消息队列可以实现消息的随机查询，消息不一定要按照先进先出的次序读取，也可以按消息的类型读取</li></ul><p>消息队列原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-comment">// 创建或打开消息队列：成功返回队列ID，失败返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">msgget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key, <span class="hljs-type">int</span> flag)</span>;<br><span class="hljs-comment">// 添加消息：成功返回0，失败返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">msgsnd</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> flag)</span>;<br><span class="hljs-comment">// 读取消息：成功返回消息数据的长度，失败返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">msgrcv</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">long</span> type,<span class="hljs-type">int</span> flag)</span>;<br><span class="hljs-comment">// 控制消息队列：成功返回0，失败返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">msgctl</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> msqid_ds *buf)</span>;<br></code></pre></td></tr></table></figure><p>在以下两种情况下，<code>msgget</code>将创建一个新的消息队列：</p><ul><li>如果没有与键值 key 相对应的消息队列，并且 flag 中包含了<code>IPC_CREAT</code>标志位</li><li>key 参数为<code>IPC_PRIVATE</code></li></ul><p>函数<code>msgrcv</code>在读取消息队列时，type 参数有下面几种情况：</p><ul><li><code>type == 0</code>，返回队列中的第一个消息</li><li><code>type &gt; 0</code>，返回队列中消息为 type 的第一个消息</li><li><code>type &lt; 0</code>，返回队列中消息类型值小于或等于 type 绝对值的消息，如果有多个，则取类型值最小的消息</li></ul><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存是 System V 版本的最后一个进程间通信方式。共享内存允许两个不相关的进程访问同一个逻辑内存，是两个正在运行的进程之间共享和传递数据的一种非常有效的方式。不同进程之间共享的内存通常为同一段物理内存。进程可以将同一段物理内存连接到他们自己的地址空间中，所有的进程都可以访问共享内存中的地址。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。</p><p>共享内存并未提供同步机制，在第一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取，所以通常需要用其他的机制来同步对共享内存的访问，例如信号量。</p><h4 id="共享内存的通信原理"><a href="#共享内存的通信原理" class="headerlink" title="共享内存的通信原理"></a>共享内存的通信原理</h4><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/916005-20200620191603410-782893759.png"></p><p>当两个进程通过页表将虚拟地址映射到物理地址时，在物理地址中有一块共同的内存区，即共享内存，这块内存可以被两个进程同时看到。这样当一个进程进行写操作，另一个进程读操作就可以实现进程间通信。但是，要确保一个进程在写的时候不能被读，因此使用信号量来实现同步与互斥。</p><p>对于一个共享内存，实现采用的是引用计数的原理，当进程脱离共享存储区后，计数器减一，挂架成功时，计数器加一，只有当计数器变为零时，才能被删除。当进程终止时，它所附加的共享存储区都会自动脱离。</p><h4 id="共享内存的接口函数以及指令"><a href="#共享内存的接口函数以及指令" class="headerlink" title="共享内存的接口函数以及指令"></a>共享内存的接口函数以及指令</h4><p>查看系统中的共享存储段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ipcs -m<br></code></pre></td></tr></table></figure><p>删除系统中的共享存储段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ipcrm -m [shmid]<br></code></pre></td></tr></table></figure><hr><p>shmget ( )：创建共享内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">shmget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> shmflg)</span>;<br></code></pre></td></tr></table></figure><p><strong>[参数 key]</strong>：由 ftok 生成的 key 标识，标识系统的唯一 IPC 资源。</p><p><strong>[参数 size]</strong>：需要申请共享内存的大小。在操作系统中，申请内存的最小单位为页，一页是 4k 字节，为了避免内存碎片，我们一般申请的内存大小为页的整数倍。</p><p><strong>[参数 shmflg]</strong>：如果要创建新的共享内存，需要使用 IPC_CREAT，IPC_EXCL，如果是已经存在的，可以使用 IPC_CREAT 或直接传 0。</p><p><strong>[返回值]</strong>：成功时返回一个新建或已经存在的的共享内存标识符，取决于 shmflg 的参数。失败返回-1 并设置错误码。</p><hr><p>shmat ( )：挂接共享内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">shmat</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr, <span class="hljs-type">int</span> shmflg)</span>;<br></code></pre></td></tr></table></figure><p><strong>[参数 shmid]</strong>：共享存储段的标识符。</p><p><strong>[参数*shmaddr]</strong>：shmaddr &#x3D; 0，则存储段连接到由内核选择的第一个可以地址上。</p><p><strong>[参数 shmflg]</strong>：若指定了 SHM_RDONLY 位，则以只读方式连接此段，否则以读写方式连接此段。</p><p><strong>[返回值]</strong>：成功返回共享存储段的指针（虚拟地址），并且内核将使其与该共享存储段相关的 shmid_ds 结构中的 shm_nattch 计数器加 1（类似于引用计数）；出错返回-1。</p><hr><p>shmdt ( )：去关联共享内存</p><p>当一个进程不需要共享内存的时候，就需要去关联。该函数并不删除所指定的共享内存区，而是将之前用 shmat 函数连接好的共享内存区脱离目前的进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">shmdt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr)</span>;<br></code></pre></td></tr></table></figure><p><strong>[参数*shmaddr]</strong>：连接以后返回的地址。</p><p><strong>[返回值]</strong>：成功返回 0，并将 shmid_ds 结构体中的 shm_nattch 计数器减 1；出错返回-1。</p><hr><p>shmctl ( )：销毁共享内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">shmctl</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> shmid_ds *buf)</span>;<br></code></pre></td></tr></table></figure><p><strong>[参数 shmid]</strong>：共享存储段标识符。</p><p><strong>[参数 cmd]</strong>：指定的执行操作，设置为 IPC_RMID 时表示可以删除共享内存。</p><p><strong>[参数*buf]</strong>：设置为 NULL 即可。</p><p><strong>[返回值]</strong>：成功返回 0，失败返回-1。</p><h3 id="POSIX-消息队列"><a href="#POSIX-消息队列" class="headerlink" title="POSIX 消息队列"></a>POSIX 消息队列</h3><p>POSIX 消息队列是 POSIX 标准在 2001 年定义的一种 IPC 机制，与 System V 中的消息队列相比有如下差异：</p><ul><li>更简单的基于文件的应用接口，Linux 通过 mqueue 的特殊文件系统来实现消息队列，队列名跟文件名类似，必须以”&#x2F;“开头，每个消息队列在文件系统内都有一个对应的索引节点，返回的队列描述符实际是一个文件描述符</li><li>完全支持消息优先级，消息在队列中是按照优先级倒序排列的(即 0 表示优先级最低)。当一条消息被添加到队列中时，它会被放置在队列中具有相同优先级的所有消息之后。如果一个应用程序无需使用消息优先级，那么只需要将 msg_prio 指定为 0 即可。</li><li>完全支持消息到达的异步通知，当新消息到达且当前队列为空时会通知之前注册过表示接受通知的进程。在任何一个时刻都只有一个进程能够向一个特定的消息队列注册接收通知。如果一个消息队列上已经存在注册进程了，那么后续在该队列上的注册请求将会失败。可以给进程发送信号或者另起一个线程调用通知函数完成通知。当通知完成时，注册即被撤销，进程需要继续接受通知则必须重新注册。</li><li>用于阻塞发送与接收操作的超时机制，可以指定阻塞的最长时间，超时自动返回。</li></ul><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>套接字是更为基础的进程间通信机制，与其他方式不同的是，套接字可用于不同机器之间的进程间通信。</p><p>有两种类型的套接字：基于文件的和面向网络的：</p><ul><li>Unix 套接字是基于文件的，并且拥有一个“家族名字”–AF_UNIX，它代表地址家族 (address family)：UNIX</li><li>第二类型的套接字是基于网络的，它也有自己的家族名字–AF_INET，代表地址家族 (address family):INTERNET</li></ul><p>不管采用哪种地址家族，都有两种不同的套接字连接：面向连接的和无连接的：</p><ul><li>面向连接的套接字 (SOCK_STREAM)：进行通信前必须建立一个连接，面向连接的通信提供序列化的、可靠地和不重复的数据交付，而没有记录边界。<br>这意味着每条信息可以被拆分成多个片段，并且每个片段都能确保到达目的地，然后在目的地将信息拼接起来。<br>实现这种连接类型的主要协议是传输控制协议 (TCP)。</li><li>无连接的套接字 (SOCK_DGRAM)：在通信开始之前并不需要建立连接，在数据传输过程中并无法保证它的顺序性、可靠性或重复性。<br>然而,数据报确实保存了记录边界,这就意味着消息是以整体发送的,而并非首先分成多个片段。<br>由于面向连接的套接字所提供的保证，因此它们的设置以及对虚拟电路连接的维护需要大量的开销。然而,数据报不需要这些开销,即它的成本更加“低廉”。<br>实现这种连接类型的主要协议是用户数据报协议 (UDP)。</li></ul><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，进程不必通过任何操作来等待信号的到达。信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件。</p><h4 id="信号来源"><a href="#信号来源" class="headerlink" title="信号来源"></a>信号来源</h4><p>信号事件的发生有两个来源：</p><ul><li>硬件来源，比如我们按下了键盘或者其它硬件故障</li><li>软件来源，最常用发送信号的系统函数是 kill, raise, alarm 和 setitimer 以及 sigqueue 函数，软件来源还包括一些非法运算等操作。</li></ul><h4 id="进程对信号的响应"><a href="#进程对信号的响应" class="headerlink" title="进程对信号的响应"></a>进程对信号的响应</h4><p>进程可以通过三种方式来响应信号：</p><ul><li>忽略信号，即对信号不做任何处理，但是有两个信号是不能忽略的：SIGKLL 和 SIGSTOP</li><li>捕捉信号，定义信号处理函数，当信号发生时，执行相应的处理函数</li><li>执行缺省操作，Linux 对每种信号都规定了默认操作</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>逆向</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树和二叉树</title>
    <link href="/2025/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2025/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><p>树结构是一类非常重要的<strong>非线性数据结构</strong>，是以分支关系定义的层次结构，在各个领域都得到广泛的运用。</p><h2 id="树和二叉树的定义"><a href="#树和二叉树的定义" class="headerlink" title="树和二叉树的定义"></a>树和二叉树的定义</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p>树是 n 个结点的有限集。对于非空树，有以下特点：</p><ul><li>有且只有一个称为<strong>根</strong>的结点。</li><li>除根结点以外的其余结点可分为 m 个互不相交的有限集 T1,T2…,Tn ，其中每一个集合本身又是一棵树，并且称为根的<strong>子树</strong>。（递归定义初见端倪）</li></ul><p>树的结构定义是一个递归的定义，这道出了树的固有特性。</p><p>树还可以有其他的表现形式，如嵌套集合、广义表、凹入表示法等等。一般来说分等级的分类方案都可用层次结构来表示，即都可由一个树结构来表示。</p><h3 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h3><p>TODO</p><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><p>二叉树是 n 个结点所构成的集合，对于非空树，有以下特点（以下是二叉树的结构特性）：</p><ul><li>有且仅有一个称为根的结点。</li><li>除根结点以外的其余结点分为两个互不相交的子集 T1 和 T2，分别称为 T 的左子树和右子树，且 T1 和 T2 本身又都是二叉树。</li></ul><p>二叉树和树有很多共同的性质，其与树的区别主要有以下两点（以下是二叉树独有的特性）：</p><ol><li>二叉树每个结点至多有两个子树（二叉树中不能存在有度数大于 2 的结点）。</li><li>二叉树的子树有左右之分，次序不能颠倒。</li></ol><h2 id="树和二叉树的抽象数据类型定义"><a href="#树和二叉树的抽象数据类型定义" class="headerlink" title="树和二叉树的抽象数据类型定义"></a>树和二叉树的抽象数据类型定义</h2><p>树的抽象数据类型定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">TODO<br></code></pre></td></tr></table></figure><p>二叉树的抽象数据类型定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TODO<br></code></pre></td></tr></table></figure><h2 id="二叉树的性质和存储结构"><a href="#二叉树的性质和存储结构" class="headerlink" title="二叉树的性质和存储结构"></a>二叉树的性质和存储结构</h2><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>其中又有两种特殊形态的二叉树，分别是满二叉树和完全二叉树。</p><p><strong>满二叉树</strong>：深度为 k 且含有 2k-1 个结点的二叉树。</p><p>满二叉树的特点：每层上的结点数都是最大结点数，即每层 i 的结点数都具有最大值 2i-1。</p><p>在对满二叉树进行编号，规则是从上到下、从左到右、从根结点开始，这样便有完全二叉树的定义。</p><p><strong>完全二叉树</strong>：深度为 k，有 n 个结点的二叉树，当且仅当每一个结点都与深度为 k 的满二叉树中编号从 1 到 n 的结点一一对应时，称为完全二叉树。</p><p>人话说就是：最后一层允许不填满，但结点必须靠左填充。高度为 h 的完全二叉树，结点数范围是 2h-1 &lt;&#x3D; 2h-1。</p><p>完全二叉树的特点：</p><ol><li>叶子结点只可能在层次最大的两层上出现。</li><li>对于任一结点，若其右分枝下的子孙最大层次为 l，则其左下分枝的子孙的最大层次必为 l 或 l + 1。</li></ol><p>二叉树的性质主要有以下几点：</p><ol><li>在二叉树的第 i 层上至多有 2i-1 个结点。</li><li>深度为 k 的二叉树至多有 2k-1 个结点。</li><li>对任何一颗二叉树 T，如果其终端结点数为 n0，度为 2 的结点数为 n2，则 n0 &#x3D; n2 + 1。</li><li>具有 n 个结点的完全二叉树的深度为 log2[n] + 1。</li><li>如果对一颗有 n 个结点的完全二叉树的结点按层序编号，则对任一结点 i，有：<ol><li>如果 i &#x3D; 1，则结点 i 是二叉树的根，无双亲；如果 i &gt; 1，则双亲 PARENT(i) 是结点 [i]。</li><li>如果 2i &gt; n，则结点 i 无左孩子（即结点 i 是叶子结点）；否则左孩子 LCHILD(i) 是结点 2i。</li><li>如果 2i + 1 &gt; n，则结点 i 无右孩子；否则有孩子 RCHILD(i) 是结点 2i + 1。</li></ol></li></ol><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p>二叉树的存储结构可以采用顺序存储或链式存储两种方式。</p><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXTSIZE 100                   <span class="hljs-comment">//二叉树的最大结点数</span></span><br><span class="hljs-keyword">typedef</span> TElemType SqBiTree[MAXTSIZE];  <span class="hljs-comment">//0 号单元存储根结点</span><br>SqBiTree bt;<br></code></pre></td></tr></table></figure><p>顺序存储结构要求二叉树中的结点按照一定规律存储进去，对于完全二叉树或满二叉树，只要从根结点按层存储即可。</p><p>然而对于一般的二叉树，要使用 “0” 将其补全为完全二叉树才可以进行存储。这样会造成极大的存储空间浪费。</p><p>由此，顺序存储更适合完全二叉树，对于一般的二叉树，更适合用链式存储结构。</p><h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><p>不同的结点结构可以构成不同形式的链式存储结构。二叉树的结点由一个数据域和指向左右子树的两个分支构成，由此至少要包含三个域：数据域和左、右指针域。如果想要便捷的找到双亲，还可以添加一个指向双亲结点的指针域。这样的存储结构被称为二叉链表和三叉链表。</p><p>有一个结论是：在含有 n 个结点的二叉链表中由 n + 1 个空链域。后面可以用这些空链域存储其他信息，这就是线索链表的由来。</p><p>由于有不同的存储结构，二叉树的各种实现方法也不同（例如查找双亲）。在具体应用中选择结构时，不仅要考虑二叉树的形态，还要考虑进行何种操作。</p><p>以下是二叉链表形式表现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>&#123;<br>    TElemType data;                  <span class="hljs-comment">//结点指针域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> *lchild,*rchild;  <span class="hljs-comment">//左右孩子指针</span><br>&#125;BiTNode,*BiTNode;<br></code></pre></td></tr></table></figure><h2 id="遍历二叉树和线索二叉树"><a href="#遍历二叉树和线索二叉树" class="headerlink" title="遍历二叉树和线索二叉树"></a>遍历二叉树和线索二叉树</h2><p>线索二叉树是在第一次遍历时将结点的前驱、后继信息存储下来，便于再次遍历二叉树。</p><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><h4 id="遍历二叉树算法描述"><a href="#遍历二叉树算法描述" class="headerlink" title="遍历二叉树算法描述"></a>遍历二叉树算法描述</h4><p>遍历二叉树是二叉树最基本的操作。遍历的实质是对二叉树进行线性化的过程，遍历的结果是将非线性结构的树中结点排成一个线性序列。</p><p>由于二叉树是由 3 个基本单元组成：根节点、左子树和右子树。因此，如果能依次遍历这三个部分，便可以遍历整个二叉树。</p><p>根据遍历的顺序不同，可以有六种不同的遍历方案，如果限定先左后右，则有三种情况：</p><ul><li>先序遍历：根结点-&gt;先序遍历左子树-&gt;先序遍历右子树</li><li>中序遍历：中序遍历左子树-&gt;根节点-&gt;先序遍历右子树</li><li>后序遍历：后序遍历左子树-&gt;后序遍历右子树-&gt;根节点</li></ul><p>3种遍历算法不同处仅在于访问根结点和遍历左、右子树的先后关系。</p><p>以下是中序遍历二叉树基本操作的递归算法在二叉链表上的表现，算法将结点的访问简化成数据的输出：</p><h5 id="中序遍历二叉树基本操作的递归算法"><a href="#中序遍历二叉树基本操作的递归算法" class="headerlink" title="中序遍历二叉树基本操作的递归算法"></a>中序遍历二叉树基本操作的递归算法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(Bitree T)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//中序遍历二叉树T的递归算法</span><br>    <span class="hljs-keyword">if</span>(T)                            <span class="hljs-comment">//若二叉树非空</span><br>    &#123;<br>        <span class="hljs-built_in">InOrderTraverse</span>(T-&gt;lchild);  <span class="hljs-comment">//中序遍历左子树</span><br>        cout &lt;&lt; T-&gt;data;             <span class="hljs-comment">//访问根结点</span><br>        <span class="hljs-built_in">InOrderTraverse</span>(T-&gt;rchild);  <span class="hljs-comment">//中序遍历右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时，可以利用栈将递归算法改写成非递归算法。从中序遍历递归算法执行过程中递归工作栈的状态如下：</p><ol><li>工作记录中包含两项，其一是递归调用的语句编号，其二是指向根结点的指针， 则当栈顶记录中的指针非空时，应遍历左子树，即指向左子树根的指针进栈；</li><li>若栈顶记录中的指针值为空，则应退至上一层，若是从左子树返回，则应访问当前层（即栈顶记录）中指针所指的根结点；</li><li>若是从右子树返回，则表明当前层的遍历结束，应继续退栈。从另一个角度看，这意味着遍历右子树时不再需要保存当前层的根指针，直接修改栈顶记录中的指针即可。</li></ol><p>以下是中序遍历的非递归算法：</p><h5 id="中序遍历的非递归算法"><a href="#中序遍历的非递归算法" class="headerlink" title="中序遍历的非递归算法"></a>中序遍历的非递归算法</h5><p><strong>算法步骤</strong></p><ol><li>初始化一个空栈 S，指针 p 指向根结点。</li><li>申请一个结点空间 q，用来存放栈顶弹出的元素。</li><li>当 p 非空或者栈 S 非空时，循环执行以下操作：<ul><li>如果 p 非空，则将 p 进栈，p 指向该节点的左孩子。</li><li>如果 p 为空，则弹出栈顶元素并访问，将 p 指向该结点的右孩子。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//中序遍历二叉树 T 的非递归算法</span><br>    <span class="hljs-built_in">InitStack</span>(S);<br>    p = T;<br>    <span class="hljs-keyword">while</span>(p||!<span class="hljs-built_in">StackEmpty</span>(S))<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p)                 <span class="hljs-comment">// p 非空</span><br>        &#123;<br>            <span class="hljs-built_in">Push</span>(S, p);       <span class="hljs-comment">// 根指针进栈</span><br>            p = p-&gt;lchild;    <span class="hljs-comment">// 根指针进栈，遍历左子树</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>                  <span class="hljs-comment">// p 为空</span><br>        &#123;<br>            <span class="hljs-built_in">Pop</span>(S, q);        <span class="hljs-comment">// 退栈</span><br>            cout&lt;&lt;q-&gt;data;    <span class="hljs-comment">// 访问根结点</span><br>            p = q-&gt;rchild;    <span class="hljs-comment">// 遍历右子树</span><br>        &#125;<br>    &#125;                         <span class="hljs-comment">// while</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504101952092.png"></p><p><strong>算法分析</strong></p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><h4 id="根据遍历序列确定二叉树"><a href="#根据遍历序列确定二叉树" class="headerlink" title="根据遍历序列确定二叉树"></a>根据遍历序列确定二叉树</h4><p>由二叉树的先序序列和中序序列，或由后序序列和中序序列均能唯一的确定一颗二叉树。</p><p>但是一颗二叉树的先序序列和后序序列不能唯一确定一颗二叉树，因为无法确定左右子树两部分。</p><h4 id="二叉树遍历算法的应用"><a href="#二叉树遍历算法的应用" class="headerlink" title="二叉树遍历算法的应用"></a>二叉树遍历算法的应用</h4><p>＂遍历” 是二叉树各种操作的基础。</p><h5 id="（1）创建二叉树的存储结构"><a href="#（1）创建二叉树的存储结构" class="headerlink" title="（1）创建二叉树的存储结构"></a>（1）创建二叉树的存储结构</h5><p><strong>算法步骤</strong></p><ol><li><p>扫描字符序列，读入字符 ch。</p></li><li><p>如果 ch 是一个 “#” 字符，则表明该二叉树为空树，即 T 为 NULL；否则执行 以下操作：</p><ul><li>申请一个结点空间 T</li><li>将 ch 赋给 T-&gt;data</li><li>递归创建 T 的左子树</li><li>递归创建 T 的右子树</li></ul></li></ol><p><strong>算法描述</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree &amp;T)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//按先序次序输入二叉树中结点的值（一个字符，创建二叉链表表示的二叉树 T）</span><br>    cin&gt;&gt;ch;<br>    <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;#&#x27;</span>)                 <span class="hljs-comment">// 递归结束，建空树</span><br>        T=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        T = <span class="hljs-keyword">new</span> BiTNode;          <span class="hljs-comment">//生成根结点</span><br>        T-&gt;data = ch;             <span class="hljs-comment">//根结点数据域置为 ch</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);  <span class="hljs-comment">//递归创建左子树</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);  <span class="hljs-comment">//递归创建右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="（2）复制二叉树"><a href="#（2）复制二叉树" class="headerlink" title="（2）复制二叉树"></a>（2）复制二叉树</h5><p>复制步骤：若二叉树不空， 则首先复制根结点， 这相当于二叉树先序遍历算法中访问根结点的语句；然后分别复制二叉树根结点的左子树和右子树， 这相当千先序遍历中递归遍历左子树和右子树的语句。因此， 复制函数的实现与二叉树先序遍历的实现非常类似。</p><p><strong>算法步骤</strong></p><p>如果是空树，递归结束，否则执行以下操作：</p><ul><li>申请一个新结点空间， 复制根结点。</li><li>递归复制左子树。</li><li>递归复制右子树。</li></ul><p><strong>算法描述</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Copy</span><span class="hljs-params">(BiTree T,BiTree &amp;NewT)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>)                      <span class="hljs-comment">// 如果是空树，递归结束</span><br>    &#123;<br>        NewT = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        NewT = <span class="hljs-keyword">new</span> BiTree;<br>        NewT-&gt;data = T-&gt;data;          <span class="hljs-comment">// 复制根结点</span><br>        <span class="hljs-built_in">Copy</span>(T-&gt;lchild,NewT-&gt;lchild);  <span class="hljs-comment">// 递归复制左子树</span><br>        <span class="hljs-built_in">Copy</span>(T-&gt;rchild,NewT-&gt;rchild);  <span class="hljs-comment">// 递归复制右子树</span><br>    &#125;                                  <span class="hljs-comment">// else</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="（3）计算二叉树的深度"><a href="#（3）计算二叉树的深度" class="headerlink" title="（3）计算二叉树的深度"></a>（3）计算二叉树的深度</h5><p>二叉树的深度为树中结点的最大层次， 二叉树的深度为左右子树深度的较大者加1。</p><p><strong>算法步骤</strong></p><p>如果是空树， 递归结束， 深度为0, 否则执行以下操作：</p><ul><li>递归计算左子树的深度记为m。</li><li>递归计算右子树的深度记为n。</li><li>如果m 大于 n, 二叉树的深度为m+1，否则为n+1。</li></ul><p><strong>算法描述</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Depth</span><span class="hljs-params">(BiTree T)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// 计算二叉树T的深度</span><br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>)                <span class="hljs-comment">// 如果是空树，深度为0, 递归结束</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        m = <span class="hljs-built_in">Depth</span>(T-&gt;lchild);  <span class="hljs-comment">// 递归计算左子树的深度记为m</span><br>        n = <span class="hljs-built_in">Depth</span>(T-&gt;rchild);  <span class="hljs-comment">// 递归计算右子树的深度记为n</span><br>        <span class="hljs-keyword">if</span>(m&gt;n)                <span class="hljs-comment">// 二叉树的深度为m与n的较大者加1</span><br>            <span class="hljs-keyword">return</span>(m<span class="hljs-number">+1</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">return</span>(n<span class="hljs-number">+1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>计算二叉树的深度是在后序遍历二叉树的基础上进行的运算。</p><h5 id="4-统计二叉树中结点个数"><a href="#4-统计二叉树中结点个数" class="headerlink" title="(4)统计二叉树中结点个数"></a>(4)统计二叉树中结点个数</h5><p>如果是空树，则结点个数为0；否则，结点个数为左子树的结点个数加上右子树的结点个数再加上1。</p><p><strong>算法描述</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NodeCount</span><span class="hljs-params">(BiTree T)</span></span><br><span class="hljs-function">｛<span class="hljs-comment">//统计二叉树T中结点的个数</span></span><br><span class="hljs-function"><span class="hljs-title">if</span> <span class="hljs-params">(T==<span class="hljs-literal">NULL</span>)</span>   <span class="hljs-comment">// 如果是空树，则结点个数为0, 递归结束</span></span><br><span class="hljs-function">        <span class="hljs-keyword">return</span> O</span>;<br><span class="hljs-keyword">else</span>           <span class="hljs-comment">// 否则结点个数为左子树的结点个数＋右子树的结点个数+l</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">NodeCount</span>(T-&gt;lchild) + <span class="hljs-built_in">NodeCount</span>(T-&gt;rchild) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><h4 id="线索二叉树的基本概念"><a href="#线索二叉树的基本概念" class="headerlink" title="线索二叉树的基本概念"></a>线索二叉树的基本概念</h4><p>线索二叉树用于解决以二叉链表存储的二叉树无法找到任一结点的前驱、后驱信息的缺点。</p><p>如果在每个结点增加两个指针域存放遍历得到的前后驱信息，则会使存储密度大大降低，同时因为有 n 个结点的二叉链表中必定存在 n+1 个空链域，因此可以使用这些空链域存储结点的前后驱信息。</p><p>若结点有左子树，则其 lchild 域指示其左孩子，否则令 lchild 域指示其前驱；若结点有右子树，则其 rchild 域指示其右孩子，否则令 rchild 域指示其后继。为了避免混淆，尚需改变结点结构，增加两个标志域：</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504102052545.png"></p><p>其中 LTag&#x3D;0 表示 lchild 指示结点的左孩子，否则指示结点的前驱，RTag 同理。</p><p>二叉树的二叉线索类型定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiThrNode</span><br>｛<br>TElemType data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiThrNode</span> *lchild,*rchild;  <span class="hljs-comment">// 左右孩子指针</span><br><span class="hljs-type">int</span> LTag, RTag;                    <span class="hljs-comment">// 左右标志</span><br>) BiThrNode,*BiThrTree;<br></code></pre></td></tr></table></figure><p>这叫做线索链表，其中指向结点前驱和后继的指针，叫做线索。加上线索的二叉树称为线索二叉树。对二叉树以某种次序遍历使其变为线索二叉树的过程叫做线索化。</p><h4 id="构造线索二叉树"><a href="#构造线索二叉树" class="headerlink" title="构造线索二叉树"></a>构造线索二叉树</h4><p>线索化的过程即为在遍历的过程中修改空指针的过程，可以使用递归算法。对二叉树按照不同的遍历次序进行线索化，可以得到不同的线索二叉树，包括先序线索二叉树、中序线索二叉树和后序线索二叉树。</p><p>以下是中序线索化的算法：</p><p>使用一个指针 pre 始终指向刚刚访问过的结点，另一个指针 p 指向当前访问的结点，这样可以记录遍历过程中访问结点的先后关系。</p><h5 id="以结点-p-为根的子树中序线索化"><a href="#以结点-p-为根的子树中序线索化" class="headerlink" title="以结点 p 为根的子树中序线索化"></a>以结点 p 为根的子树中序线索化</h5><p><strong>算法步骤</strong></p><ol><li>如果 p 非空，左子树递归线索化。</li><li>如果 p 的左孩子为空，则给 p 加上左线索，将其 LTag 置为 1，让 p 的左孩子指针指向 pre（前驱）；否则将 p 的 LTag 置为 0。</li><li>如果 pre 的右孩子为空，则给 pre 加上右线索，将其 RTag 置为 1，让 pre 的右孩子指针指向 p (后继）；否则将 pre 的 RTag 置为 0。</li><li>将 pre 指向刚访问过的结点 p , 即 pre&#x3D;p。</li><li>右子树递归线索化。</li></ol><p><strong>算法描述</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InThreading</span><span class="hljs-params">(BiThrTree p)</span> </span>&#123;<br><span class="hljs-comment">// pre 是全局变量，初始化时其右孩子指针为空，便于在树的最左点开始建线索</span><br><span class="hljs-keyword">if</span>(p) &#123;<br><span class="hljs-built_in">InThreading</span>(p-&gt;lchild);  <span class="hljs-comment">// 左子树递归线索化</span><br><br><span class="hljs-keyword">if</span>(!p-&gt;lchild) &#123;         <span class="hljs-comment">// p 的左孩子为空</span><br>p-&gt;LTag = <span class="hljs-number">1</span>;         <span class="hljs-comment">// 给 p 加上线索</span><br>p-&gt;lchild = pre;     <span class="hljs-comment">// p 的左孩子指针指向 pre（前驱）</span><br>&#125;                        <span class="hljs-comment">// if</span><br><span class="hljs-keyword">else</span><br>p-&gt;LTag = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span>(!pre-&gt;rchild) &#123;       <span class="hljs-comment">// pre 的右孩子为空</span><br>pre-&gt;RTag = <span class="hljs-number">1</span>;       <span class="hljs-comment">// 给 pre 加上线索</span><br>pre-&gt;rchild = p;     <span class="hljs-comment">// pre 的右孩子指针指向 p（后继）</span><br>&#125;                        <span class="hljs-comment">// if</span><br><span class="hljs-keyword">else</span><br>p-&gt;RTag = <span class="hljs-number">0</span>;<br><br>pre = p;                 <span class="hljs-comment">// 保持 pre 指向 p 的前驱</span><br><span class="hljs-built_in">InTreading</span>(p-&gt;rchild);   <span class="hljs-comment">// 右子树递归线索化</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="带头节点的二叉树中序线索化"><a href="#带头节点的二叉树中序线索化" class="headerlink" title="带头节点的二叉树中序线索化"></a>带头节点的二叉树中序线索化</h5><p><strong>算法描述</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrderThreading</span><span class="hljs-params">(BiThrTree &amp;Thrt, BiThrTree T)</span> </span>&#123;<span class="hljs-comment">// 中序遍历二叉树 T，并将其中序线索化，Thrt 指向头节点</span><br>Thrt = <span class="hljs-keyword">new</span> BiThrNode;     <span class="hljs-comment">// 建头节点</span><br>Thrt-&gt;LTag = <span class="hljs-number">0</span>;           <span class="hljs-comment">// 头节点有左孩子，若树非空，则其左孩子为树根</span><br>Thrt-&gt;RTag = <span class="hljs-number">1</span>;           <span class="hljs-comment">// 头节点的右孩子为右线索</span><br>Thrt-&gt;rchild = Thrt;      <span class="hljs-comment">// 初始化时右指针指向自己</span><br><br><span class="hljs-keyword">if</span>(!T)                    <span class="hljs-comment">// 若树为空，则左指针也指向自己</span><br>Thrt-&gt;lchild = Thrt;<br><span class="hljs-keyword">else</span> &#123;<br>Thrt-&gt;lchild = T;     <span class="hljs-comment">// 头节点的左孩子指向树根，pre 初值指向头节点</span><br>pre = Thrt;<br><span class="hljs-built_in">InThreading</span>(T);       <span class="hljs-comment">// 调用算法 InThreading()，对以 T 为根的二叉树进行中序线索化</span><br>pre-&gt;rchild = Thrt;   <span class="hljs-comment">// 算法 InThreading() 结束后，pre 为最右结点，pre 的右线索指向头节点</span><br>pre-&gt;RTag = <span class="hljs-number">1</span>;<br>Thrt-&gt;rchild = pre;   <span class="hljs-comment">// 头节点的右线索指向 pre</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="遍历线索二叉树"><a href="#遍历线索二叉树" class="headerlink" title="遍历线索二叉树"></a>遍历线索二叉树</h4><p>由于有了结点的前驱和后继，线索二叉树的遍历和在指定次序下查找结点的前驱和后驱算法都变得简单。由此，如果经常需要查找结点在所遍历线性序列中的前驱和后继，则采用线索链表作为存储结构。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504141448617.png"></p><p>在先序线索化树上找前驱或在后序线索化树上找后继时都比较复杂，此时若需要，可直接建立含4个指针的线索链表。</p><h5 id="遍历中序线索二叉树"><a href="#遍历中序线索二叉树" class="headerlink" title="遍历中序线索二叉树"></a>遍历中序线索二叉树</h5><p><strong>算法步骤</strong></p><ol><li>指针 p 指向根结点</li><li>p 为非空树或遍历未结束时，循环执行以下操作：<ul><li>沿左孩子向下，到达最左下结点 *p ，它是中序的第一个结点</li><li>访问 *p</li><li>沿右线索反复查找当前结点 *p 的后继结点并访问后继结点，直至右线索为0或遍历结束</li><li>转向 p 的右子树</li></ul></li></ol><p><strong>算法描述</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrderTraverse_Thr</span><span class="hljs-params">(BiThrTree T)</span> </span>&#123;<br>p = T-&gt;lchild;<br><br><span class="hljs-keyword">while</span>(p != T) &#123;<br><span class="hljs-keyword">while</span>(p-&gt;LTag == <span class="hljs-number">0</span>) &#123;<br>p = p-&gt;lchild;<br>&#125;<br><br>cout &lt;&lt; p-&gt;data;<br><br><span class="hljs-keyword">while</span>(p-&gt;RTag == <span class="hljs-number">1</span> &amp;&amp; p-&gt;rchild != T) &#123;<br>p = p-&gt;rchild;<br>cout &lt;&lt; p-&gt;data;<br>&#125;<br><br>p = p-&gt;child;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历线索二叉树的时间复杂度为O(n), 空间复杂度为0(1), 这是因为线索二叉树的遍历不需要使用栈来实现递归操作。</p><h2 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h2><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><p>树有以下三种常见的存储结构：</p><ul><li>双亲表示法</li><li>孩子表示法</li><li>孩子兄弟法</li></ul><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><p>一组连续的存储单元存储树的结点，每个结点包括数据域 data 和指示双亲结点的域 parent。</p><p>这种存储结构利用了每个结点只有唯一双亲的性质，求树根很容易，但求结点的孩子则需要遍历整个结构。</p><h4 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h4><p>由于每个结点可能有多棵子树，则使用多重链表，即每个结点有多个指针域，每个指针指向一棵子树的根节点。</p><p>链表中的结点可以使用两种方式：</p><ol><li>多重链表的结点是同构的，但由于很多结点的度小于树的度，因此会浪费大量的空间，及其浪费空间。</li><li>多重链表的结点不同构，有多少度就设置多少空间，但需要加一个 degree 域存储结点的度，这样虽然节省空间，但是操作很不方便。</li></ol><p>与双亲表示法相反， 孩子表示法便于那些涉及孩子的操作的实现。可以把双亲表示法和孩子表示法结合起来，即将双亲表示和孩子链表合在一起。</p><h4 id="孩子兄弟法"><a href="#孩子兄弟法" class="headerlink" title="孩子兄弟法"></a>孩子兄弟法</h4><p>又称二叉树表示法，或二叉链表表示法，即以二叉链表做树的存储结构。</p><p>链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点，分别命名为firstchild 域和nextsibling域。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504141514598.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span> &#123;<br>ElemType data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span> *firstchild,*nextsibling;<br>&#125; CSNode,*CSTree;<br></code></pre></td></tr></table></figure><p>利用这种存储结构便千实现各种树的操作。首先易于实现找结点孩子等的操作。例如，若要访问结点 x 的第 i 个孩子，则只要先从 firstchild 域找到第 1 个孩子结点，然后沿着孩子结点的 nextsibling 域连续走 i-1 步，便可找到 x 的第 i 个孩子。当然，如果为每个结点增设一个 parent 域，则同样能方便地实现查找双亲的操作。</p><p>这种存储结构的优点是它和二叉树的二叉链表表示完全一样， 便千将一般的树结构转换为二叉树进行处理， 利用二叉树的算法来实现对树的操作。因此孩子兄弟表示法是应用较为普遍的一种树的存储表示方法。</p><h3 id="森林与二叉树的转换"><a href="#森林与二叉树的转换" class="headerlink" title="森林与二叉树的转换"></a>森林与二叉树的转换</h3><p>任何一棵和树对应的二叉树，其根结点的右子树必空。若把森林中第二棵树的根结点看成是第一棵树的根结点的兄弟，则同样可导出森林和二叉树的对应关系。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504141533489.png"></p><h3 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h3><h4 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h4><p>存在两种遍历树的方法：</p><ol><li>先根遍历树：先访问树的根节点，然后依次先根遍历根的每棵子树。</li><li>后根遍历：先依次后根遍历每棵子树，然后访问根节点。</li></ol><h4 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h4><ol><li>先序遍历森林：<ol><li>访问森林中第一棵树的根节点</li><li>先序遍历第一棵树的根节点的子树森林</li><li>先序遍历除去第一棵树之后剩余树构成的森林</li></ol></li><li>中序遍历森林：<ol><li>中序遍历森林中第一棵树的根节点的子树森林</li><li>访问第一棵树的根结点</li><li>中序遍历除去第一棵树之后剩余的树构成的森林</li></ol></li></ol><h2 id="哈夫曼树及其应用"><a href="#哈夫曼树及其应用" class="headerlink" title="哈夫曼树及其应用"></a>哈夫曼树及其应用</h2><h3 id="哈夫曼树的基本概念"><a href="#哈夫曼树的基本概念" class="headerlink" title="哈夫曼树的基本概念"></a>哈夫曼树的基本概念</h3><p>哈夫曼(Huffman)树又称最优树，是一类带权路径长度最短的树。</p><ul><li>路径：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。</li><li>路径长度：路径上的分支数目称作路径长度。</li><li>树的路径长度：从树根到每一结点的路径长度之和。</li><li>权：赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述。</li><li>结点的带权路径长度：从该结点到树根之间的路径长度与结点上权的乘积。</li><li>树的带权路径长度：树中所有叶子结点的带权路径长度之和，通常记作 WPL。</li><li>哈夫曼树：带权路径长度 WPL 最小的二叉树称做最优二叉树或哈夫曼树。</li></ul><p>在哈夫曼树中，权值越大的结点离根结点越近。</p><h3 id="哈夫曼树的构造算法"><a href="#哈夫曼树的构造算法" class="headerlink" title="哈夫曼树的构造算法"></a>哈夫曼树的构造算法</h3><h4 id="哈夫曼树的构造过程"><a href="#哈夫曼树的构造过程" class="headerlink" title="哈夫曼树的构造过程"></a>哈夫曼树的构造过程</h4><ol><li>根据给定的n个权值{w1,w2,…,wn}，构造n棵只有根结点的二叉树，这 n 棵二叉树构成一个森林F。</li><li>在森林 F 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和。</li><li>在森林 F 中删除这两棵树，同时将新得到的二叉树加入 F 中。</li><li>重复2、3，直到 F 只含一棵树为止，这棵树就是哈夫曼树。</li></ol><p>这种算法是一种典型的贪心法。</p><h4 id="哈夫曼算法的实现"><a href="#哈夫曼算法的实现" class="headerlink" title="哈夫曼算法的实现"></a>哈夫曼算法的实现</h4><p>哈夫曼树是一种二叉树，但由千哈夫曼树中没有度为 1 的结点，则一棵有n 个叶子结点的哈夫曼树共有 2n-1 个结点，可以存储在一个大小为 2n-1 的一维数组中。树中每个结点还要包含其双亲信息和孩子结点的信息。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504141544873.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-type">int</span> weight;                 <span class="hljs-comment">// 结点的权值</span><br><span class="hljs-type">int</span> parent, lchild, rchild; <span class="hljs-comment">// 结点的双亲、左孩子、右孩子的下标</span><br>&#125; HTNode,*HuffmanTree;          <span class="hljs-comment">// 动态分配数组存储哈夫曼树</span><br></code></pre></td></tr></table></figure><p>为了实现方便，数组的 0 号单元不使用，从 1 号单元开始使用，所以数组的大小为 2n。</p><p>将叶子结点集中存储在前面部分 1~n 个位置，而后面的 n-1 个位置存储其余非叶子结点。</p><h5 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h5><p><strong>算法步骤</strong></p><ol><li>初始化：首先动态申请 2n 个单元；然后循环 2n-1 次，从 1 号单元开始，依次将 1 至 2n-1 所有单元中的双亲、左孩子、右孩子的下标都初始化为0；最后再循环 n 次，输入前 n 个单元中叶子结点的权值。</li><li>创建树：循环 n-1 次，通过 n-1 次的选择、删除与合并来创建哈夫曼树。选择是从当前森林中选择双亲为 0 且权值最小的两个树根结点 s1 和s2；删除是指将结点 s1 和 s2 的双亲改为非0；合并就是将 s1 和 s2 的权值和作为一个新结点的权值依次存入到数组的第 n+l 之后的单元中，同时记录这个新结点左孩子的下标为 s1， 孩子的下标为 s2。</li></ol><p><strong>算法描述</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateHuffmanTree</span><span class="hljs-params">(HuffmanTree &amp;HT, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-comment">// 构造哈夫曼树</span><br><span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span>;<br><br>m = <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>;<br>HT = <span class="hljs-keyword">new</span> HTNode[m + <span class="hljs-number">1</span>];        <span class="hljs-comment">// 0 号单元未用，所以需要动态分配 m+1 个单元，HT[m] 表示根节点</span><br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;      <span class="hljs-comment">// 将 1~m 号单元中的双亲、左孩子、右孩子的下标都初始化为 0</span><br>HT[i].parent = <span class="hljs-number">0</span>;<br>HT[i].lchild = <span class="hljs-number">0</span>;<br>HT[i].rchild = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;      <span class="hljs-comment">// 输入前 n 个单元中叶子结点的权值</span><br>cin &gt;&gt; HT[i].weight;<br>&#125;<br><br><span class="hljs-keyword">for</span>(i = n + <span class="hljs-number">1</span>, i &lt;= m; ++i) &#123;  <span class="hljs-comment">// 通过 n-1 次的选择、删除、合并来创建哈夫曼树</span><br><span class="hljs-built_in">Select</span>(HT, i - <span class="hljs-number">1</span>, s1, s2)<br>HT[s1].parent = i;         <span class="hljs-comment">// 在 HT[k] 中选择两个其双亲域为 0 且权值最小的结点，并返回它们在 HT 中的序号 sl 和 s2</span><br>HT[s2].parent = i;<br>HT[i].lchild = s1;         <span class="hljs-comment">// 得到新结点 i, 从森林中删除 s1, s2, 将 s1 和 s2 的双亲域由 0 改为 1</span><br>HT[i].rchild = s2;         <span class="hljs-comment">// s1,s2分别作为 i 的左右孩子</span><br>HT[i].weight = HT[s1].weight + HT[s2].weight;  <span class="hljs-comment">// i 的权值为左右孩子权值之和</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><ol><li>前缀编码：如果在一个编码方案中，任一个编码都不是其他任何编码的前缀（最左子串），则称编码是前缀编码。</li><li>哈夫曼编码：对一棵具有 n 个叶子的哈夫曼树，若对树中的每个左分支赋予 0，右分支赋予 1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进串， 该二进制串就称为哈夫曼编码。</li></ol><p>哈夫曼编码是最优前缀编码</p><h4 id="哈夫曼编码的算法实现"><a href="#哈夫曼编码的算法实现" class="headerlink" title="哈夫曼编码的算法实现"></a>哈夫曼编码的算法实现</h4><p>求哈夫曼编码的主要思想是：依次以叶子为出发点，向上回溯至根结点为止。回溯时走左分支则生成代码 0，走右分支则生成代码 1。</p><p>每个哈夫曼编码是变长编码，因此使用一个指针数组来存放每个字符编码串的首地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> **HuffmanCode  <span class="hljs-comment">// 动态分配数组存储哈夫曼编码表</span><br></code></pre></td></tr></table></figure><p>为了实现方便， 数组的 0 号单元不使用，从 1 号单元开始使用， 所以数组 HC 的大小为 n+1，即编码表 HC 包括 n+1 行。</p><p>使用动态分配一个长度为 n 的一维数组 cd，根据数组 cd 的字符串长度分配 HC[i] 的存储空间，然后将 cd 的编码复制到 HC[i] 中，用于解决不定长的编码存储分配的问题。</p><p>因为求解编码时是从哈夫曼树的叶子出发， 向上回溯至根结点，是倒置的顺序。所以对于每个字符， 得到的编码顺序是从右向左的，故将编码向数组 cd 存放的顺序也是从后向前的要手动进行一次倒置。</p><p><strong>算法步骤</strong></p><ol><li>分配存储 n 个字符编码的编码表空间 HC，长度为 n+1；分配临时存储每个字符编码的动态数组空间 cd，cd[n-1]置为’\0’。</li><li>逐个求解n个字符的编码，循环n次，执行以下操作：<ul><li>设置变量 start 用于记录编码在cd中存放的位置，start初始时指向最后，即编码结束符位置 n-1；</li><li>设置变量 c 用于记录从叶子结点向上回溯至根结点所经过的结点下标，c 初始时为当前待编码字符的下标 i，f 用于记录 i 的双亲结点的下标；</li><li>从叶子结点向上回溯至根结点，求得字符 i 的编码，当 f 没有到达根结点时，循环执行以下操作：<ul><li>回溯一次 start 向前指一个位置，即 –start；</li><li>若结点 c 是 f 的左孩子，则生成代码 0，否则生成代码 1，生成的代码 0 或 1 保存在 cd[start] 中；</li><li>继续向上回溯，改变 c 和 f 的值。</li></ul></li><li>根据数组 cd 的字符串长度为第 i 个字符编码分配空间 HC[i]，然后将数组 cd 中的编码复制到 HC[i] 中。</li></ul></li><li>释放临时空间cd。</li></ol><p><strong>算法描述</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreatHuffmanCode</span><span class="hljs-params">(HuffmanTree HT, HuffmanCode &amp;HC, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-comment">// 从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表 HC 中</span><br>HC = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>* [n + <span class="hljs-number">1</span>];         <span class="hljs-comment">// 分配存储 n 个字符编码的编码表空间</span><br>cd = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n];               <span class="hljs-comment">// 分配临时存放每个字符编码的动态数组空间</span><br>cd[n - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;               <span class="hljs-comment">// 编码结束符</span><br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;       <span class="hljs-comment">// 逐个字符求哈夫曼编码</span><br>start = n - <span class="hljs-number">1</span>;              <span class="hljs-comment">// start 开始时指向最后，即编码结束符位置</span><br>c = i;                      <span class="hljs-comment">// f 指向结点 c 的双亲结点</span><br>f = HT[i].parent;<br><br><span class="hljs-keyword">while</span>(f != <span class="hljs-number">0</span>) &#123;             <span class="hljs-comment">// 从叶子结点开始向上回溯，直到根结点</span><br>-start;                 <span class="hljs-comment">// 回溯一次 start 向前指一个位置</span><br><br><span class="hljs-keyword">if</span>(HT[f].lchild == c)   <span class="hljs-comment">// 结点 c 是 f 的左孩子，则生成代码 0</span><br>cd[start] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-keyword">else</span>                    <span class="hljs-comment">// 结点 c 是 f 的右孩子，则生成代码 1</span><br>cd[start] = <span class="hljs-string">&#x27;1&#x27;</span>;<br><br>c = f;                  <span class="hljs-comment">// 继续向上回溯</span><br>f = HT[f].parent;<br>&#125;<br><br>HC[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n - start];<span class="hljs-comment">// 为第 i 个字符编码分配空间</span><br><span class="hljs-built_in">strcpy</span>(HC[i], &amp;cd[start]);  <span class="hljs-comment">// 将求得的编码从临时空间 cd 复制到 HC 的当前行中</span><br>&#125;<br><br><span class="hljs-keyword">delete</span> cd;                      <span class="hljs-comment">// 释放临时空间</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202504141736792.png"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>幻象——有趣的句子</title>
    <link href="/2025/03/24/%E8%AF%BB%E4%B9%A6/%E5%B9%BB%E8%B1%A1%E2%80%94%E2%80%94%E6%9C%89%E8%B6%A3%E7%9A%84%E5%8F%A5%E5%AD%90/"/>
    <url>/2025/03/24/%E8%AF%BB%E4%B9%A6/%E5%B9%BB%E8%B1%A1%E2%80%94%E2%80%94%E6%9C%89%E8%B6%A3%E7%9A%84%E5%8F%A5%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p>赞不绝口的朋友：“哎呀，你这孩子太漂亮了！”<br>妈妈：“噢，这不算什么——你该看看他的照片！”</p><p>从前，读到无聊报纸时，读者会说“今天的世界也太无趣！”<br>今天，他便要抱怨：“这报纸也太无趣！”</p><p>使世界变得有趣已不再是神的责任，而是新闻编辑的责任了。</p><p>我们索要的超过现实世界所能提供的限度，便要求有人编造出什么来补足世界的缺憾。这不过是我们追求幻象的一个例子罢了。</p><p>生动鲜明的图像让苍白的现实失色。</p><p>读者与观众很快就被报道的生动与照片的“真实”所折服，而不再关心被记录的事件是否自然发生。</p><p>但麦考利肯定想象不到记者在 20 世纪美国的崇高地位。他们早早把自己变成了人民的保护者。据说他们拥有超然的态度，没有党派的偏见，紧贴信息的源头，据有缜密清晰的表达能力，又时时刻刻直接接触全体人民，这使他们也成了人民的顾问。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>社科</tag>
      
      <tag>《幻象》</tag>
      
      <tag>真相</tag>
      
      <tag>传播学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后真相时代</title>
    <link href="/2025/03/24/%E8%AF%BB%E4%B9%A6/%E5%90%8E%E7%9C%9F%E7%9B%B8%E6%97%B6%E4%BB%A3/"/>
    <url>/2025/03/24/%E8%AF%BB%E4%B9%A6/%E5%90%8E%E7%9C%9F%E7%9B%B8%E6%97%B6%E4%BB%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="第一部分——片面真相：沟通者选择的真相"><a href="#第一部分——片面真相：沟通者选择的真相" class="headerlink" title="第一部分——片面真相：沟通者选择的真相"></a>第一部分——片面真相：沟通者选择的真相</h2><h3 id="复杂性"><a href="#复杂性" class="headerlink" title="复杂性"></a>复杂性</h3><blockquote><p>真相是散落成无数碎片的镜子，每个人都认为自己看到的一小片是完整的真相。<br>——理查德·伯顿</p></blockquote><h4 id="片面真相存在的原因"><a href="#片面真相存在的原因" class="headerlink" title="片面真相存在的原因"></a>片面真相存在的原因</h4><p>生活是极其复杂的，没有人能看到整个画面。无法在形成关于现实的实用理解之前考虑所有可用信，只能进行简化和选择<br>同时我们更倾向于和想法一致的朋友或同事讨论问题，并下意识地滤除与我们想法存在冲突的思想或数据</p><h3 id="复杂性策略"><a href="#复杂性策略" class="headerlink" title="复杂性策略"></a>复杂性策略</h3><h4 id="1-忽略"><a href="#1-忽略" class="headerlink" title="1.忽略"></a>1.忽略</h4><p>忽略分为两大手段</p><ol><li>直接忽略特定真相</li><li>将特定真相”淹没”</li></ol><p>不过需要注意的是：忽略不一定具有误导性，忽略可以提高对事物的认知效率</p><h5 id="忽略真相"><a href="#忽略真相" class="headerlink" title="忽略真相"></a>忽略真相</h5><p>恶意忽略真相常常体现在只描述对自己有利的方向，而不谈及对自己观点不利的方向<br>同时”忽略真相”还可以在众多细节之中抓住要点，提高认知效率。不过需要注意的是，认知效率的提高往往容易导致偏见的产生。<br><strong>示例</strong><br>“我们相信，亚马逊利用自己的主导地位伤害了美国读者的利益，压榨了整个图书行业的利润，影响了许多作家的职业生涯（并使他们产生了恐惧），阻碍了思想在我们这个社会中的自由流动。”然而，他们并没有提及亚马逊为许多作家和小型出版商提供了丰富的机遇，也没有考虑到亚马逊在其他领域的伟大成就。</p><h5 id="“淹没”真相"><a href="#“淹没”真相" class="headerlink" title="“淹没”真相"></a>“淹没”真相</h5><p>淹没真相往往将对自己不利的真相与对自己有利的真相相提并论，并强调对自己有利的方向更为重要<br><strong>示例</strong><br>“是的，我们的税收政策的确对残疾人不利，但是残疾人目前的就业人数比过去任何时候都要多，科技的发展也在为残疾人提供越来越大的帮助”这三句都是事实，然而第二个和第三个事实无法改变第一个事实</p><h4 id="2-混淆"><a href="#2-混淆" class="headerlink" title="2.混淆"></a>2.混淆</h4><p>混淆的关键在于将事件的注意力从原本的真相中转移，那么这要求用于混淆的真相越能挑起群众的神经越好<br>不过需要注意的是：在混淆之前一定要对引入的无关真相进行仔细选择，有些无关真相有可能会造成意想不到的伤害</p><h4 id="3-关联"><a href="#3-关联" class="headerlink" title="3.关联"></a>3.关联</h4><p>关联的目的在于使人们觉得两个或更多无关真相之间存在联系，通过巧妙的选择一系列看似有联系的真相，将目标与无关真相绑定起来<br>关联容易让人们产生对现实的虚假想象，而这种想象来源于作者对一系列真相的精心编排。作者是不需要说谎就能达到效果的。<br>同时需要注意的是：在互联网时代，周围人员和组织的信息越来越容易可以被公开获取，我们越来越容易通过与他人片面真相的关联而受到不公正的贬低，宣传对手可以通过宣传周围人员的片面真相而对我们造成伤害。<br><strong>示例</strong><br>“克里斯·休恩在担任能源和气候变化部长期间支持木质颗粒绿色补贴。2013 年，62 岁的休恩先生由于滥用司法程序而被监禁”，克里斯·休恩由于对一次违章驾驶撒谎（有趣的是，原文中被称为“滥用司法程序”）而被定罪，这与绿色补贴没有任何关系。《泰晤士报》将这两个不相关的真相结合在一起，使人们觉得休恩在推动这项政策时采取了恶意行为。</p><h3 id="复杂性总结"><a href="#复杂性总结" class="headerlink" title="复杂性总结"></a>复杂性总结</h3><p>复杂性无处不在，事物具有的多面性超出了我们大多数人的想象。当我们听到以“……是……”开头时，只需要考虑这些话语谈论的事物具有的复杂性、多样性以及矛盾性。也许这些话语的确反映了某种真相，但我们一定可以在同样的事物中得出其他许多竞争性真相。<br>我们需要对政客、评论家和社会活动家保持警惕，因为他们一定会呈现出最适合自己的局部。<br>同时，我们也可以从复杂的主题中选择简单的真相，从而更有效的表达自己，这样的简化和选择对于沟通者和听众都是一件好事</p><h4 id="如何应用于现实"><a href="#如何应用于现实" class="headerlink" title="如何应用于现实"></a>如何应用于现实</h4><ul><li>考虑任何重要问题的许多不同方面，均衡地寻找各种不同观点</li><li>选择哪些可以支持你的观点，又不会歪曲你所传达的现实的真相</li><li>通过忽略真相使问题变得更加清晰，但是注意不要误导听众</li></ul><h4 id="当心……"><a href="#当心……" class="headerlink" title="当心……"></a>当心……</h4><ul><li>将重要真相淹没在不相关海洋中的误导者</li><li>仅仅通过关联，攻击人和项目的误导者</li></ul><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><blockquote><p>谁控制了过去，谁就控制了未来。谁控制了现在，谁就控制了过去。<br>——乔治·奥威尔</p></blockquote><h3 id="历史策略"><a href="#历史策略" class="headerlink" title="历史策略"></a>历史策略</h3><h4 id="1-忘记过去"><a href="#1-忘记过去" class="headerlink" title="1.忘记过去"></a>1.忘记过去</h4><p>强制性的遗忘很难实现，此时在脑海中已经存在历史的记忆。但是沟通者可以引导我们远离不符合他们需要的历史真相。其中最简单的方法就是漏掉使你感到不便的部分（此处指忽略特定历史的整体）。忽略过去的罪恶可以回避批评，忽略或淡化对手的成功也可以用来削弱对手。同时偏差选择是最常见的形式，我们天生就具备这项技能，选择性历史叙述极具误导性（此处指选择性的讲述特定历史的某一片面真相）<br><strong>示例</strong><br>“重要技术被开发出来，尤其是在交通运输、餐具和个人卫生领域。民主制度蓬勃发展，许多人加入了工会，获得了选举权，社会变得更加公平。许多穷人的膳食得到了改善，他们变得更加健康和强壮。婴儿死亡率下降，人均寿命上升。酗酒人数有所下降。工作岗位，尤其是女性岗位有所增加，着增进了性别平等”这段话讨论的是第一次世界大战。</p><h4 id="2-有选择的记忆过去"><a href="#2-有选择的记忆过去" class="headerlink" title="2.有选择的记忆过去"></a>2.有选择的记忆过去</h4><p>历史是由无数真相组成的，我们没有能力了解任一历史事件的所有真相，对特定真相的选择决定了对过去的理解，而对过去的理解又会影响现在的行动，它塑造了我们的身份，影响了我们的思考方式。<br>通过选择，我们改变历史。当加入当前意图时，可以将过去塑造成几乎任何形式<br>误导者也可以仅仅谈论他们发现的一个真相，从而很大程度的歪曲历史。<br><strong>示例</strong><br>面对西贡的陷落，羞耻感成为绝大多数美国人的反应。他们选择遗忘掉这段历史，尽管作为军事行动，这是一次引人瞩目的成就：直升机小组夜以继日勤奋工作，从西贡撤出了 1373 名美国人、5595 名越南人和其他国家的公民。<br>面对敦刻尔克大撤退，英国人自豪的回顾起由渔船、私人游艇组成的开往法国海岸的小型船队以及它们所救出的数千名勇敢的士兵。他们选择自豪的回顾历史，尽管在法国战场上英国军队遭受了毁灭性的失败。<br>面对“百年国耻”，中国人则选择群情激愤的回顾这段历史，中国政府将这段历史的每一个细节深深的印在国民意识中。侵华日军南京大屠杀遇难同胞纪念馆是这座历史都城访问人数最多的地点。<br>对历史的选择造就了三个国家不同的身份认同</p><h3 id="历史总结"><a href="#历史总结" class="headerlink" title="历史总结"></a>历史总结</h3><p>历史决定了个人、组织或者国家的身份从何而来，通过忘记或者选择性的记忆，历史可以被无限改写</p><h4 id="如何应用于现实-1"><a href="#如何应用于现实-1" class="headerlink" title="如何应用于现实"></a>如何应用于现实</h4><ul><li>根据相关历史事件和成就塑造组织的当前身份</li><li>重述过去的成功行动和事件，以鼓励其他人现在的行动</li></ul><h4 id="当心……-1"><a href="#当心……-1" class="headerlink" title="当心……"></a>当心……</h4><ul><li>通过忽略相关重要历史使自己免于尴尬或者削弱对手的误导者</li><li>用高度选择性的历史叙述推动暴力、歧视和种族冲突的误导者</li></ul><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>对于黄疸病人来说，蜂蜜似乎是苦的。对于被疯狗咬过的人来说，水是恐怖的。<br>——马可·奥勒</p></blockquote><p>背景会极大的改变我们对现实的印象，可以改变意义。在不同背景下，同一个故事或物体会给人完全不同的印象，确定需要强调和需要淡化的背景是影响现实的一个重要环节，我们对很多物品的反应主要取决于背景，而不是物品本身。面对不同的背景，我们的行为往往也不同。我们往往在思考的时候忽视或者故意忽视某些背景。通过强调或忽视某些背景，演讲者在听众开始思考相关问题之前就已经能够有效地改变听众的思考方式。</p><h3 id="背景策略"><a href="#背景策略" class="headerlink" title="背景策略"></a>背景策略</h3><h4 id="1-设置框架"><a href="#1-设置框架" class="headerlink" title="1.设置框架"></a>1.设置框架</h4><p>设置有利于个人意图的背景可以提前决定人们对于一个问题的反应，合适的背景可以创造出令人信服的框架，影响人们对于框架内信息的处理方式。在沟通过程中，如果双方用完全不同的框架考虑一个复杂问题，那么他们不太可能找到共同的基础。有时，我们甚至很难听到与我们当前框架不符的信息。背景改变时，我们会下意识地对自己使用不同框架，我们的自我形象也会发生改变<br>框架可以帮助我们解读事件，也可以被人用于操纵和劝说我们。使用不同的背景可以改变谈判或辩论的方向<br><strong>示例</strong><br>“巴以冲突中，许多以色列犹太人认为这块神圣土地是上帝许诺给他们的，或者认为他们在敌对环境中取得了来之不易的安全。巴勒斯坦人考虑的则是他们被迫离开家园和土地时受到的不公正对待。”双方拥有各自的背景，这种框架错位使他们几乎不可能达成妥协。</p><h4 id="2-忽略相关背景"><a href="#2-忽略相关背景" class="headerlink" title="2.忽略相关背景"></a>2.忽略相关背景</h4><p>为了误导听众，许多演讲者会故意操纵或忽略背景。他们喜欢对反对者的文字断章取义，曲解反对者的立场，以更好的反驳对方。通过忽略相关背景，演讲者暗示听众不存在的真相是真实存在的，或者支持某个论点。<br><strong>示例</strong><br>“但是妈妈说，我可以在洗澡以后看电视”，小男孩真诚的对困惑的保姆说，不过他漏掉了一个重要背景，即这项特权只适用于星期六。</p><h3 id="背景总结"><a href="#背景总结" class="headerlink" title="背景总结"></a>背景总结</h3><p>我们当下的阅读习惯决定了我们喜欢碎片化信息，长篇报道已经让位于新闻滚动条和推特信息。因此，我们不可避免地失去了背景，我们在不了解实情的情况下对事件、评论、声明和传闻做出回应。我们需要确保自己了解最贴切的背景</p><h4 id="如何应用于现实-2"><a href="#如何应用于现实-2" class="headerlink" title="如何应用于现实"></a>如何应用于现实</h4><ul><li>总是应该检查背景</li><li>将最有用的背景作为框架，以支撑你的论点</li><li>通过改变背景改变对事物、人和问题的态度</li></ul><h4 id="当心……-2"><a href="#当心……-2" class="headerlink" title="当心……"></a>当心……</h4><ul><li>在不了解完整背景的情况下分享劲爆新闻的误传者</li><li>故意略去重要背景，尤其是引用他人话语的误导者</li></ul><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><blockquote><p>只要拷问数字，它们就会承认任何罪名。<br>——格雷格·伊斯特布鲁克</p></blockquote><p>我们在看到一个统计量时很难知道它的真正含义，误导者可以按时他们所希望的含义，从而影响现实<br>在对数字进行思考之前，我们要先真正弄明白这个数字代表了什么，即指代事物具体而详实的定义</p><h3 id="数字策略"><a href="#数字策略" class="headerlink" title="数字策略"></a>数字策略</h3><h4 id="1-选择有利单位"><a href="#1-选择有利单位" class="headerlink" title="1.选择有利单位"></a>1.选择有利单位</h4><p>对数字指代对象的不同选择，往往能导致不同的叙述效果。在了解背景之前，我们无法做出判断。<br><strong>示例</strong><br>1、“特朗普总统 2017 年对国会说‘9400 万美国人没有工作’时，这似乎意味着所有这些人都是被动失业者”，实际上，这个来自劳工统计局对数字包括所有 16 岁以上的学生、退休人员以及那些选择不工作的人。真实的美国失业数字——想工作但无法获得工作职位的人——在 2017 年初约为 760 万，不到特朗普所说数字的 1&#x2F;10。<br>2、“某款沐浴露产品的市场宣传材料称：‘原始薄荷茶树叶沐浴露浓缩了 7927 片真实的薄荷叶’”，数字 7927 以很大的字号印在瓶子上。7927 片薄荷叶对于此类产品而言并不多，但这款产品显然暗示了这是一个很大的数字。</p><h4 id="2-使数字看上去变大或变小"><a href="#2-使数字看上去变大或变小" class="headerlink" title="2.使数字看上去变大或变小"></a>2.使数字看上去变大或变小</h4><p>当某人试图说服你相信一个数字特别重要时，他所做的第一件事将数字转换成包含相关背景的更具启发性的真相。百分率往往可以比数字本身提供更多信息。百分率可以让绝对数字很大的事物所占比例很小，也可以让绝对数字很小的事物所占比例很大，这两个方向都可以被误导者所利用。在相对数字面前，我们往往又很少考虑绝对数字。同时，对数字指代对象的转换也可以改变数字的大小。想让数字变大或变小，可以把时间线拉长或拉近。也可以将某件事物转换成无关测量单位，使其看上去更加便宜或昂贵，一件事物的成本是它的实际金额，对这个成本的任何改写都是竞争性真相，很可能是为了服务于某个特殊目的。<br>同时，我们最重要的一些真相来自重要数字随时间的变化情况，误导者可能会用某个与其相关的数字讲述不同的故事。我们需要考虑到数字指代对象本身的变化。对相关问题选择不同的起始时间也会改变相关现象的真相。</p><ol><li>将数字转换成百分率</li><li>使用相对数字或绝对数字</li><li>改变数字指代的对象</li><li>改变（时间）范围</li><li>将事物转换成无关测量单位</li><li>改变起始时间</li><li>忽略对象本身的变化</li></ol><p><strong>示例</strong><br>1、“皇家《每日快报》的一则标题是‘多么划算！王室每年只会给你带来 56 磅成本’”，政客们喜欢用每日成本代替每年成本，甚至使用每个纳税人的或公民的成本。<br>2、“英国财政部发布了一则预测报告，称如果脱离欧盟，英国 2030 年的国内生产总值将比留在欧盟低 6%”，这则新闻稿使人们觉得英国将比目前更加糟糕。实际上财政部的预测显示，不管是否脱离欧盟，英国 2030 年的国内生产总值都要比现在高很多。更加完整诚实的标题应该是这样的：“英国将比它本应面临的情况糟糕一些，但它仍会好于现在”。</p><h4 id="3-隐藏或夸大趋势"><a href="#3-隐藏或夸大趋势" class="headerlink" title="3.隐藏或夸大趋势"></a>3.隐藏或夸大趋势</h4><p>隐藏或夸大趋势的常用手段之一就是使用图表。误导者可以改变图像的标度，在有利的轴线上描绘数据时，下降趋势可以显得很平坦，不明显的增长也可以显得很突出。同时累计图像也是常用图表之一，对于误导者来说，累计图像的好处在于，它不会下降。<br>同时对于两组数据来说，表面上的关联并不意味着它们存在某种因果关系，可能都是由第三个因素导致的，误传者很容易陷入这个陷阱。<br>另外值得一提的是，不同的平均数可以达到不同的效果，面对不了解平均数差异的听众，误导者可以在均值和中位数之间进行切换。大多数评论家不会具体指出他们使用的是哪种平均数，聪明的误导者会选择符合个人意图的平均数。<br><strong>示例</strong><br>1、“苹果总裁蒂姆·库克 2013 年展示了“苹果手机销售”图表，从而隐藏了两个季度的销售下降，他在一个月后对平板电脑销量也进行了同样的操作，因为平板电脑销量也下降了两个季度。”。<br>2、“有人注意到，海滨度假区销售的冰淇淋越多，溺水的人就越多。”这并不意味着冰淇淋会导致致命的痉挛，当天气暖和时，人们喜欢吃冰淇淋。当天气较好时，人们还喜欢游泳。<br>3、2014-2015 年，英国税前工资的中位数是 22400 英镑，同一年的工资均值是 31800 英镑，所以“28000 英镑的教师工资低于平均收入”与“28000 英镑的教师工资高于平均收入”都是成立的。</p><h4 id="4-挑选统计量"><a href="#4-挑选统计量" class="headerlink" title="4.挑选统计量"></a>4.挑选统计量</h4><p>对于平均数而言，统计量也是一个非常重要的因素。例如国家或省的均值总会低估普通人的经历。<br>非常有趣的是“<a href="https://zh.m.wikipedia.org/wiki/%25E8%25BE%259B%25E6%2599%25AE%25E6%25A3%25AE%25E6%2582%2596%25E8%25AE%25BA">辛普森悖论</a>”。<br>所以在面对不同的统计量时，我们一定要注意数字使用的背景。<br><strong>示例</strong><br>1、“2015 年，爱尔兰国内生产总值增长了 26%。对于这个欧元区小国来说，这是一个惊人的成就。”然而，国内生产总值的激增与爱尔兰人几乎没有关系，原因在于少数国外公司由于税收原因在全球赌桌上移动了一些筹码，一些宝贵的资产被转移到爱尔兰。但是这些新增资产和新增国民收入对于爱尔兰人没有太大意义，爱尔兰仍然是世界上人均债务第二多的国家。<br>2、虽然国内生产总值被视作目前最好的国家经济健康指标，但是它的增长并不意味着快乐和幸福的增长。当科技改变我们的活动和我们重视的事情时，国内生产总值和人类福祉的差异正在变得越来越重要。大多数发达国家的国内生产总值已经连续多年保持停滞，不过在这段时间发达国家居民的机器、沟通和医学质量得到了显著的提高，不过由于互联网服务不需要花一分钱，所以这些价值大部分被国内生产总值的统计数字忽略了。考虑到这个问题，中国国家统计局副局长在 2016 年呼吁将免费服务纳入国内生产总值报告中。‘数字经济催生了新的商业模式，创造了许多非货币交易，’许宪春说，‘它们的收入主要来自网络广告，而不是实际享受服务的用户。所以，消费者免费获得的最终服务的价值常常被低估或忽略’。英国国家统计局被要求研究如何将共享经济纳入国内生产总值的估计之中。</p><h5 id="辛普森悖论"><a href="#辛普森悖论" class="headerlink" title="辛普森悖论"></a>辛普森悖论</h5><p>辛普森悖论的问题在于，同样的数字可以传达两个不同的真相，它的关键在于识别群体与子群体的差异。例如“当一个头发超过平均值的男人走进酒吧，酒吧里的头发长度平均值却下降了”，这是因为第一个平均值指的是酒吧内男性群体的平均值，第二个平均值指的是酒吧内所有人的总平均值，这句话里面暗含了指代群体的改变。</p><h3 id="数字总结"><a href="#数字总结" class="headerlink" title="数字总结"></a>数字总结</h3><p>面对数字，我们往往会停止批判性思考。数字很重要，我们一定不能失去对数字的信任。但是我们需要更好地解读数字。对数字的解读本质上还是对数字背后指代对象的可变性、延展性的解读。</p><h4 id="如何应用于现实-3"><a href="#如何应用于现实-3" class="headerlink" title="如何应用于现实"></a>如何应用于现实</h4><ul><li>深入挖掘，以理解辩论中的每个数字究竟代表了什么</li><li>确保你使用的是最贴切的单位，你所对比的事物处于同一级别</li><li>将数字放在背景中，将它们与其他相关数字进行比较，以显示它们的真实大小</li></ul><h4 id="当心……-3"><a href="#当心……-3" class="headerlink" title="当心……"></a>当心……</h4><ul><li>试图使数字看上去更大或更小，或者使趋势变得更加明显的误导者</li><li>认为两组相关数据存在因果关系的误传者</li><li>挑选统计量或者不明确指出自己使用的是何种平均数的误导者</li></ul><h3 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h3><blockquote><p>让事实见鬼去吧！我们需要故事<br>——肯·凯西</p></blockquote><p>故事是对变化过程的选择性连贯描述，强调局面和事件之间的因果关系。故事有三个最主要的构成：变化过程、因果关系、触发事件。对于变化过程，强调的是故事必须要有变化，即故事内容一定是丰富的。对于因果关系，这是一切故事的核心，是故事的逻辑所在，也是听众愿意相信故事的原因，原因是可以被人为创造的，因果关系由叙事过程决定，讲述者一定会说清楚事情发生的原因。对于触发事件，每个故事都需要一系列事件的最初诱因，同一个事件的不同故事，触发事件一般不同，取决于讲述者的观点态度。<br>因果关系具有非常强大的力量。人们渴望获得解释。当重要的事情发生时，我们希望理解它为什么发生。由于故事似乎可以说明一件事情是如何导致另一件事情的，因此它可以帮助我们理解这个混乱的世界。故事作为沟通的真正价值在于它们使复杂事物变得连贯而清晰。<br>不过故事的问题也在于此，故事具有高度选择性。它们没法给出完整的画面，是片面的真相。即故事只能给读者固定的由讲述者选择的片面真相。当讲述者描述一系列事件时，会选择起始点、叙述时段和描绘人物的方式，重要的是，叙述者会简化原因和结果。故事相当具有条理，但真实的生活很少如此黑白分明，事件往往拥有多个原因。<br>面对描述同一事件不同版本的故事，我们的思维模式和世界观往往使我们相信其中一个版本，不过这些版本呈现的事实都是真相。至于这些事实连接成的因果关系及其组合而成的最终信息，就要看讲述者如何讲故事了。</p><h3 id="故事策略"><a href="#故事策略" class="headerlink" title="故事策略"></a>故事策略</h3><h4 id="1-通过连接事实暗示因果关系"><a href="#1-通过连接事实暗示因果关系" class="headerlink" title="1.通过连接事实暗示因果关系"></a>1.通过连接事实暗示因果关系</h4><p>对故事三要素的不同选择，可以传达不同的观点和思想。通过对事件的一系列特定事实的选择，串联起来构成一个完整的故事，可以暗示读者其中的因果关系。<br>因此在讲故事的过程中，我们需要知道根据现有事实构造不同故事的方式，以及我们可以让听众相信的不同结论。<br><strong>示例</strong><br>在对金融危机故事的讲述中，默文·金讲述的故事始于柏林墙倒塌，而其他人则将金融服务行业放松管制、债务抵押债券的发明或者美国住房泡沫作为触发事件。这些都暗示和强调了支持个人观点的不同的因果关系。</p><h4 id="2-用故事定义身份"><a href="#2-用故事定义身份" class="headerlink" title="2.用故事定义身份"></a>2.用故事定义身份</h4><p>故事不一定要讲述过去的事情，同样可以展望未来，讲述关于前进方向的许多具有同样可能性的故事。<br>故事的作用在于提出了一个因果链条，淡化了其他的因果链条。<br>这个策略在企业和群体中用的很多。公司起源故事是团结员工和吸引顾客的常见手段，当然这些都是选择性历史，只讲述使当前企业具有良好形象的过往事迹。具有同样效果的还有逸事，这是关于某些人或事件的局部真相，其目的是改变人们的普遍行为和思维模式，在企业环境中，这种坦诚而真实的描述可以起到有效的鼓励作用。<br><strong>示例</strong><br>北面和巴塔哥尼亚的创始人为满足自己的探险需求而设计工具包和服装的故事极大地提高了他们的品牌形象，巴克莱银行为他们的贵格会创始人而自豪，其诚实、正直和坦率的原则是银行员工目前仍然在使用的口号，耐克为其共同创始人兼跑步教练比尔·鲍尔曼打造了一个复杂的神话。</p><h4 id="3-用案例故事鼓励或改变行为"><a href="#3-用案例故事鼓励或改变行为" class="headerlink" title="3.用案例故事鼓励或改变行为"></a>3.用案例故事鼓励或改变行为</h4><p>当政客和记者用故事支持争议性观点时，他们会起到引导情绪的作用，这些故事的作用在于长时间激起读者的情绪，使读者支持作者的观点，哪怕故事本身和观点毫无联系。故事的目的不一定在于说明什么事实，激起情绪也是目的之一。因此，开场故事是极为常见的新闻技巧（严格来说，应该是“现代新闻”技巧）。人们喜欢故事，而且认为故事具有说服力——后者更加重要。<br><strong>示例</strong><br>“ 1 月 23 日星期一下午刚过 3 点，从伦敦西北部卡皮塔尔中学走出来的孩子们突然停止了往常的喧嚣。‘所有孩子像平时一样跑来跑去，’一个邻居说，‘突然，大家安静下来。我站起来，拉开窗帘，看到孩子们尖叫着四散奔逃。’<br>15 岁的学生夸马里•巴恩斯被刺数刀。他倒在距离学校大门几米远的地方。一个女人用胳膊抱着他。医疗救助人员冲到现场，将夸马里送到医院。”这是 2017 年《卫报》一篇谈论英国青少年持刀犯罪的重要文章的开头，在这篇文章中，他的故事服务于一个明确的目标：一个孩子在自家学校门外被刺的开头远比持刀犯罪枯燥事实刀均衡呈现更加引人注目。然而，文章开头的故事与作者的主要论点没有任何关系。</p><h4 id="4-将故事作为证据"><a href="#4-将故事作为证据" class="headerlink" title="4.将故事作为证据"></a>4.将故事作为证据</h4><p>常常被人们忽略的一点是：故事没法证明任何事情，它仅仅是独立的数据点，将一个具体案例外推为普遍规则是一种逻辑谬误。<br>倡导者可以用故事展示一件事情可能具有的情况，而不是证明什么结论，真实的故事可以展示可能性。在讲述过程中应当努力将故事当作数据点和论证，而不是某个论点的基础。在证明某件事情时，要坚持使用冰冷的数字和事实。</p><h3 id="故事总结"><a href="#故事总结" class="headerlink" title="故事总结"></a>故事总结</h3><p>故事具有极大的力量，很容易被人相信。由于它可以帮助我们理解复杂世界，由于它们的结构符合古老的心理模式，因此我们往往认为它们是唯一的真相。实际上它们只是真相之一。当我们倾听和讲述故事时，我们应该记住它们所描绘的真相具有多大的灵活性。</p><h4 id="如何应用于现实-4"><a href="#如何应用于现实-4" class="headerlink" title="如何应用于现实"></a>如何应用于现实</h4><ul><li>用故事澄清事情发生的原因和可能性</li><li>仔细选择关于某个组织的故事，以帮助该组织塑造身份</li><li>分享关于最佳实践的逸事，以鼓励其他人做出相同的表现</li></ul><h4 id="当心……-4"><a href="#当心……-4" class="headerlink" title="当心……"></a>当心……</h4><ul><li>在真实事件组成的故事中捏造因果关系的误导者</li><li>用具体故事证明普遍观点的误传者</li></ul><h2 id="第二部分——主观真相：可以改变的真相"><a href="#第二部分——主观真相：可以改变的真相" class="headerlink" title="第二部分——主观真相：可以改变的真相"></a>第二部分——主观真相：可以改变的真相</h2><h3 id="道德"><a href="#道德" class="headerlink" title="道德"></a>道德</h3><blockquote><p>杀人是被禁止的。所以，所有的杀人犯都会受到惩罚，除非他们杀掉一堆人，最后吹响胜利的号角。<br>——伏尔泰</p></blockquote><p>在不同文化的不同道德观念之中，一个人眼中的善可能是另一个人眼中的恶。但是我们往往认为某些道德观点是不言而喻的。我们过于坚信我们的道德，但善恶并不是一成不变的。道德真理可以被操纵，有经验的沟通者（往往是被尊为社会道德指引者的人）可以为事物、事件甚至个人赋予不同的道德意义，从而重塑我们的现实。</p><h3 id="道德策略"><a href="#道德策略" class="headerlink" title="道德策略"></a>道德策略</h3><h4 id="1-妖魔化"><a href="#1-妖魔化" class="headerlink" title="1.妖魔化"></a>1.妖魔化</h4><p>在我们生活的世界上，总有一些人持有和我们完全不同的道德观念。在我们还没有形成固定观念的问题上，我们可以更加清晰的看到道德真理可能具有的灵活性。<br>我们往往会接受所在群体的主流道德真理，出现道德争议时，我们会服从群体中大多数人的反应。道德真理将群体维系在一起。如果一个群体的不同成员开始采纳不同道德真理，那么道德的合作功能就会蒸发，群体就会受到破坏。由此，遵守群体道德真理的“同济压力”在每个文化中都很强烈。<br>当群体的立场受到挑战时，我们会自发的为这种立场辩护，哪怕已经开始产生怀疑。我们甚至会将与其他群体相冲突的道德真理定义我们群体，这加剧了不同社会的割裂。<br>以上这些群体错位可能是相对隔离群体逐渐变化的结果，但更可能是领导者或意见领袖故意设计的。这为将其他群体的道德真理妖魔化提供了可能。强大的沟通者可以鼓励整个群体接受新的道德真理。<br><strong>示例</strong><br>植物兴奋剂和致幻剂千年以来就一直被地球几乎所有文化使用，这种植物提取物一直广泛在社会中使用，直到 20 世纪最初的几十年，各国政府共同参与了妖魔化毒品和毒品使用者的运动，西方政府反毒品宣传中强调了危险物质、“边缘群体”威胁和犯罪之间的联系。它们广泛的将毒品与反政府组织联系起来起来，借用毒品打击这些群体。</p><h4 id="2-影响群体道德"><a href="#2-影响群体道德" class="headerlink" title="2.影响群体道德"></a>2.影响群体道德</h4><p>群体道德容易与社会整体道德相违背，有可能是外界对群体的要求，也有可能是群体内部约定俗成。形成群体道德可以通过长期且重复的行为和言论，也可以通过群体内部的忠诚。<br><strong>示例</strong><br>有一条完全可以被称为宇宙道德法则的道德真理，那就是我们不应该互相残杀。不过，大多数社会都会在依靠一群愿意杀人的同胞维持秩序。我们将这些人称为士兵，并且向他们灌输这样一个真理：在某些情况下，杀人是正当的。这样并不容易。</p><h4 id="3-让道德变得不重要"><a href="#3-让道德变得不重要" class="headerlink" title="3.让道德变得不重要"></a>3.让道德变得不重要</h4><p>有一种言论，被社会上大多数人谴责的行为在道德上是中性的——它们在道德上谈不上好，但也谈不上坏。很多人只想知道他们的行为是否合法，如果合法，他们就不会讨论其他事情了（所谓的“法无禁止皆可为”）。<br><strong>示例</strong><br>投资银行家通常会努力遵守法律，遵守金融监管结构制定的大量复杂规则，但他们中的许多人认为自己并没有其他任何道德义务。</p><h3 id="道德总结"><a href="#道德总结" class="headerlink" title="道德总结"></a>道德总结</h3><p>道德是主观的和可变的，改变自身道德真理的群体会采取与其他人完全不同的做法。当有害的群体道德真理出现时，我们需要努力改变它们。<br>培育道德同样是非常重要的。面对有害的道德真理，倡导者应该主动培育良好的道德“与之对抗”。</p><h4 id="培育道德"><a href="#培育道德" class="headerlink" title="培育道德"></a>培育道德</h4><p>培育道德有几种方式：</p><ol><li>同理心。同理心是改变组织内部道德文化的重要工具。如果一个人被迫长时间思考说谎对社会的恶劣影响，那么他未来就不太可能说谎。</li><li>重塑价值观。如果领导者重新定义群体的价值观念，那么群体更有可能培育出良好的道德真理。</li><li>举出证据。对于具有分析头脑、不太容易接受同理心干预的人来说，这场常常是最有效的策略。例如可以展示当前行为对人们自身利益的损害，从而说服他们改变行为。</li><li>长时间坚持。如果没有同情意愿或者不愿意接受新定义和智力辩论的人来说，可以让他长时间坚持习惯良好的道德真理，这样可以让他养成真正的道德真理。伪装的品德完全有可能变成真正的品德。</li></ol><h4 id="如何应用于现实-5"><a href="#如何应用于现实-5" class="headerlink" title="如何应用于现实"></a>如何应用于现实</h4><ul><li>认识到道德是主观的，具有破坏性的群体道德可以得到改变。</li><li>通过同理心、激励、逻辑论证以及合意性的新定义灌输新的道德真理。</li></ul><h4 id="当心……-5"><a href="#当心……-5" class="headerlink" title="当心……"></a>当心……</h4><ul><li>对于道德中性事物的人群进行妖魔化的误导者。</li><li>支持某种对社会有害的道德真理的群体。</li></ul><h3 id="吸引力"><a href="#吸引力" class="headerlink" title="吸引力"></a>吸引力</h3><blockquote><p>己之蜜糖，彼之砒霜。<br>——卢克莱修</p></blockquote><p>我们常常被激发快感、兴趣或兴奋的事物吸引，排斥激发仇恨、恐惧或厌恶的事物。不同的情绪以不同的方式激励我们。<br>吸引力是非常易变的，即使表面上看起来普遍被人接受或者普遍不被接受的事物也可以被描绘成完全不同的色彩。它不仅取决于事物本身，也取决于上下文。如果农业、卫生和知识可以被视作坏事，战争、粪便和失败可以被视作好事，那么愿望的主观性似乎不会有什么界限。任何事物的吸引力都存在竞争性真相。合适的竞争性真相会极大地影响我们的行为，我们可以对我们想要的理想事物进行选择，并且推动其他人朝着相同的方向前进。</p><h3 id="吸引力策略"><a href="#吸引力策略" class="headerlink" title="吸引力策略"></a>吸引力策略</h3><h4 id="1-劝说人们喜欢对他们有益的事物"><a href="#1-劝说人们喜欢对他们有益的事物" class="headerlink" title="1.劝说人们喜欢对他们有益的事物"></a>1.劝说人们喜欢对他们有益的事物</h4><p>当我们享受预期时，我们更容易享受某种事物。这被称为“营销安慰剂效应”。从生物学来说，情绪本身不是目的，而是一种机制，劝说我们追求对进化有用的目标，排斥对进化有害的目标。然而这种机制可以得到重新校正。<br>这个策略的关键在于“说服”与“目标”。<br>对于成年人而言，孩子更容易被说服接受某些事物。不过需要注意的是，通过奖励（！）或恐吓只会强化某些事物对他们无益的信息，使之成为自我实现的预言。然而，成年人也是很容易被说服的，</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>社科</tag>
      
      <tag>真相</tag>
      
      <tag>传播学</tag>
      
      <tag>《后真相时代》</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>串、数组和广义表</title>
    <link href="/2025/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
    <url>/2025/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>字符串一般被称为串，串是一种内容受限的线性表。多维数组和广义表也是线性表的一种延伸。</p><h2 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h2><p><strong>串</strong>是有零个或多个字符组成的有限序列。</p><p><strong>串的长度</strong>：串中字符的数目 n。</p><p><strong>空串</strong>：零个字符的穿。</p><p><strong>子串</strong>：串中任意个连续的字符组成的字序列。</p><p><strong>主串</strong>：包含子串的串。</p><p>字符在串中的位置被称为字符在序列中的序号。</p><p>子串在主串中的位置是以子串的第一个字符在主串中的位置表示。</p><p>两个串相等当且仅当这两个串的值相等。</p><p><strong>空格串</strong>：一个或多个空格组成的串” “。</p><h2 id="串的类型定义、存储结构及其运算"><a href="#串的类型定义、存储结构及其运算" class="headerlink" title="串的类型定义、存储结构及其运算"></a>串的类型定义、存储结构及其运算</h2><h3 id="串的抽象类型定义"><a href="#串的抽象类型定义" class="headerlink" title="串的抽象类型定义"></a>串的抽象类型定义</h3><p>串的逻辑结构和线性表极其相似，但是串的基本操作和线性表有很大的差别。在串的基本操作中，一般以”串的整体”作为操作对象。</p><p>串的抽象数据类型定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ADT String&#123;<br>数据对象：D=&#123;ai|ai∈CharacterSet, i=l,<span class="hljs-number">2</span>,…,n,n&gt;=<span class="hljs-number">0</span>J<br>数据关系：Rl=&#123;&lt;ai<span class="hljs-number">-1</span>,ai&gt;|ai<span class="hljs-number">-1</span>,ai∈D,i=<span class="hljs-number">2</span>,…,n&#125;<br>基本操作：<br>    <span class="hljs-built_in">StrAssign</span>(&amp;T, chars)<br>        初始条件：chars是字符串常址。<br>        操作结果：生成一个其值等于chars的串T。<br>    <span class="hljs-built_in">StrCopy</span>(&amp;T,S)<br>        初始条件：串S存在。<br>        操作结果：由串S复制得串T。<br>    <span class="hljs-built_in">StrEmpty</span>(S)<br>        初始条件：串S存在。<br>        操作结果：若S为空串，则返回<span class="hljs-literal">true</span>, 否则返回<span class="hljs-literal">false</span>。<br>    StrCompar <span class="hljs-built_in">e</span>(S,T)<br>        初始条件：串S和T存在。<br>        操作结果：若S&gt;T, 则返回值&gt;<span class="hljs-number">0</span>; 若S=T, 则返回值=<span class="hljs-number">0</span>; 若S&lt;T, 则返回值&lt;<span class="hljs-number">0</span>。<br>    <span class="hljs-built_in">StrLength</span>(S)<br>        初始条件：串S存在。<br>        操作结果：返回S的元素个数，称为串的长度。<br>    <span class="hljs-built_in">ClearString</span>(&amp;S)<br>        初始条件：串S存在。<br>        操作结果：将S清为空串。<br>    <span class="hljs-built_in">Concat</span>(&amp;T,Sl,S2)<br>        初始条件：串Sl和S2存在。<br>        操作结果：用T返回由Sl和S2联接而成的新串。<br>    <span class="hljs-built_in">SubString</span>(&amp;Sub,S,pos,len)<br>        初始条件：串S存在，<span class="hljs-number">1</span>&lt;=pos&lt;=<span class="hljs-built_in">StrLength</span>(S)且<span class="hljs-number">0</span>&lt;=<span class="hljs-number">1</span>en&lt;=<span class="hljs-built_in">StrLength</span>(S)-pos+l。<br>        操作结果：用Sub返回串S的第pos个字符起长度为len的子串。<br>    <span class="hljs-built_in">Index</span>(S,T,pos)<br>        初始条件：串S和T存在，T是非空串，<span class="hljs-number">1</span>:s;pos:s;<span class="hljs-built_in">strLength</span>(S)。<br>        操作结果：若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置；否则函数值为<span class="hljs-number">0</span>。<br>    <span class="hljs-built_in">Replace</span>(&amp;S,T,V)<br>        初始条件：串S,T和V存在,T是非空串。<br>        操作结果：用V替换主串S中出现的所有与T相等的不重叠的子串。<br>    <span class="hljs-built_in">Strlnsert</span>(&amp;S,pos,T)<br>        初始条件：串S和T存在，<span class="hljs-number">1</span>&lt;=pos&lt;=<span class="hljs-built_in">StrLength</span>(S)+l。<br>        操作结果：在串S的第pos 个字符之前插人串T。<br>    <span class="hljs-built_in">StrDelete</span>(&amp;S,pos,len)<br>    初始条件：串S存在，<span class="hljs-number">1</span>&lt;=pos&lt;=<span class="hljs-built_in">StrLength</span>(S)-len+l。<br>    操作结果：从串S中删除第pos 个字符起长度为len 的子串。<br>    <span class="hljs-built_in">DestroyString</span> (&amp;S)<br>    初始条件：串S存在。<br>    操作结果：串S被销毁。<br>&#125;ADT String<br></code></pre></td></tr></table></figure><h3 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h3><p>串可以用链式存储，但是有存储效率和算法考虑，一般采用顺序存储结构</p><h4 id="串的顺序存储"><a href="#串的顺序存储" class="headerlink" title="串的顺序存储"></a>串的顺序存储</h4><p>串的顺序存储结构用一组地址连续的存储单元存储串值的字符序列，每个定义的串都被分配一个固定长度的存储区域。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 255      <span class="hljs-comment">//串的最大长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">char</span> ch[MAXLEN<span class="hljs-number">+1</span>];  <span class="hljs-comment">//存储串的一维数组</span><br>    <span class="hljs-type">int</span> length;         <span class="hljs-comment">//串的当前长度</span><br>&#125;SString;<br></code></pre></td></tr></table></figure><p>然而实际上这种为串变量设定固定大小的空间不是很合理，最好根据实际需要在程序执行过程中按需分配和释放字符数组的空间。</p><p>在 C 语言中，可以使用被称为”堆”堆自由存储区，为每个新产生的串动态分配一块实际串长所需要的存储空间，如果分配成功则返回一个指向起始地址的指针。这样被称为串的堆式顺序存储结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">char</span> *ch;    <span class="hljs-comment">//如果是非空串，则按串长分配存储区，否则 ch 为 NULL</span><br>    <span class="hljs-type">int</span> length;  <span class="hljs-comment">//串的当前长度</span><br>&#125;HString;<br></code></pre></td></tr></table></figure><h4 id="串的链式存储"><a href="#串的链式存储" class="headerlink" title="串的链式存储"></a>串的链式存储</h4><p>在串的链式存储中，存在一个与别的链式存储不一样的问题，本质是串结构的特殊性——串中每一个数据元素是一个字符，用链表存储串时，需要选择一个结点存储几个字符（可以存放一个，也可以存放多个）。</p><p>为了便于串的操作，当用链表存储串值时，除了头指针还可以加一个尾指针指示链表中的最后一个结点，并给出当前串的长度。这样定义的串存储结构为块链结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHUNKSIZE 80     <span class="hljs-comment">//由用户定义块大小</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Chunk</span>&#123;<br>    <span class="hljs-type">char</span> ch[CHUNKSIZE];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Chunk</span> *next;<br>&#125;Chunk;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    Chunk *head, *tail;  <span class="hljs-comment">//串的头和尾指针</span><br>    <span class="hljs-type">int</span> length;          <span class="hljs-comment">//串的当前长度</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在链式存储中，结点大小直接影响串处理的效率。面对很长的串，存储密度就很重要了。</p><p>存储密度小，运算处理方便，但是存储占用量大。因此串的字符集的大小也是一个重要因素。一般来说，字符集小，字符的机内编码就短，这影响串值存储方式的选取。</p><h3 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h3><p>子串的定位运算通常称为串的模式匹配或串匹配。</p><p>串的模式匹配的效果：</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image.png"></p><p>著名的模式匹配算法有 BF 算法和 KMP 算法</p><h4 id="BF-算法"><a href="#BF-算法" class="headerlink" title="BF 算法"></a>BF 算法</h4><p>BF 算法是最简单直观的模式匹配算法。</p><p>模式匹配也要求可以指定主串中查找的起始位置，这样字符串顺序存储结构的优势就体现出来了。</p><p><strong>算法步骤</strong></p><ol><li>分别利用计数指针 i 和 j 指示主串 S 和模式 T 中当前正待比较的字符位置，i 的初值为 pos，j 的初值为 1。</li><li>如果两个串都没有达到串尾，即 i 和 j 均分别小于等于 S 和 T 的长度时，则循环执行一下操作：</li></ol><ul><li>S.ch[i] 和 T.ch[i] 比较，若相等，则 i 和 j 分别指示串中下个位置，继续比较后续字符。</li><li>若不等，指针后退重新开始匹配，从主串的下一个字符（i&#x3D;i-j+2）起再重新和模式的第一个字符（j&#x3D;1） 比较。</li></ul><ol start="3"><li>如果 j&gt;T.length，说明匹配成功，返回和模式 T 中第一个字符相等的字符串在主串中的序号（i-T.length）；否则匹配失败，返回 0。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Index_BF</span><span class="hljs-params">(SString S, SString T, <span class="hljs-type">int</span> pos)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//返回模式 T 在主串 S 中第 pos 个字符开始第一次出现的位置。若不存在则返回值为0</span><br> <span class="hljs-comment">//其中，T 非空，1&lt;=pos&lt;=S.length</span><br>    i = pos;                           <span class="hljs-comment">//初始化</span><br>    j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)  <span class="hljs-comment">//两个串均为比较到串尾</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(S.ch[i] == T.ch[i])         <span class="hljs-comment">//继续比较后续字符</span><br>        &#123;<br>            ++i;<br>            ++j;<br>        &#125;<br>        <span class="hljs-keyword">else</span>                           <span class="hljs-comment">//指针后退重新开始匹配</span><br>        &#123;<br>            i = i-j<span class="hljs-number">+2</span>;<br>            j=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j&gt;T.length)                 <span class="hljs-comment">//匹配成功</span><br>            <span class="hljs-keyword">return</span> i-T.length;<br>        <span class="hljs-keyword">else</span>                           <span class="hljs-comment">//匹配失败</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h5><p><strong>最好情况下平均时间复杂度</strong>：</p><p>最好的情况下，每次不成功的匹配都发生在模式串的第一个字符和主串相对应字符的比较。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_2.png"></p><p>最好情况下平均时间复杂度是 O(n+m)。</p><p><strong>最坏情况下平均时间复杂度</strong>：</p><p>最坏情况下，每次不成功的匹配都发生在模式串的最后一个字符与主串相对应字符的比较。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_3.png"></p><p>最坏情况下平均时间复杂度是 O(n*m)。</p><p>由此看出，BF 算法在匹配失败后总是跳转到 i-j+2 的位置，这导致算法的时间复杂度比较高。</p><h4 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h4><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的类型定义"><a href="#数组的类型定义" class="headerlink" title="数组的类型定义"></a>数组的类型定义</h3><p>数组：类型相同的数据元素构成的有序集合。</p><p>n 维数组：数组中每个元素处于 n 个关系中。</p><p>数组的特点在于结构中的元素本身可以看作是具有某种结构的数据，但要求它们属于同一数据类型。</p><p>一个 n 维数组类型可以定义为其数据元素为 n-1 维数组类型的一维数组类型。</p><p>由于数组一旦被定义，维度和维界就不再改变，因此除了初始化和销毁外，只有存取元素和修改元素值的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ADT Array&#123;<br>    数据对象:ji=<span class="hljs-number">0</span>,...,bi<span class="hljs-number">-1</span>,i=l,<span class="hljs-number">2</span>,...,n,<br>        D =&#123;aj1j<span class="hljs-number">2.</span>..jn|<span class="hljs-built_in">n</span>(&gt;O)称为数组的维数,bi是数组第i维的长度,ji是数组元素的第i维下标，aj1j<span class="hljs-number">2.</span>..jn∈ElemSet&#125;<br>    数据关系:R=&#123;Rl,R2,...,Rn&#125;<br>    基本操作:<br>        <span class="hljs-built_in">InitArray</span> (&amp;A, n, bound i, ···, boundn)<br>            操作结果:若维数n和各维长度合法， 则构造相应的数组A, 并返回OK。<br>        <span class="hljs-built_in">DestroyArray</span>(&amp;A)<br>            操作结果:销毁数组A。<br>        <span class="hljs-built_in">Value</span>(A,&amp;e,indexl ,...,indexn)<br>            初始条件:A是n维数组，e为元素变量，随后是n个下标值。<br>            操作结果:若各下标不超界，则e赋值为所指定的A的元素值，并返回OK。<br>        <span class="hljs-built_in">Assign</span>(&amp;A,e,indexl, …，indexn)<br>            初始条件:A是n维数组，e为元素变扯，随后是n 个下标值。<br>            操作结果:若下标不超界，则将e的值赋给所指定的A的元素，并返回OK。<br>&#125; ADT Array<br></code></pre></td></tr></table></figure><h3 id="数组的顺序存储"><a href="#数组的顺序存储" class="headerlink" title="数组的顺序存储"></a>数组的顺序存储</h3><p>由于数组特殊的特性，采用顺序存储比较合适。</p><p>需要注意的是，存储单元是一维结构，但数组可以是多维结构，此时便存在次序约定的问题——一种是以列序为主序的存储方式，另一种是以行序为主序的存储方式。常用的语言都是以行序为主序的存储方式。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_4.png"></p><p>因此对于数组而言，只要给出下标就可以访问到元素的位置。（随机存储结构，很好理解，放个图略过得了）</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_5.png"></p><h3 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h3><blockquote><p>说实话，没看懂</p></blockquote><h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_6.png"></p><h4 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h4><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_7.png"><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_8.png"></p><h4 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h4><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_9.png"></p><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><h3 id="广义表的定义"><a href="#广义表的定义" class="headerlink" title="广义表的定义"></a>广义表的定义</h3><p>广义表是线性表的推广，称作列表。一般记作 <code>LS = (a1,a2,...,an)</code>。需要注意的是，这里的 ai 不再局限于单个元素，在广义表中既可以是元素也可以是广义表，分别称为广义表的原子和子表。由此看出广义表的定义是一个递归定义。</p><p>关于广义表有几个重要结论：</p><ol><li>广义表的元素可以是子表，广义表是一个多层次结构。</li><li>广义表可为其他广义表所共享。</li><li>广义表可以是一个递归的表，即广义表可以是其本身的一个子表。</li></ol><p>广义表的结构比较复杂，其中主要的两个运算如下：</p><ul><li>取表头 GetHead(LS)：取出的表头为非空广义表的第一个元素。</li><li>取表尾 GetTail(LS)：取出的表尾为除去表头外，其余元素构成的表。</li></ul><h3 id="广义表的存储结构"><a href="#广义表的存储结构" class="headerlink" title="广义表的存储结构"></a>广义表的存储结构</h3><p>广义表常用链式存储结构。同时又有两种处理思路：</p><ul><li>头尾链表</li><li>扩展线性链表</li></ul><h4 id="头尾链表的存储结构"><a href="#头尾链表的存储结构" class="headerlink" title="头尾链表的存储结构"></a>头尾链表的存储结构</h4><p>由于一对确定的表头表尾可唯一确定广义表，因此一个表结点由三个域组成：标志域、指示表头的指针域和指示表尾的指针域；原子结点则由两个域组成：标志域和值域。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_10.png"></p><p>形式定义说明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>&#123;ATOM,LIST&#125; ElemTag;           <span class="hljs-comment">//ATOM == 0：原子;LIST == 1：子表</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">GLNode</span><br>&#123;<br>    ElemTag tag;                           <span class="hljs-comment">//公共部分，用于区分原子结点和表结点</span><br>    <span class="hljs-keyword">union</span>                                  <span class="hljs-comment">//原子结点和表结点的联合部分</span><br>    &#123;<br>        AtomType atom;                     <span class="hljs-comment">//atom 是原子结点的值域，AtomByte 由用户定义</span><br>        <span class="hljs-keyword">struct</span>&#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">GLNode</span>*hp, *tp;&#125;ptr  <span class="hljs-comment">//ptr 是表结点的指针域，ptr.hp 和 ptr.tp 分别指向表头和表尾</span><br>    &#125;;<br>&#125;*GList;                                   <span class="hljs-comment">//广义表类型</span><br></code></pre></td></tr></table></figure><p>这种存储结构有以下三个特点：</p><ul><li>除空表的表头指针为空外，任意非空广义表，表头指针均指向一个表结点。</li><li>容易分清列表中原子和子表所在层次。</li><li>最高层的表结点个数即为广义表的长度。</li></ul><h4 id="扩展线性链表的存储结构"><a href="#扩展线性链表的存储结构" class="headerlink" title="扩展线性链表的存储结构"></a>扩展线性链表的存储结构</h4><p>这种结构中，两种元素都由三个域构成。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_11.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/image_12.png"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈和队列</title>
    <link href="/2025/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2025/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>栈和队列本质上也是线性表，是操作受限的线性表。</p><h2 id="栈和队列的定义和特点"><a href="#栈和队列的定义和特点" class="headerlink" title="栈和队列的定义和特点"></a>栈和队列的定义和特点</h2><h3 id="栈的定义和特权"><a href="#栈的定义和特权" class="headerlink" title="栈的定义和特权"></a>栈的定义和特权</h3><p>栈是限定在表尾进行插入或删除操作的线性表。表尾端叫做<strong>栈顶</strong>，表头端叫做<strong>栈底</strong>，不含元素的空表称为<strong>空栈</strong>。</p><p>栈的修改按照后进先出的原则进行，被称为<strong>后进先出</strong>（LIFO）的线性表。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231616615.png"></p><p>相比数组和链表，栈更多的是限制，”没有”很明显的优势。不过，虽然从功能上来说，数组和链表确实可以替代栈，但它俩暴露了太多的操作接口，操作上灵活自由但使用时可能不太可控，容易出 bug。</p><p>因此，如果一个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这时应该首选”栈”这种数据结构。</p><h3 id="队列的定义和特点"><a href="#队列的定义和特点" class="headerlink" title="队列的定义和特点"></a>队列的定义和特点</h3><p>队列是一种<strong>先进先出</strong>（FIFO）的线性表，只允许在表的一端进行插入，另一端删除元素。</p><p>队列中允许插入的一端称为<strong>队尾</strong>，允许删除的一端称为<strong>队头</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231616493.png"></p><h2 id="栈的表示和操作的实现"><a href="#栈的表示和操作的实现" class="headerlink" title="栈的表示和操作的实现"></a>栈的表示和操作的实现</h2><h3 id="栈的类型定义"><a href="#栈的类型定义" class="headerlink" title="栈的类型定义"></a>栈的类型定义</h3><p>栈的抽象数据类型定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ADT Stack&#123;<br>    数据对象： D=&#123;ai|ai∈ElemSet, i=l, <span class="hljs-number">2</span>,..., n,n&gt;=<span class="hljs-number">0</span>&#125;<br>    数据关系： R= &#123;&lt;ai<span class="hljs-number">-1</span>,ai&gt;|ai<span class="hljs-number">-1</span>,,ai∈D, i=<span class="hljs-number">2</span>,...,n&#125;<br>        约定an端为栈顶， a1端为栈底。<br>    基本操作：<br>        <span class="hljs-built_in">InitStack</span>(&amp;S)<br>            操作结果：构造一个空栈s。<br>        <span class="hljs-built_in">DestroyStack</span>(&amp;S)<br>            初始条件：栈s巳存在。<br>            操作结果：栈S被销毁。<br>        <span class="hljs-built_in">ClearStack</span>(&amp;S)<br>            初始条件：栈S已存在。<br>            操作结果：将S清为空栈。<br>        StackEmpt <span class="hljs-built_in">y</span>(S)<br>            初始条件：栈S巳存在。<br>            操作结果：若栈s 为空栈， 则返回<span class="hljs-literal">true</span>, 否则返回<span class="hljs-literal">false</span>。<br>        <span class="hljs-built_in">StackLength</span> (S)<br>            初始条件：栈S已存在。<br>            操作结果：返回s的元素个数， 即栈的长度。<br>        <span class="hljs-built_in">GetTop</span>(S)<br>            初始条件：栈S已存在且非空。<br>            操作结果：返回s的栈顶元素， 不修改栈顶指针。<br>        <span class="hljs-built_in">Push</span>(&amp;S,e)<br>            初始条件：栈S已存在。<br>            操作结果：插入元素e为新的栈顶元素。<br>        <span class="hljs-built_in">Pop</span>(&amp;S,&amp;e)<br>            初始条件：栈s已存在且非空。<br>            操作结果：删除S的栈顶元素，并用e返回其值。<br>        <span class="hljs-built_in">StackTraverse</span>(S)<br>            初始条件：栈S已存在且非空。<br>            操作结果：从栈底到栈顶依次对S的每个数据元素进行访问。<br>&#125;ADT Stack<br></code></pre></td></tr></table></figure><h3 id="顺序栈的表示和实现"><a href="#顺序栈的表示和实现" class="headerlink" title="顺序栈的表示和实现"></a>顺序栈的表示和实现</h3><p>顺序栈指的是利用顺序存储结构实现的栈，使用 top 指针指示栈顶元素在顺序栈中的位置。通常做法是以 top&#x3D;&#x3D;0 表示空栈。但由于 C 语言中数组下标从 0 开始，所有另设指针 base 指示栈底元素在顺序栈中的位置，此时当 top 和 base 值相等时，表示空栈。</p><p>基于数组的栈，是一个固定大小的栈，需要事先制定栈的大小。不过要实现一个支持动态扩容的栈，只需要底层依赖一个支持动态扩容的数组就可以了。不过实际上，支持动态扩容的顺序栈在实际开发中用的比较少。</p><p>顺序栈的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    SElemType *base;  <span class="hljs-comment">//栈底指针</span><br>    SElemType *top;   <span class="hljs-comment">//栈顶指针</span><br>    <span class="hljs-type">int</span> stacksize;    <span class="hljs-comment">//栈可用的最大容量</span><br>&#125;SqStack;<br></code></pre></td></tr></table></figure><p>base 是栈底指针，始终指向栈底的位置，如果值为 NULL ，说明栈结构不存在。top 是栈顶指针，初值指向栈底，插入新元素时，指针 top 值加一，删除栈顶元素时指针 top 值减一。<strong>栈非空时，top 始终指向栈顶元素的上一个位置</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231616479.png"></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><strong>算法步骤</strong></p><ol><li>动态分配一个最大容量是 MAXSIZE 的数组空间，使 base 指向这段空间的基地址，即栈底。</li><li>栈顶指针 top 初始为 base，表示栈为空。</li><li>stacksize 置为栈的最大容量 MAXSIZE。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//构造一个空栈S</span><br>    S.base = <span class="hljs-keyword">new</span> SElemType [MAXSIZE];  <span class="hljs-comment">//为顺序栈分配一个最大容量为 MAXSIZE 的数组空间</span><br>    <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(OVERFLOW);        <span class="hljs-comment">//存储分配失败</span><br>    S.top = S.base;                    <span class="hljs-comment">//top 初始化为 base，空栈</span><br>    S.stacksize = MAXSIZE;             <span class="hljs-comment">//stacksize 置为栈的最大容量 MAXSIZE</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h4><p><strong>算法步骤</strong></p><ol><li>判断栈是否满，若满则返回 ERROR。</li><li>将新元素压入栈顶，栈顶指针加一。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S, SElemType e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//插入元素e为新的栈顶元素</span><br>    <span class="hljs-keyword">if</span>(S.top-S.base==S.stacksize) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//栈满</span><br>    *S.top++ = e;                                <span class="hljs-comment">//元素e压入栈顶，栈顶指针加一</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><p><strong>算法步骤</strong></p><ol><li>判断栈是否空，若空则返回 ERROR。</li><li>栈顶指针减一，栈顶元素出栈。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S, SElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//删除 S 的栈顶元素，用 e 返回其值</span><br>    <span class="hljs-keyword">if</span>(S.top==S.base) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//栈空</span><br>    e = *--S.top;                    <span class="hljs-comment">//栈顶指针减一，将栈顶元素赋给 e</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h4><p>当栈非空时，此操作返回当前栈顶元素的值，栈顶指针保持不变。</p><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SElemType <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//返回 S 的栈顶元素，不修改栈顶指针</span><br>    <span class="hljs-keyword">if</span>(S.top!=S.base)       <span class="hljs-comment">//栈非空</span><br>        <span class="hljs-keyword">return</span> *(S.top<span class="hljs-number">-1</span>);  <span class="hljs-comment">//返回栈顶元素的值，栈顶指针不变</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链栈的表示和实现"><a href="#链栈的表示和实现" class="headerlink" title="链栈的表示和实现"></a>链栈的表示和实现</h3><p>顺序栈和顺序表一样受到最大空间容量的限制，所以在无法预先估计最大容量的时候，应该使用链栈。</p><p>链栈的结构和单链表的结构相同，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackNode</span><br>&#123;<br>    ElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackNode</span> *next;<br>&#125;StackNode, *LinkStack;<br></code></pre></td></tr></table></figure><p>由于栈主要操作就是插入和删除，所以不用在加入头结点。（说到底，头结点只是为了操作方便的工具罢了，不是必须的）</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(LinkStack &amp;s)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//构造一个空栈 S，栈顶指针置空</span><br>    S = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="入栈-1"><a href="#入栈-1" class="headerlink" title="入栈"></a>入栈</h4><p>入栈不需要判断栈是否满，这一点和顺序栈有所不同，只需要为入栈元素分配一个结点空间。</p><p><strong>算法步骤</strong></p><ol><li>为入栈元素 e 分配空间，用指针 p 指向。</li><li>将新结点数据域置为 e。</li><li>将新结点插入栈顶。</li><li>修改栈顶指针为 p。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231616079.png"></p><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(LinkStack &amp;S,  SElemType e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//在栈顶插入元素 e</span><br>    p = <span class="hljs-keyword">new</span> StackNode;  <span class="hljs-comment">//生成新的结点</span><br>    p-&gt;data = e;        <span class="hljs-comment">//将新结点的数据域置为 e</span><br>    p-&gt;next = S;        <span class="hljs-comment">//将新结点插入栈顶</span><br>    S = p;              <span class="hljs-comment">//修改栈顶指针为 p</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h4><p>链栈出栈前不仅要判断栈是否为空，还要释放出栈元素的栈顶空间，这是和顺序栈不同的地方。</p><p><strong>算法步骤</strong></p><ol><li>判断栈是否为空，若空则返回 ERROR。</li><li>将栈顶元素赋给 e。</li><li>临时保存栈顶元素空间，以备释放。</li><li>修改栈顶指针，指向新的栈顶元素。</li><li>释放原栈顶元素的空间。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231616914.png"></p><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(LinkStack &amp;S, SELemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//删除 S 的栈顶元素，用 e 返回其值</span><br>    <span class="hljs-keyword">if</span>(S==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//栈空</span><br>    e = S-&gt;data;               <span class="hljs-comment">//将栈顶元素赋给 e</span><br>    p = S;                     <span class="hljs-comment">//用 p 临时保存栈顶元素空间，以备释放</span><br>    S = S-&gt;next;               <span class="hljs-comment">//修改栈顶指针</span><br>    <span class="hljs-keyword">delete</span> p;                  <span class="hljs-comment">//释放原栈顶元素的空间</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="取栈顶元素-1"><a href="#取栈顶元素-1" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h4><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SElemType <span class="hljs-title">GetTop</span><span class="hljs-params">(LinkStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(S!=<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> S-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h2><p>栈作为一个比较基础的数据结构，应用场景还是很多的。比较经典的应用场景就是函数调用栈。</p><p>操作系统给每个线程分配一块独立的内存空间，这块内存就被组织成”栈”这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p><h2 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h2><p>对于表达式求值，编译器通过两个栈实现运算。其中一个保存操作数的栈，另一个保存运算符的栈。从左向后遍历表达式，如果遇到数字就直接压入操作数栈；如果遇到运算符，就与运算符栈的栈顶元素进行比较。</p><p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的有限集低或相同，从运算符栈中取栈顶运算符，从操作数栈顶取两个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p><h2 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h2><h3 id="递归算法的应用情景"><a href="#递归算法的应用情景" class="headerlink" title="递归算法的应用情景"></a>递归算法的应用情景</h3><p><strong>递归</strong>：在一个函数、过程或者数据结构定义的内部又直接（或间接）出现定义本身的应用。</p><p>以下三种情况常使用递归方法：</p><h4 id="定义属于递归"><a href="#定义属于递归" class="headerlink" title="定义属于递归"></a>定义属于递归</h4><p><strong>递归求解</strong>：把一个复杂问题分解成几个相对简单且解法相同或类似的子问题来求解。</p><p>这种分解-求解的策略也叫做”分治法”。</p><p>采用”分治法”要满足以下三个条件：</p><ol><li>能将一个问题转化为新问题，并且它们解法相同，不同的仅仅是处理对象。</li><li>有一个明确的<strong>递归出口</strong>，又叫做<strong>递归的边界</strong>。</li></ol><h4 id="数据结构是递归的"><a href="#数据结构是递归的" class="headerlink" title="数据结构是递归的"></a>数据结构是递归的</h4><p>有些数据结构本身具有递归的特性，例如链表、广义表、二叉树等等。</p><h4 id="问题可以用递归求解"><a href="#问题可以用递归求解" class="headerlink" title="问题可以用递归求解"></a>问题可以用递归求解</h4><p>这里指问题采用递归求解更方便，考验脑子的时候到了。</p><h3 id="递归算法的效率分析"><a href="#递归算法的效率分析" class="headerlink" title="递归算法的效率分析"></a>递归算法的效率分析</h3><h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>算法分析中，如果一个算法包含递归调用时，时间复杂度可以转化为一个递归方程求解。迭代法是求解递归方程的一个常用方法，迭代的展开递归方程的右端，变成一个非递归的和式，然后通过对和式的估计来达到对方程左端的估计。</p><h4 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h4><p>分析递归算法的空间复杂度需要分析工作栈的大小。</p><p><code>S(n) = O(f(n))</code>，其中 f(n) 为”递归工作栈”中工作记录的个数与问题规模 n 的函数关系。</p><h3 id="利用栈将递归转化为非递归的方法"><a href="#利用栈将递归转化为非递归的方法" class="headerlink" title="利用栈将递归转化为非递归的方法"></a>利用栈将递归转化为非递归的方法</h3><p>步骤：</p><ol><li>设置一个递归工作栈存放递归工作记录（包括实参、返回地址及局部变量等）。</li><li>进入非递归调用入口，将调用程序传来的实参和返回地址入栈。</li><li>进入递归调用入口：不满足递归结束条件时，逐层递归，将实参、返回地址及局部变量入栈。这一步可以用循环语句完成。</li><li>递归结束条件满足，将到达递归出口的给定常数作为当前的函数值。</li><li>返回处理：栈非空的情况下，反复退出栈顶记录，逐层计算当前函数值，直到栈空为止。</li></ol><p>由于递归调用的特性，可以将任何递归算法改成非递归算法，但是改写后的算法和原来比结构不够清晰，可读性较差。</p><h2 id="队列的表示和操作的实现"><a href="#队列的表示和操作的实现" class="headerlink" title="队列的表示和操作的实现"></a>队列的表示和操作的实现</h2><h3 id="队列的类型定义"><a href="#队列的类型定义" class="headerlink" title="队列的类型定义"></a>队列的类型定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ADT Queue&#123;<br>    数据对象：D=&#123;aila∈ElemSet,i=l,<span class="hljs-number">2</span>,…,n,n&gt;=O&#125;<br>    数据关系：R=&#123;&lt;ai<span class="hljs-number">-1</span>,ai&gt;|ai,ai∈D,i=<span class="hljs-number">2</span>,…,n&#125;<br>        约定其中a1端为队列头，an端为队列尾。<br>    基本操作：<br>        <span class="hljs-built_in">InitQueue</span>(&amp;Q)<br>            操作结果：构造一个空队列Q。<br>        <span class="hljs-built_in">DestroyQueue</span>(&amp;Q)<br>            初始条件：队列Q已存在。<br>            操作结果：队列Q被销毁， 不再存在。<br>        <span class="hljs-built_in">ClearQueue</span>(&amp;Q)<br>            初始条件：队列Q巳存在。<br>            操作结果：将Q清为空队列。<br>        <span class="hljs-built_in">QueueEmpty</span>(Q)<br>            初始条件：队列Q已存在。<br>            操作结果：若Q为空队列，则返回<span class="hljs-literal">true</span>, 否则返回<span class="hljs-literal">false</span>。<br>        <span class="hljs-built_in">QueueLength</span>(Q)<br>            初始条件：队列Q已存在。<br>            操作结果：返回Q的元素个数，即队列的长度。<br>        <span class="hljs-built_in">GetHead</span>(Q&#125;<br>            初始条件：Q为非空队列。<br>            操作结果：返回Q的队头元素。<br>        <span class="hljs-built_in">EnQueue</span>(&amp;Q,e)<br>            初始条件：队列Q已存在。<br>            操作结果：插入元素e为Q的新的队尾元素。<br>        <span class="hljs-built_in">DeQueue</span>(&amp;Q,&amp; e)<br>            初始条件：Q为非空队列。<br>            操作结果：删除Q的队头元素，并用e 返回其值。<br>        <span class="hljs-built_in">QueueTraverse</span>(Q)<br>            初始条件：Q巳存在且非空。<br>            操作结果：从队头到队尾，依次对Q的每个数据元素访问。<br>&#125;ADT Queue<br></code></pre></td></tr></table></figure><h3 id="循环队列——队列的顺序表示和实现"><a href="#循环队列——队列的顺序表示和实现" class="headerlink" title="循环队列——队列的顺序表示和实现"></a>循环队列——队列的顺序表示和实现</h3><p>在队列的顺序存储结构中，需要附设两个整型变量 front 和 rear 分别指示队列头元素和队列尾元素的位置。</p><p>队列的顺序存储结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    QElemType *base;  <span class="hljs-comment">//存储空间的基地址</span><br>    <span class="hljs-type">int</span> front;        <span class="hljs-comment">//头指针</span><br>    <span class="hljs-type">int</span> rear;         <span class="hljs-comment">//尾指针</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><p>初始化创建空队列时，设置 front &#x3D; rear &#x3D; 0，插入新元素尾指针 rear 加一，删除队列头元素头指针 front 加一。头指针始终指向队列头元素，尾指针始终指向队列尾元素的下一个元素。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231617112.png"></p><p>但是这样的队列结构容易造成”假溢出”的现象。这是由”队尾入队，队头出队”这种限制的操作造成的。</p><p>解决”假溢出”的解决办法之一就是使用循环队列。</p><p>循环队列的核心在于对头尾指针进行取模操作。</p><p>但由于循环队列的特性，不能再使用头尾指针的值是否相同来判断队列空间是”满”还是”空”。面对这一情况有两种解决办法：</p><ol><li>少用一个元素空间，这样当头尾指针的值相同时可以判断队列为空，当尾指针在循环意义上加一后等于头指针的值，此时可以认为队列已满。循环队列中队空和队满的条件：<br>队空：<code>Q.front == Q.rear</code><br>队满：<code>(Q.rear + 1) % MAXSIZE == Q.front</code></li><li>另设一个标志位区分队列是”空”还是”满”。</li></ol><p>现在使用第一种方法实现循环队列。循环队列的类型定义和顺序队列是一样的。</p><h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4><p>初始化就是动态分配分配一个数组空间。</p><p><strong>算法步骤</strong></p><ol><li>为队列分配一个最大容量为 MAXSIZE 的数组空间，base 指向数组空间的首地址。</li><li>头指针和尾指针设置为 0，表示队列为空。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">status <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//构造空队列 Q</span><br>    Q.base = <span class="hljs-keyword">new</span> QElemType[MAXSIZE];  <span class="hljs-comment">//为队列分配一个最大容量为 MAXSIZE 的数组空间</span><br>    <span class="hljs-keyword">if</span>(!Q.base) <span class="hljs-built_in">exit</span>(OVERFLOW);       <span class="hljs-comment">//存储分配失败</span><br>    Q.front = Q.rear = <span class="hljs-number">0</span>;             <span class="hljs-comment">//头尾指针设置为0，队列为空</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="求队列长度"><a href="#求队列长度" class="headerlink" title="求队列长度"></a>求队列长度</h4><p>对于顺序队列而言，头尾指针之差就是队列长度。但对于循环队列而言显然不同，此时差值可能为负数。所以要给差值加上 MAXSIZE ，然后再求模。</p><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QueueLength</span><span class="hljs-params">(SqQueue Q)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (Q.rear-Q.front+MAXSIZE)%MAXSIZE;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><p><strong>算法步骤</strong></p><ol><li>判断队列是否为满，如果已满则返回 ERROR。</li><li>将新元素插入队尾。</li><li>队尾指针加一。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q,QElemType e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//插入元素 e 为 Q 的新的队尾元素</span><br>    <span class="hljs-keyword">if</span>((Q.rear<span class="hljs-number">+1</span>)%MAXSIZE==Q.front)   <span class="hljs-comment">//尾指针在循环意义上加一后等于头指针表示队列已满</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>    Q.base[Q.rear] = e;               <span class="hljs-comment">//新元素插入队尾</span><br>    Q.rear = (Q.rear + <span class="hljs-number">1</span>) % MAXSIZE;  <span class="hljs-comment">//队尾指针加一</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h4><p><strong>算法步骤</strong></p><ol><li>判断队列是否为空，若空则返回 ERROR。</li><li>保存队头元素。</li><li>队头指针加一。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q,QElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//删除 Q 的队头元素，用 e 返回其值</span><br>    <span class="hljs-keyword">if</span>(Q.front==Q.rear) <span class="hljs-keyword">return</span> ERROR;   <span class="hljs-comment">//队空</span><br>    e = Q.base[Q.front];                <span class="hljs-comment">//保存队头元素</span><br>    Q.front = (Q.front + <span class="hljs-number">1</span>) % MAXSIZE;  <span class="hljs-comment">//队头指针加一</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="取队头元素"><a href="#取队头元素" class="headerlink" title="取队头元素"></a>取队头元素</h4><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SElemType <span class="hljs-title">GetQueue</span><span class="hljs-params">(SqQueue Q)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//返回 Q 对队头元素，不修改队头指针</span><br>    <span class="hljs-keyword">if</span>(Q.front != Q.rear)        <span class="hljs-comment">//队列非空</span><br>        <span class="hljs-keyword">return</span> Q.base[Q.front];  <span class="hljs-comment">//返回队头元素的值，队头指针不变</span><br>&#125;<br></code></pre></td></tr></table></figure><p>循环队列说到底也属于顺序存储，还是有队列的最大长度。如果无法预测队列的最大长度，最好采用链队。</p><h3 id="链队——队列的链式表示和实现"><a href="#链队——队列的链式表示和实现" class="headerlink" title="链队——队列的链式表示和实现"></a>链队——队列的链式表示和实现</h3><p>链队通常用单链表来表示。一个链队需要两个分别指示队头和队尾的指针。为了操作方便可以给链队添加一个头结点，让头指针始终指向头结点。</p><p>队列的链式存储结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">QNode</span><br>&#123;<br>    QElemType data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">QNode</span> *next;<br>&#125;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    QueuePtr front;  <span class="hljs-comment">//队头指针</span><br>    QueuePtr rear;   <span class="hljs-comment">//队尾指针</span><br>&#125;<br></code></pre></td></tr></table></figure><p>链队的操作即为单链表插入和删除操作的特殊情况，就是需要再注意一下尾指针或头指针的修改。</p><h4 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h4><p>构造一个只有一个头结点的空对。</p><p><strong>算法步骤</strong></p><ol><li>生产新结点作为头结点，队头和队尾指针指向此结点。</li><li>头结点的指针域置空。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span><br><span class="hljs-function"></span>&#123;<br>    Q.front = Q.reat = <span class="hljs-keyword">new</span> QNode;  <span class="hljs-comment">//生成新结点作为头结点，队头和队尾指针指向此结点</span><br>    Q.front-&gt;next = <span class="hljs-literal">NULL</span>;          <span class="hljs-comment">//头结点的指针域置空</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h4><p>由于链队可以”无限”添加元素，所以不需要像顺序队列那样判断队列是否满，只需要为入队元素动态分配一个结点空间。</p><p><strong>算法步骤</strong></p><ol><li>为入队元素分配结点空间，用指针 p 指向。</li><li>将新结点数据域置为 e。</li><li>将新结点插入到队尾。</li><li>修改队尾指针为 p。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231617287.png"></p><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q,QElemType e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//插入元素 e 为 Q 的新的队尾元素</span><br>    p = <span class="hljs-keyword">new</span> QNode;     <span class="hljs-comment">//为入队元素分配结点空间，用指针 p 指向</span><br>    p-&gt;data = e;       <span class="hljs-comment">//将新结点指针域置为 e</span><br>    p-&gt;next = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//将新结点插入队尾</span><br>    Q.rear-&gt;next = p;<br>    Q.rear = p;        <span class="hljs-comment">//修改队尾指针</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h4><p>出队就需要判断链队是否为空了。并且链队出队后需要放出队头元素所占空间。</p><p><strong>算法步骤</strong></p><ol><li>判断队列是否为空，若空则返回 ERROR。</li><li>临时保存队头元素的空间，以备释放。</li><li>修改头结点的指针域，指向下一个结点。（头结点的优点就体现出来了）</li><li>判断出队元素是否为最后一个元素，若是则将队尾指针重新赋值，指向头结点。</li><li>释放原队头元素的空间。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q,QElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//删除 Q 的队头元素，用 e 返回其值</span><br>    <span class="hljs-keyword">if</span>(Q.front==Q.rear) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//若队列为空则返回 ERROR</span><br>    p = Q.front-&gt;next;                 <span class="hljs-comment">//p 指向队头元素</span><br>    e = p-&gt;data;                       <span class="hljs-comment">//e 保持队头元素的值</span><br>    Q.front-&gt;next = p-&gt;next;           <span class="hljs-comment">//修改头结点的指针域</span><br>    <span class="hljs-keyword">if</span>(Q.rear==p)                      <span class="hljs-comment">//如果最后一个元素被删</span><br>        Q.rear = Q.front;              <span class="hljs-comment">//那就将队尾指针指向头结点</span><br>    <span class="hljs-keyword">delete</span> p;                          <span class="hljs-comment">//释放原队头元素的空间</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>链队出队操作要考虑如果队列最后一个元素被删，队列尾指针也丢失了，要给队尾指针重新复制指向头结点。</p><h4 id="取队头元素-1"><a href="#取队头元素-1" class="headerlink" title="取队头元素"></a>取队头元素</h4><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SElemType <span class="hljs-title">GetHead</span><span class="hljs-params">(LinkQueue Q)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//返回 Q 的队头元素，不修改队头指针</span><br>    <span class="hljs-keyword">if</span>(Q.front!=Q.rear)              <span class="hljs-comment">//队列非空</span><br>        <span class="hljs-keyword">return</span> Q.front-&gt;next-&gt;data;  <span class="hljs-comment">//返回队头元素的值，队头指针不变</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231617730.png"></p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231617726.png"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表</title>
    <link href="/2025/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2025/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>线性结构的基本特点：除第一个元素无直接前驱，最后一个元素无直接后驱之外，其他每个数据元素都有一个前驱和后驱。</p><h2 id="线性表的定义和特点"><a href="#线性表的定义和特点" class="headerlink" title="线性表的定义和特点"></a>线性表的定义和特点</h2><p><strong>线性表</strong>：由 n 个数据特性相同的元素构成的有限序列称为线性表。</p><p>n&#x3D;0 时称为<strong>空表</strong>。</p><p>线性表既可以使用顺序存储也可以使用链式存储。</p><h2 id="线性表的类型定义"><a href="#线性表的类型定义" class="headerlink" title="线性表的类型定义"></a>线性表的类型定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ADT list&#123;<br>    数据对象:D=&#123;ai|ai属于ElemSet,i=<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,...,n,n&gt;=<span class="hljs-number">0</span>&#125;<br>    数据关系R=&#123;&lt;ai<span class="hljs-number">-1</span>,ai&gt;|ai<span class="hljs-number">-1</span>,ai属于D,i=<span class="hljs-number">2</span>,...,n&#125;<br>    基本操作:<br>        <span class="hljs-built_in">InitList</span>(&amp;L)<br>            操作结果:构造一个空的线性表L。<br>        <span class="hljs-built_in">DestroyList</span>(&amp;L)<br>            初始条件:线性表L已存在。<br>            操作结果:销毁线性表L。<br>        <span class="hljs-built_in">ClearList</span> (&amp;L)<br>            初始条件：线性表L已存在。<br>            操作结果：将L重置为空表。<br>        <span class="hljs-built_in">ListEmpty</span>(L)<br>            初始条件：线性表L已存在。<br>            操作结果：若L为空表， 则返回<span class="hljs-literal">true</span>, 否则返回<span class="hljs-literal">false</span>。<br>        <span class="hljs-built_in">ListLength</span>(L)<br>            初始条件：线性表L已存在。<br>            操作结果：返回L中数据元素个数。<br>        <span class="hljs-built_in">GetElem</span>(L,i,&amp;e)<br>            初始条件：线性表L巳存在， 且<span class="hljs-number">1</span>&lt;=s&lt;=<span class="hljs-built_in">ListLength</span>(L)。<br>            操作结果：用e返回L中第<span class="hljs-number">1</span>个数据元素的值。<br>        <span class="hljs-built_in">LocateElem</span>(L,e)<br>            初始条件：线性表L已存在。<br>            操作结果：返回L中第<span class="hljs-number">1</span>个值与e相同的元素在L中的位置。若这样的数据元素不存在， 则返回值为<span class="hljs-number">0</span>。<br>        <span class="hljs-built_in">PriorElem</span>(r,,cur_e,&amp;pre_e)<br>            初始条件：线性表L已存在。<br>            操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回其前驱，否则操作失败，pre_e无定义。<br>        <span class="hljs-built_in">NextElem</span>(L,cur_e,&amp;next_e)<br>            初始条件：线性表L已存在。<br>            操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回其后继，否则操作失败，next_e无定义。<br>        <span class="hljs-built_in">Listinsert</span>(&amp;L,i,e)<br>            初始条件： 线性表L已存在，且<span class="hljs-number">1</span>&lt;=s&lt;=<span class="hljs-built_in">ListLength</span>(L)+l。<br>            操作结果：在L中第<span class="hljs-number">1</span>个位置之前插入新的数据元素e, L的长度加<span class="hljs-number">1</span>。<br>        <span class="hljs-built_in">ListDelete</span>(&amp;L,i)<br>            初始条件：线性表L 已存在且非空，且<span class="hljs-number">1</span>&lt;=s&lt;=<span class="hljs-built_in">ListLength</span>(L)。<br>            操作结果：删除L的第<span class="hljs-number">1</span>个数据元素，L的长度减<span class="hljs-number">1</span>。<br>        <span class="hljs-built_in">TraverseList</span>(L)<br>            初始条件：线性表L已存在。<br>            操作结果：对线性表L进行遍历，在遍历过程中对L的每个结点访问一次。<br>&#125;ADT List;<br></code></pre></td></tr></table></figure><h2 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h2><h3 id="线性表的顺序存储表示"><a href="#线性表的顺序存储表示" class="headerlink" title="线性表的顺序存储表示"></a>线性表的顺序存储表示</h3><p><strong>线性表的顺序存储表示</strong>：用一组地址连续的存储单元依次存储线性表的数据元素。称这种存储结构的线性表为<strong>顺序表</strong>。</p><p>其<strong>特点</strong>是：逻辑上相邻的数据元素，其物理次序也是相邻的。</p><p>线性表的顺序存储是一种<strong>随机存取</strong>的存储结构，由于通常都用数组来描述数据结构中的顺序存储结构，并且线性表的长度可变，在 C 语言中可用动态分配的一维数组表示线性表，描述如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100    <span class="hljs-comment">//顺序表可能达到的最大长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    ElemType *elem;    <span class="hljs-comment">//存储空间的基地址</span><br>    <span class="hljs-type">int</span> length;        <span class="hljs-comment">//当前长度</span><br>&#125;SqList                <span class="hljs-comment">//顺序表的结构类型为SqList</span><br></code></pre></td></tr></table></figure><p>其中，ElemType 数据类型可以替换成具体定义表中数据元素的数据类型，既可以是基本数据类型，也可以是构造数据类型（如 struct 结构体类型）。</p><h3 id="顺序表中基本操作的实现"><a href="#顺序表中基本操作的实现" class="headerlink" title="顺序表中基本操作的实现"></a>顺序表中基本操作的实现</h3><p>当线性表以顺序表示时，表的长度是顺序表的一个”属性”，因此一些涉及表长度的基本操作算法的时间复杂度都是 O(1)</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>顺序表的初始化操作就是构造一个空的顺序表</p><p><strong>算法步骤</strong></p><ol><li>为顺序表 L 动态分配一个预定义大小的数组空间，使 elem 指向这段空间的基地址</li><li>将表的当前长度设为 0</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(SqList &amp;L)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//构造一个空的顺序表</span><br>    L.elem = <span class="hljs-keyword">new</span> ElemType[MAXSIZE];    <span class="hljs-comment">//为顺序表分配一个大小为MAXSIZE的数组空间</span><br>    <span class="hljs-keyword">if</span>(!L.elem) <span class="hljs-built_in">exit</span>(OVERFLOW);        <span class="hljs-comment">//存储分配失败退出</span><br>    L.length = <span class="hljs-number">0</span>;                      <span class="hljs-comment">//空表长度为0</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>采用动态分配线性表的存储区域可以更有效的利用系统资源，当不需要该线性表时，可以使用销毁操作及时释放占用的存储空间</p><h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><p>由于顺序存储结构具有随机存储的特点，可以直接通过数组下标定位得到，elem[i]单元存储第 i 个数据元素。</p><p><strong>算法步骤</strong></p><ol><li>判断指定的位置序号 i 值是否合理，如果不合理则返回 ERROR。</li><li>若 i 值合理，则将第 i 个数据元素 L.elem[i-1]赋给参数 e，通过 e 返回第 i 个数据元素的传值。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L,<span class="hljs-type">int</span> i,ElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length) <span class="hljs-keyword">return</span> ERROR;    <span class="hljs-comment">//判断i值是否合理，若不合理，返回ERROR</span><br>    e = L.elem[i<span class="hljs-number">-1</span>];                     <span class="hljs-comment">//elem[i-1]单元存储第i个数据元素</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>顺序表取值算法的时间复杂度为 O(1)。</p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>查找操作根据指定元素值 e，查找顺序表中第 1 个与 e 相等的元素 L.elem[i]，若查找成功返回该元素的序号 i+1；若查找失败，则返回 0.</p><p><strong>算法步骤</strong></p><ol><li>从第一个元素开始，依次与 e 相比较，若找到与 e 相等的元素 L.elem[i]，则查找成功，返回该元素的序号 i+1。</li><li>若查找整个顺序表都没找到，则查找失败，返回 0。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList L,ElemType e)</span></span><br><span class="hljs-function"></span>&#123;在顺序表L中查找值为e的数据元素，返回其序号<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;L.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(L.elem[i] == e)    <span class="hljs-comment">//查找成功，返回序号i+1</span><br>            <span class="hljs-keyword">return</span> i<span class="hljs-number">+1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                 <span class="hljs-comment">//查找失败，返回0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在顺序表中查找数据元素时，时间主要耗费在数据的比较上，比较的次数取决于被查元素在线性表中的位置。</p><p>设定查找算法在查找成功时的平均查找长度（ASL）为和给定值进行比较大数据元素个数的期望值。</p><p>顺序表按值查找算法的平均时间复杂度为 O(n)。</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>一般情况下，在线性表第 i 个位置插入一个元素时，需从最后一个元素即第 n 个元素开始，依次向后移动一个位置，直至第 i 个元素。</p><p><strong>算法步骤</strong></p><ol><li>判断插入位置 i 是否合法，若不合法则返回 ERROR</li><li>判断顺序表的存储空间是否已满，若满则返回 ERROR</li><li>将第 n 个至第 i 个位置的元素依次向后移动一个位置，空出第 i 个位置</li><li>将要插入的新元素 e 放入第 i 个位置</li><li>表长加 1</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//在顺序表L中第i个为位置之前插入新的元素e，i的合法范围是[1,L.length]</span><br>    <span class="hljs-keyword">if</span>((i &lt; <span class="hljs-number">1</span>) || (i &gt; L.length<span class="hljs-number">+1</span>)) <span class="hljs-keyword">return</span> ERROR;    <span class="hljs-comment">//i值不合法</span><br>    <span class="hljs-keyword">if</span>(L.length == MAXSIZE) <span class="hljs-keyword">return</span> ERROR;            <span class="hljs-comment">//当前存储空间已满</span><br>    <span class="hljs-keyword">for</span>(j=L.length<span class="hljs-number">-1</span>;j&gt;=i<span class="hljs-number">-1</span>;j--)&#123;<br>        L.elem[j<span class="hljs-number">+1</span>] = L.elem[j];                     <span class="hljs-comment">//插入位置及之后的元素后移</span><br>    &#125;<br>    L.elem[i<span class="hljs-number">-1</span>]=e;                                   <span class="hljs-comment">//将新元素e放入第i个位置</span><br>    ++L.length;                                      <span class="hljs-comment">//表长加1</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>顺序表插入算法的平均时间复杂度为 O(n)。</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除第 i 个元素时需将第 i+1 个至第 n 个元素依次向前移动一个位置</p><p><strong>算法步骤</strong></p><ol><li>判断删除位置 i 是否合法，若不合法返回 ERROR。</li><li>将第 i+1 个至第 n 个点元素依次向前移动一个位置。</li><li>表长减 1。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//在顺序表中删除第i个元素，i的合法范围是[1,L.length]</span><br>    <span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L.length)) <span class="hljs-keyword">return</span> ERROR;    <span class="hljs-comment">//i值不合法</span><br>    <span class="hljs-keyword">for</span>(j=i;j&lt;=L.length<span class="hljs-number">-1</span>;j++)<br>        L.elem[j<span class="hljs-number">-1</span>] = L.elem[j];             <span class="hljs-comment">//被删除元素之后的元素前移</span><br>    --L.length;                              <span class="hljs-comment">//表长减1</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>顺序表删除算法的平均时间复杂度为 O(n)。</p><p>在做插入或删除操作时，需要移动大量元素，同时导致操作过程相对复杂，导致存储空间的浪费，需要使用链式存储结构来解决这些难题。</p><h2 id="线性表的链式表示和实现"><a href="#线性表的链式表示和实现" class="headerlink" title="线性表的链式表示和实现"></a>线性表的链式表示和实现</h2><h3 id="单链表的定义和表示"><a href="#单链表的定义和表示" class="headerlink" title="单链表的定义和表示"></a>单链表的定义和表示</h3><p><strong>线性表链式存储结构的特点</strong>：用一组任意的存储单元存储线性表的数据元素。</p><p>为了实现这样的特点，对于每个数据元素，除去本身的信息，还需要存储一个指示其直接后继的信息，用来展示它们之间的逻辑关系。这两部分信息组成数据元素的存储映像，称作<strong>结点。</strong></p><p>结点包括两个域：</p><ul><li><strong>数据域</strong>：存储数据元素信息的域。</li><li><strong>指针域</strong>：存储直接后继存储位置的域。</li></ul><p>指针域中存储的信息被称作<strong>指针</strong>或<strong>链</strong>。</p><p>n 个结点链结成一个<strong>链表</strong>，即为<strong>线性表的链式存储结构</strong></p><p>这样的链表的每个结点中只包含一个指针域，所以又被称作<strong>线性链表</strong>或<strong>单链表</strong>。单链表、循环链表和双向链表用于实现线性链表的链式存储结构，其他形式多用于实现树和图等非线性结构。</p><p>整个链表的存取必须从头指针开始进行，头指针指示链表中的第一个结点的存储位置，单链表中最后一个结点的指针为空（NULL）。用单链表表示线性表时，数据元素之间的逻辑关系是由结点中的指针指示的，个个结点物理位置不相邻，并不关心它们的实际位置。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231606780.png"></p><p>单链表可由头指针唯一确定，在 C 语言中可用”结构指针”来描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span><br>&#123;<br>    ElemType data;         <span class="hljs-comment">//结点的数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> *next;    <span class="hljs-comment">//结点的指针域</span><br>&#125;LNode,*LinkList;          <span class="hljs-comment">//LinkList为指向结构体LNode的指针类型</span><br></code></pre></td></tr></table></figure><p>习惯上用 LinkList 定义单链表，使用 LNode*定义指向单链表中任意结点的指针变量。</p><p>注意区分指针变量和结点变量两个不同的概念，如果定义 LinkList p 或 LNode <em>p，则 p 为指向某结点的指针变量，表示该结点的地址；而</em>p 为对应的结点变量，表示该结点的名称。</p><p>一般情况下，为了处理方便，在单链表的第一个结点之前附设一个结点，称之为头结点。</p><p>头结点的优点：</p><ul><li>便于首元结点的处理<br>增加头结点后，首元结点的地址保存在头结点的指针域中，取消了首元结点的特殊性。</li><li>便于空表和非空表的统一处理<br>当链表不设头结点时，如果为空表，L 指针为空（NULL）<br>增加头结点后，无论链表是否为空，头指针都是指向头结点的非空指针，若为空表，则头结点的指针域为空（判定空表的条件：L-&gt;next &#x3D;&#x3D; NULL）</li></ul><p>区分首元结点、头结点、头指针：</p><ul><li>首元结点：链表中存储第一个数据元素的结点</li><li>头结点：首元结点之前附设的一个结点，其指针域指向首元结点</li><li>头指针：指向链表汇总第一个结点的指针，指向头结点（如果有）或首元结点（如果没有头结点）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231607496.png"></p><p>由于单链表是非随机存取的存储结构，要取得第 i 个元素必须从头指针出发顺链进行寻找，也就是顺序存取结构。</p><h3 id="单链表基本操作的实现"><a href="#单链表基本操作的实现" class="headerlink" title="单链表基本操作的实现"></a>单链表基本操作的实现</h3><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>单链表的初始化操作就是构造一个空表。</p><p><strong>算法步骤</strong></p><ol><li>生成新结点作为头结点，用头指针 L 指向头结点</li><li>头结点指针域置空</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(LinkList &amp;L)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//构造一个空的单链表L</span><br>    L = <span class="hljs-keyword">new</span> LNode;     <span class="hljs-comment">//生成新结点作为头结点，用头指针L指向头结点</span><br>    L-&gt;next = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//头结点指针域置空</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="取值-1"><a href="#取值-1" class="headerlink" title="取值"></a>取值</h4><p>由于链表非随机存取的特性，只能从链表的首元结点出发，顺着链域 next 逐个结点向下访问。</p><p><strong>算法步骤</strong></p><ol><li>用指针 p 指向首元结点，用 j 做计数器初值赋为 1。</li><li>从首元结点开始依次顺着链域 next 向下访问，只要指向当前结点的指针 p 不为空，并且没有到达序号为 i 的结点，则循环执行以下操作：</li></ol><ul><li>p 指向下一个结点</li><li>计数器 j 相应加 1</li></ul><ol start="3"><li>退出循环时，如果指针 p 为空，或者计数器 j 大于 i，说明指定的序号 i 值不合法，取值失败返回 ERROR；否则取值成功，此时 j&#x3D;i 时，p 所指的结点就是要找的第 i 个结点，用参数 e 保存当前结点的数据域，返回 OK。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L,<span class="hljs-type">int</span> i,ElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//在带头结点的单链表L中根据序号i获取元素的值，用e返回L中第i个数据元素的值</span><br>    p = L-&gt;next;j=<span class="hljs-number">1</span>;           <span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">while</span>(p&amp;&amp;j&lt;i)&#123;             <span class="hljs-comment">//顺链域扫描</span><br>        p = p-&gt;next;           <span class="hljs-comment">//p指向下一个结点</span><br>        ++j;                   <span class="hljs-comment">//计数器+1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p||j&gt;i) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//i值不合法</span><br>    e=p-&gt;data;                 <span class="hljs-comment">//取得第i个结点的数据域</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>算法的最坏时间复杂度为 O(n)，平均时间复杂度为 O(n)。</p><h4 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h4><p>链表中按值查找的过程和顺序表类似</p><p><strong>算法步骤</strong></p><ol><li>用指针 p 指向首元结点。</li><li>从首元结点开始依次顺着链域 next 向下查找，只要指向当前结点的指针 p 不为空，并且 p 所指结点的数据域不等于给定值 e，则循环执行以下操作：p 指向下一个结点。</li><li>返回 p，若查找成功，p 此时即为结点的地址值，若查找失败，p 的值即为 NULL。</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">LNode *<span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L,Elemtype e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//在带头结点的单链表L中查找值为e的元素</span><br>    p = L-&gt;next;            <span class="hljs-comment">//初始化，p指向首元结点</span><br>    <span class="hljs-keyword">while</span>(P &amp;&amp; p-&gt;data!=e)  <span class="hljs-comment">//顺链域向后扫描</span><br>        p = p-&gt;next;        <span class="hljs-comment">//p指向下一结点</span><br>    <span class="hljs-keyword">return</span> p;               <span class="hljs-comment">//查找成功返回值为e的结点地址p，查找失败p为NULL</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该算法的平均时间复杂度为 O(n)。</p><h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><p>插入数据元素 x，要先生成一个数据域为 x 的结点，然后插入到单链表中。插入操作需要先修改前置结点中的指针域，令其指向结点 x，结点 x 中的指针域应指向后继结点，从而实现三个元素之间逻辑关系的变化。上述过程用代码描述即为：<code>s-&gt;next = p-&gt;next; p-&gt;next = s</code></p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231608867.png"></p><p><strong>算法步骤</strong></p><ol><li>查找结点 ai-1 并由指针 p 指向该结点</li><li>生成一个新结点*s</li><li>将新结点*s 的数据域置为 e</li><li>将新结点*s 的指针域指向结点 ai</li><li>将结点<em>p 的指针域指向新结点</em>s</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>    p = L;j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">0</span> &amp;&amp; (j&lt;i<span class="hljs-number">-1</span>))&#123;<br>        p = p-&gt;next;             <span class="hljs-comment">//查找第i-1个结点，p指向该结点</span><br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p||j&gt;i<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//i&gt;n+1或i&lt;1</span><br>    s = <span class="hljs-keyword">new</span> LNode;               <span class="hljs-comment">//生成新结点s</span><br>    s-&gt;data = e;                 <span class="hljs-comment">//将结点*s的数据域置为e</span><br>    s-&gt;next = p-&gt;next;           <span class="hljs-comment">//将结点*s的指针域指向结点ai</span><br>    p-&gt;next = s;                 <span class="hljs-comment">//将结点*p的指针域指向结点*s</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，单链表的插入操作虽然不需要像顺序表的插入操作一样移动元素，但是平均时间复杂度仍然是 O(n)。这是因为单链表是非随机存取的结构，要花费大量的时间找到第 i-1 个结点。</p><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>删除和插入一样，都要先找到该位置的前驱结点，所以时间复杂度是 O(n)。</p><p>要实现删除某一结点，只需要将前驱结点的指针域指向后继结点即可。不过需要注意的是，要实现真正的删除，还要释放目标结点所占的空间，在修改指针前，应该引入一个指针临时保存结点 b 的地址以备释放。</p><p><strong>算法步骤</strong></p><ol><li>查找结点 ai-1 并由指针 p 指向该结点</li><li>临时保存待删除结点 ai 的地址在 q 中，以备释放</li><li>将结点*p 的指针域指向 ai 的直接后继结点</li><li>释放结点 ai 的空间</li></ol><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    p = L;j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>((p-&gt;next) &amp;&amp; (j&lt;i<span class="hljs-number">-1</span>))&#123;           <span class="hljs-comment">//查找第i个结点，p指向该结点</span><br>        p = p-&gt;next;<br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!(p-&gt;next)||(j&gt;i<span class="hljs-number">-1</span>)) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//当i&gt;n或i&lt;1时，删除位置不合理</span><br>    q = p-&gt;next;                           <span class="hljs-comment">//临时保存被删结点的地址以备释放</span><br>    p-&gt;next = q-&gt;next;                     <span class="hljs-comment">//改变删除结点前驱结点的指针域</span><br>    <span class="hljs-keyword">delete</span> q;                              <span class="hljs-comment">//释放删除结点的空间</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，删除操作的循环条件<code>(p-&gt;next) &amp;&amp; (j&lt;i-1)</code>和插入操作的循环条件<code>p&amp;&amp; (j&lt;i-1)</code>是有区别的——插入操作中合法的插入位置有 n+1 个，而删除操作中合法的删除操作只有 n 个，此时如果使用与插入操作相同的循环条件，则会出现引用空指针的情况，会使删除操作失败。</p><p>删除算法的时间复杂度也是 O(n)。</p><h4 id="创建单链表"><a href="#创建单链表" class="headerlink" title="创建单链表"></a>创建单链表</h4><p>链表是一种动态结构，整个可用存储空间可为多个链表共同享用（整体结构非常松散），每个链表占用的空间不需要预先分配划定，而是由系统按需即时生成。</p><p>根据结点插入位置不同，可以分为前插法和后插法</p><h5 id="前插法"><a href="#前插法" class="headerlink" title="前插法"></a>前插法</h5><p>前插法通过将新结点逐个插入链表的头部来创建链表。需要注意的是，前插法输入顺序和线性表中的逻辑顺序应该是相反的，要逆序输入数据。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231608909.png"></p><p><strong>算法步骤</strong></p><ol><li>创建一个只有头结点的空链表</li><li>根据待创建链表包括的元素个数 n，循环 n 次执行以下操作：</li></ol><ul><li>生成一个新结点*p</li><li>输入元素值赋给新结点*p 的数据域</li><li>将新结点*p 插入到头结点之后</li></ul><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_H</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    L = <span class="hljs-keyword">new</span> LNode;<br>    L-&gt;next = <span class="hljs-literal">NULL</span>;         <span class="hljs-comment">//先建立一个带头结点的空链表</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        p = <span class="hljs-keyword">new</span> LNode;      <span class="hljs-comment">//生成新结点*p</span><br>        cin&gt;&gt;p-&gt;data;       <span class="hljs-comment">//输入元素值符给新结点*p的数据域</span><br>        p-&gt;next = L-&gt;next;  <span class="hljs-comment">//将新结点*p插入到头结点之后</span><br>        L-&gt;next = p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然算法的时间复杂度为 O(n)。</p><h5 id="后插法"><a href="#后插法" class="headerlink" title="后插法"></a>后插法</h5><p>后插法可以按照顺序添加，但是与前插法不同的是，为了使新结点能够插入到表尾，需要增加一个尾指针 r 指向链表的尾结点。</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231609169.png"></p><p><strong>算法步骤</strong></p><ol><li>创建一个只有头结点的空链表</li><li>尾指针 r 初始化，指向头结点</li><li>根据创建链表包括的元素个数 n，循环 n 次执行以下操作：</li></ol><ul><li>生成一个新结点*p</li><li>输入元素值赋给新结点*p 的数据域</li><li>将新结点<em>p 插入到尾结点</em>r 之后</li><li>尾指针指向新的尾结点*p</li></ul><p><strong>算法描述</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_R</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    L = <span class="hljs-keyword">new</span> LNode;<br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<br>    r = L;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        p = <span class="hljs-keyword">new</span> LNode;<br>        cin&gt;&gt;p-&gt;data;<br>        p-&gt;next = <span class="hljs-literal">NULL</span>;<br>        r-&gt;next = p;<br>        r = p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>算法的时间复杂度为 O(n</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表的特点是表中最后一个结点的指针域指向头结点。由此从表中任一结点出发均可找到表中其他结点。</p><p>循环单链表和单链表唯一的差别就在于：链表遍历时，判别当前指针 p 是否指向表尾结点的终止条件不同——单链表判别条件是<code>p!=NULL或p-&gt;next!-NULL</code>，而循环单链表的判别条件为<code>p!=L或p-&gt;next!=L</code></p><p>某些条件下若在循环链表中设立尾指针而不设头指针，可使一些操作简化。（说到底，头指针也只是为了操作简化，并不是必须的）</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>在单链表和循环单链表中，查找直接后继结点的执行时间为 O(1)，而查找直接前驱的执行时间为 O(n)。为了克服这个缺点可以使用双向链表。</p><p>双向链表有两个指针域，一个指向直接后继，另一个指向直接前驱，结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DulNode</span><br>&#123;<br>    ElemType data;          <span class="hljs-comment">//数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DulNode</span> *prior;  <span class="hljs-comment">//直接前驱</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DulNode</span> *next;   <span class="hljs-comment">//直接后继</span><br>&#125;DulNode,*DuLinkList;<br></code></pre></td></tr></table></figure><p>双向链表也可以有循环表。此时链表中有两个环。</p><p>在双向链表中，有些操作仅需涉及一个方向的指针，则它们的算法描述和线性链表的操作相同，但是插入、删除有很大的不同。双向链表中需要同时修改两个方向的指针——插入结点时需要修改四个指针，删除结点时需要修改两个指针，它们的时间复杂度都是 O(n)。</p><h4 id="双向链表的插入"><a href="#双向链表的插入" class="headerlink" title="双向链表的插入"></a>双向链表的插入</h4><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231610748.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">ListInsert_Dul</span><span class="hljs-params">(DulLinkList &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!(p=<span class="hljs-built_in">GetElem_DuL</span>(L,i)))  <span class="hljs-comment">//在L中确定第i个元素的位置指针</span><br>        <span class="hljs-keyword">return</span> ERROR;          <span class="hljs-comment">//p为NULL时，第i个元素不存在</span><br>    s = <span class="hljs-keyword">new</span> DulNode;           <span class="hljs-comment">//生成新结点*s</span><br>    s-&gt;data = e;               <span class="hljs-comment">//将结点*s数据域置为e</span><br>    s-&gt;prior = p-&gt;prior;       <span class="hljs-comment">//将结点*s插入L中</span><br>    p-&gt;prior-&gt;next = s;<br>    s-&gt;next = p;<br>    p-&gt;prior = s;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="双向链表的删除"><a href="#双向链表的删除" class="headerlink" title="双向链表的删除"></a>双向链表的删除</h4><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231611429.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(DULinkList &amp;L,<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!(p=<span class="hljs-built_in">GetElem_DuL</span>(L,i)))   <span class="hljs-comment">//在L中确定第i个元素的位置指针p</span><br>        <span class="hljs-keyword">return</span> ERROR;           <span class="hljs-comment">//p为NULL时，第i个元素不存在</span><br>    p-&gt;prior-&gt;next = p-&gt;next;   <span class="hljs-comment">//修改被删结点的前驱结点的后继指针</span><br>    p-&gt;next-&gt;prior = p-&gt;prior;  <span class="hljs-comment">//修改被删结点的后继结点的前驱指针</span><br>    <span class="hljs-keyword">delete</span> p;                   <span class="hljs-comment">//释放被删结点的空间</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="顺序表和链表比较"><a href="#顺序表和链表比较" class="headerlink" title="顺序表和链表比较"></a>顺序表和链表比较</h2><h3 id="空间性能比较"><a href="#空间性能比较" class="headerlink" title="空间性能比较"></a>空间性能比较</h3><h4 id="存储空间的分配"><a href="#存储空间的分配" class="headerlink" title="存储空间的分配"></a>存储空间的分配</h4><p>顺序表：存储空间必须预先分配，元素扩充受到限制，容易造成存储空间浪费或空间溢出。</p><p>链表：不需要预先分配空间，元素个数没有限制。</p><p><strong>结论</strong>：当线性表的长度变化较大，难以预估存储规模时，使用链表作为存储结构更好。</p><h4 id="存储密度的大小"><a href="#存储密度的大小" class="headerlink" title="存储密度的大小"></a>存储密度的大小</h4><p>链表每个结点要额外设置指针域，存储密度小于 1，而顺序表的存储密度为 1。</p><p><strong>结论</strong>：当线性表的长度变化不大，易于实先确定大小时，为了节约存储空间，使用顺序表作为存储结构更好。</p><h3 id="时间性能的比较"><a href="#时间性能的比较" class="headerlink" title="时间性能的比较"></a>时间性能的比较</h3><h4 id="存取元素的效率"><a href="#存取元素的效率" class="headerlink" title="存取元素的效率"></a>存取元素的效率</h4><p>顺序表：由数组实现，随机存取结构，时间复杂度为 O(1)，取值操作效率高。</p><p>链表：顺序存取结构，只能遍历链表，时间复杂度为 O(n)，取值操作效率低。</p><p><strong>结论</strong>：如果主要操作和元素位置紧密相关，很少插入或删除时，使用顺序表作为存储结构更好。</p><h4 id="插入和删除效率"><a href="#插入和删除效率" class="headerlink" title="插入和删除效率"></a>插入和删除效率</h4><p>链表：确定插入或删除位置后，插入或删除操作无需移动位置，只需要修改指针，时间复杂度为 O(1)。</p><p>顺序表：插入或删除平均要移动一半的结点，时间复杂度为 O(n)。</p><p><strong>结论</strong>：频繁进行插入或删除操作的线性表，使用链表作为存储结构更好。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>线性表的逻辑结构特性是指数据元素之间存在着线性关系，在计算机中表示这种关系的两类不同的存储结构是顺序存储结构（顺序表） 和链式存储结构（链表）。</li><li>对千顺序表，元素存储的相邻位置反映出其逻辑上的线性关系，可借助数组来表示。给定数组的下标， 便可以存取相应的元素，可称为随机存取结构。而对千链表，是依靠指针来反映其线性逻辑关系的，链表结点的存取都要从头指针开始，顺链而行，所以不属千随机存取结构，可称之为顺序存取结构。不同的特点使得顺序表和链表有不同的适用情况。<br><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231612782.png"></li><li>对于链表，除了常用的单链表外，在本章还讨论了两种不同形式的链表， 即循环链表和双向链表，它们有不同的应用场合。<br><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231612999.png"></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>引入</title>
    <link href="/2025/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BC%95%E5%85%A5/"/>
    <url>/2025/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BC%95%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h2><h3 id="数据、数据元素、数据项和数据对象"><a href="#数据、数据元素、数据项和数据对象" class="headerlink" title="数据、数据元素、数据项和数据对象"></a>数据、数据元素、数据项和数据对象</h3><ul><li>数据：客观事物的符号表示，所有能输入到计算机中并被计算机程序处理的符号的总称</li><li>数据元素：数据的基本单位，在计算机中通常作为一个整体进行考虑和处理</li><li>数据项：组成数据元素的、有独立含义的、不可分割的最小单位</li><li>数据对象：性质相同的数据元素的集合，数据的一个子集</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合</p><p>数据结构包含逻辑结构和存储结构</p><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>数据的逻辑结构是从逻辑关系上描述数据，与数据的存储无关，是独立于计算机的，可以看作是从具体问题抽象出来的数学模型</p><p>逻辑结构包含两个要素：</p><ul><li>数据元素：数据的基本单位，在计算机中通常作为一个整体进行考虑和处理</li><li>关系：数据元素间的逻辑关系</li></ul><p>关系通常由四种基本结构：</p><ul><li>集合结构</li><li>线性结构</li><li>树结构</li><li>图结构</li></ul><p>其中集合结构、树结构和图结构都属于非线性结构</p><p>线性结构包括线性表、栈和队列、字符串、数组、广义表。</p><p>非线性结构包括树和二叉树、有向图和无向图</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231604037.png"></p><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>数据的存储结构为数据对象在计算机中的存储表示。也被称作物理结构。</p><p>把数据对象存储到计算机时，既要存储各数据元素的数据，又要存储数据元素之间的逻辑关系。</p><p>数据元素在计算机中有两种基本的存储结构：</p><ul><li>顺序存储结构</li><li>链式存储结构</li></ul><h5 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h5><p>顺序结构结组元素在存储器中的相对位置来表示数据元素之间的逻辑关系，通常借助程序设计语言的数组类型来描述。需要一整块连续的存储空间</p><h5 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h5><p>链式存储结构不需要一整块存储空间，但为了表示每个节点之间的关系，需要给每个节点附加指针字段，用于存放后继元素的存储地址，通常结组程序设计语言的指针类型来描述</p><h3 id="数据类型和抽象数据类型"><a href="#数据类型和抽象数据类型" class="headerlink" title="数据类型和抽象数据类型"></a>数据类型和抽象数据类型</h3><p>数据类型：一个值的集合和定义在这个值集上的一组操作的总称</p><p>抽象数据类型（ADT）： 由用户定义的、表示应用问题的数学模型以及定义在这个模型上的一组操作的总称。</p><p>抽象数据类型具体包括三部分：</p><ul><li>数据对象</li><li>数据对象上关系的集合</li><li>对数据对象的基本操作的集合</li></ul><p>抽象数据类型的定义格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">ADT 抽象数据类型名&#123;<br>  数据对象:&lt;数据对象的定义&gt;<br>  数据关系:&lt;数据关系的定义&gt;<br>  基本操作:&lt;基本操作的定义&gt;<br>&#125;ADT 抽象数据类型名<br></code></pre></td></tr></table></figure><p>数据对象和数据关系的定义采用数学符号和自然语言描述，基本操作的定义格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">基本操作名(参数表)<br>  初始条件:&lt;初始条件描述&gt;<br>  操作结果:&lt;操作结果描述&gt;<br></code></pre></td></tr></table></figure><p><code>基本操作</code>有两种参数：</p><ul><li>赋值参数：只为操作提供输入值</li><li>引用参数：以”&amp;”打头，除可提供输入值外，还将返回操作结果</li></ul><p><code>初始条件</code>描述了操作执行之前数据结构和参数应满足的条件。<code>操作结果</code>说明了正常完成之后，数据结构的变化状况和应返回的结果</p><h2 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h2><h3 id="算法的定义及特性"><a href="#算法的定义及特性" class="headerlink" title="算法的定义及特性"></a>算法的定义及特性</h3><p>算法是为了解决某类问题而规定的一个有限长的操作序列</p><p>算法必须具有以下五个特性：</p><ul><li>有穷性</li><li>确定性</li><li>可行性</li><li>输入</li><li>输出</li></ul><h3 id="评价算法优劣的基本标准"><a href="#评价算法优劣的基本标准" class="headerlink" title="评价算法优劣的基本标准"></a>评价算法优劣的基本标准</h3><ul><li>正确性</li><li>可读性</li><li>健壮性</li><li>高效性</li></ul><h3 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h3><p>衡量算法效率的方法主要分为两类：</p><ul><li>事后统计法</li><li>事前分析估算法</li></ul><p>通常采用事前分析估算法</p><h4 id="问题规模和语句频度"><a href="#问题规模和语句频度" class="headerlink" title="问题规模和语句频度"></a>问题规模和语句频度</h4><p>问题规模是影响算法时间代价的最主要因素，是问题大小的本质表示，一般用整数 n 表示。</p><p>语句频度是一条语句的重复执行次数，语句的执行时间是该条语句的重复执行次数和执行一次所需要的时间</p><p>算法分析并非精确统计算法实际执行所需要的时间，而是针对算法中语句的执行次数做出估计，从中得到算法执行时间的信息</p><h4 id="算法的时间复杂度定义"><a href="#算法的时间复杂度定义" class="headerlink" title="算法的时间复杂度定义"></a>算法的时间复杂度定义</h4><p>为了客观地反映一个算法的执行时间，可以只用算法中的“基本语句”的执行次数来度量算法的工作量。“基本语句”指的是算法中重复执行次数和算法执行时间成正比的语句，它对算法运行时间的贡献最大。算法中基本语句重复执行的次数是问题规模 n 的某个函数 f(n)，用“O”表示数量级，算法的时间量度记作<code>T(n)=O(f(n))</code>。算法执行时间的增长率与 f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度。</p><p>定理：若<img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231605589.png">是一个 m 次多项式，则 T(n)&#x3D;O(n<sup>m</sup>)</p><p>以上定理说明，在计算算法时间复杂度时，可以忽略所有低次幂和最高次幂的系数</p><h4 id="最好、最坏和平均时间复杂度"><a href="#最好、最坏和平均时间复杂度" class="headerlink" title="最好、最坏和平均时间复杂度"></a>最好、最坏和平均时间复杂度</h4><p>最好时间复杂度：算法计算量可能达到的最小值</p><p>最坏时间复杂度：算法计算量可能达到的最大值</p><p>平均时间复杂度：算法在所有可能情况下，按照输入实例以等概率出现时，算法计算量的加权平均值</p><p>通常只讨论算法在最坏情况下的时间复杂度</p><h3 id="算法的空间复杂度"><a href="#算法的空间复杂度" class="headerlink" title="算法的空间复杂度"></a>算法的空间复杂度</h3><p>渐近空间复杂度简称空间复杂度，是问题规模 n 的函数，记作<img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231605856.png"></p><p>讨论算法的空间复杂度只需要分析该算法在实现时所需要的辅助空间就可以了。有的算法需要占用临时的工作单元数与问题规模 n 有关，例如归并排序算法。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>数据结构是一门研究非数值计算程序设计中操作对象， 以及这些对象之间的关系和操作的学科</li><li>数据结构包括两个方面的内容：数据的逻辑结构和存储结构。同一逻辑结构采用不同的存储方法， 可以得到不同的存储结构</li></ul><ol><li>逻辑结构是从具体问题抽象出来的数学模型，从逻辑关系上描述数据，它与数据的存储无关。根据数据元素之间关系的不同特性， 通常有四类基本逻辑结构：集合结构、线性结构、树形结构和图状结构</li><li>存储结构是逻辑结构在计算机中的存储表示，有两类存储结构：顺序存储结构和链式存储结构</li></ol><ul><li>抽象数据类型是指由用户定义的、表示应用问题的数学模型， 以及定义在这个模型上的一组操作的总称， 具体包括三部分：数据对象、数据对象上关系的集合， 以及对数据对象的基本操作的集合</li><li>算法是为了解决某类问题而规定的一个有限长的操作序列。算法具有五个特性：有穷性、确定性、可行性、输入和输出。一个算法的优劣应该从以下四方面来评价：正确性、可读性、健壮性和高效性</li><li>算法分析的两个主要方面是分析算法的时间复杂度和空间复杂度， 以考察算法的时间和空间效率。一般情况下， 鉴于运算空间较为充足， 故将算法的时间复杂度作为分析的重点。算法执行时间的数量级称为算法的渐近时间复杂度，<code>T(n) = 0(f(n))</code>, 它表示随着问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同， 简称时间复杂度</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>blog 上传出现 github css js 404 问题解决方案（自用）</title>
    <link href="/2025/03/23/blog-%E4%B8%8A%E4%BC%A0%E5%87%BA%E7%8E%B0-github-css-js-404-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E8%87%AA%E7%94%A8%EF%BC%89/"/>
    <url>/2025/03/23/blog-%E4%B8%8A%E4%BC%A0%E5%87%BA%E7%8E%B0-github-css-js-404-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E8%87%AA%E7%94%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本地运行 blog 正常，但是上传到 GitHub 之后出现问题，例如：</p><p><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231433008.png"></p><p>排查问题发现是 github css js 404 的问题，有以下解决方案：</p><ol><li><p>查看 URL 是否正确<br><code>url: https://nice2006.github.io/</code><br><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231434265.png"></p></li><li><p>在博客的 source 目录里加入.nojekyll 文件，然后更改 Hexo 的_config.yml 加入以下配置：<br><img src="https://cdn.jsdelivr.net/gh/nice2006/blog-imgs@master/img/202503231435407.png"><br>还不行的话在.deploy_git 里加入.nojekyll 文件。</p></li><li><p>在博客 source 目录下创建 assets&#x2F;static 文件夹，将<a href="https://github.com/dr34m-cn/hexo/tree/master/source/assets/static">此链接</a>下的内容全部拷贝到 assets&#x2F;static 文件夹中。<br>将_config.fluid.yml 文件中的 static_prefix 部分改成如下这样：</p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">static_prefix:</span><br>  <span class="hljs-comment"># 内部静态</span><br>  <span class="hljs-comment"># Internal static</span><br>  <span class="hljs-attr">internal_js:</span> <span class="hljs-string">/js</span><br>  <span class="hljs-attr">internal_css:</span> <span class="hljs-string">/css</span><br>  <span class="hljs-attr">internal_img:</span> <span class="hljs-string">/img</span><br><br>  <span class="hljs-attr">anchor:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">github_markdown:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">jquery:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">bootstrap:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">prismjs:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">tocbot:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">typed:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">fancybox:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">nprogress:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">mathjax:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">katex:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">busuanzi:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">clipboard:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">mermaid:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">valine:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">waline:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">gitalk:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">disqusjs:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">twikoo:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">discuss:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">hint:</span> <span class="hljs-string">/assets/static/</span><br><br>  <span class="hljs-attr">moment:</span> <span class="hljs-string">/assets/static/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂物</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设置文章信息（自用）</title>
    <link href="/2025/03/23/%E8%AE%BE%E7%BD%AE%E6%96%87%E7%AB%A0%E4%BF%A1%E6%81%AF%EF%BC%88%E8%87%AA%E7%94%A8%EF%BC%89/"/>
    <url>/2025/03/23/%E8%AE%BE%E7%BD%AE%E6%96%87%E7%AB%A0%E4%BF%A1%E6%81%AF%EF%BC%88%E8%87%AA%E7%94%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>Front-matter 是文件开头的 YAML 或 JSON 代码块，用于配置写作设置。 以 YAML 格式书写时，Front-matter 以三个破折号结束；以 JSON 格式书写时，Front-matter 以三个分号结束。</p><h3 id="设置-默认值"><a href="#设置-默认值" class="headerlink" title="设置 &amp; 默认值"></a>设置 &amp; 默认值</h3><table><thead><tr><th align="left">设置</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td><td align="left"><a href="https://hexo.io/docs/configuration#Writing"><code>config.default_layout</code></a></td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td><td align="left">文章的文件名</td></tr><tr><td align="left"><code>date</code></td><td align="left">建立日期</td><td align="left">文件建立日期</td></tr><tr><td align="left"><code>updated</code></td><td align="left">更新日期</td><td align="left">文件更新日期</td></tr><tr><td align="left"><code>comments</code></td><td align="left">开启文章的评论功能</td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>tags</code></td><td align="left">标签（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>categories</code></td><td align="left">分类（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">覆盖文章的永久链接. 永久链接应该以 <code>/</code> 或 <code>.html</code> 结尾</td><td align="left"><code>null</code></td></tr><tr><td align="left"><code>excerpt</code></td><td align="left">纯文本的页面摘要。 使用 <a href="https://hexo.io/zh-cn/docs/tag-plugins#%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%92%8C%E6%88%AA%E6%96%AD">该插件</a> 来格式化文本</td><td align="left"></td></tr><tr><td align="left"><code>disableNunjucks</code></td><td align="left">启用时禁用 Nunjucks 标签 <code>&#123;&#123; &#125;&#125;</code>&#x2F;<code>&#123;% %&#125;</code> 和 <a href="https://hexo.io/zh-cn/docs/tag-plugins">标签插件</a> 的渲染功能</td><td align="left">false</td></tr><tr><td align="left"><code>lang</code></td><td align="left">设置语言以覆盖 <a href="https://hexo.io/zh-cn/docs/internationalization#%E8%B7%AF%E5%BE%84">自动检测</a></td><td align="left">继承自 <code>_config.yml</code></td></tr><tr><td align="left"><code>published</code></td><td align="left">文章是否发布</td><td align="left">对于 <code>_posts</code> 下的文章为 <code>true</code>，对于 <code>_draft</code> 下的文章为 <code>false</code></td></tr></tbody></table><h2 id="隐藏文章"><a href="#隐藏文章" class="headerlink" title="隐藏文章"></a>隐藏文章</h2><p>如果想把某些文章隐藏，不在首页和其他归档分类页里展示，可以在文章开头 front-matter (opens new window)中配置 <code>hide: true</code> 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><span class="hljs-attr">hide:</span> <span class="hljs-literal">true</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure><h2 id="归档文章"><a href="#归档文章" class="headerlink" title="归档文章"></a>归档文章</h2><p>如果只是想让文章在首页隐藏，但仍需要在归档分类页里展示，可以在文章开头 front-matter (opens new window)中配置 <code>archive: true</code> 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><span class="hljs-attr">archive:</span> <span class="hljs-literal">true</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">以下是文章内容</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂物</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
